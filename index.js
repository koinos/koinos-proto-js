/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.koinos = (function() {
    
        /**
         * Namespace koinos.
         * @exports koinos
         * @namespace
         */
        var koinos = {};
    
        /**
         * bytes_type enum.
         * @name koinos.bytes_type
         * @enum {number}
         * @property {number} BASE64=0 BASE64 value
         * @property {number} BASE58=1 BASE58 value
         * @property {number} HEX=2 HEX value
         * @property {number} BLOCK_ID=3 BLOCK_ID value
         * @property {number} TRANSACTION_ID=4 TRANSACTION_ID value
         * @property {number} CONTRACT_ID=5 CONTRACT_ID value
         * @property {number} ADDRESS=6 ADDRESS value
         */
        koinos.bytes_type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "BASE64"] = 0;
            values[valuesById[1] = "BASE58"] = 1;
            values[valuesById[2] = "HEX"] = 2;
            values[valuesById[3] = "BLOCK_ID"] = 3;
            values[valuesById[4] = "TRANSACTION_ID"] = 4;
            values[valuesById[5] = "CONTRACT_ID"] = 5;
            values[valuesById[6] = "ADDRESS"] = 6;
            return values;
        })();
    
        koinos.contracts = (function() {
    
            /**
             * Namespace contracts.
             * @memberof koinos
             * @namespace
             */
            var contracts = {};
    
            contracts.claim = (function() {
    
                /**
                 * Namespace claim.
                 * @memberof koinos.contracts
                 * @namespace
                 */
                var claim = {};
    
                claim.claim_status = (function() {
    
                    /**
                     * Properties of a claim_status.
                     * @memberof koinos.contracts.claim
                     * @interface Iclaim_status
                     * @property {number|Long|null} [token_amount] claim_status token_amount
                     * @property {boolean|null} [claimed] claim_status claimed
                     */
    
                    /**
                     * Constructs a new claim_status.
                     * @memberof koinos.contracts.claim
                     * @classdesc Represents a claim_status.
                     * @implements Iclaim_status
                     * @constructor
                     * @param {koinos.contracts.claim.Iclaim_status=} [properties] Properties to set
                     */
                    function claim_status(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * claim_status token_amount.
                     * @member {number|Long} token_amount
                     * @memberof koinos.contracts.claim.claim_status
                     * @instance
                     */
                    claim_status.prototype.token_amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * claim_status claimed.
                     * @member {boolean} claimed
                     * @memberof koinos.contracts.claim.claim_status
                     * @instance
                     */
                    claim_status.prototype.claimed = false;
    
                    /**
                     * Creates a new claim_status instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_status=} [properties] Properties to set
                     * @returns {koinos.contracts.claim.claim_status} claim_status instance
                     */
                    claim_status.create = function create(properties) {
                        return new claim_status(properties);
                    };
    
                    /**
                     * Encodes the specified claim_status message. Does not implicitly {@link koinos.contracts.claim.claim_status.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_status} message claim_status message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    claim_status.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.token_amount != null && Object.hasOwnProperty.call(message, "token_amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.token_amount);
                        if (message.claimed != null && Object.hasOwnProperty.call(message, "claimed"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.claimed);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified claim_status message, length delimited. Does not implicitly {@link koinos.contracts.claim.claim_status.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_status} message claim_status message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    claim_status.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a claim_status message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.claim.claim_status} claim_status
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    claim_status.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.claim.claim_status();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.token_amount = reader.uint64();
                                break;
                            case 2:
                                message.claimed = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a claim_status message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.claim.claim_status} claim_status
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    claim_status.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a claim_status message.
                     * @function verify
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    claim_status.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.token_amount != null && message.hasOwnProperty("token_amount"))
                            if (!$util.isInteger(message.token_amount) && !(message.token_amount && $util.isInteger(message.token_amount.low) && $util.isInteger(message.token_amount.high)))
                                return "token_amount: integer|Long expected";
                        if (message.claimed != null && message.hasOwnProperty("claimed"))
                            if (typeof message.claimed !== "boolean")
                                return "claimed: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a claim_status message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.claim.claim_status} claim_status
                     */
                    claim_status.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.claim.claim_status)
                            return object;
                        var message = new $root.koinos.contracts.claim.claim_status();
                        if (object.token_amount != null)
                            if ($util.Long)
                                (message.token_amount = $util.Long.fromValue(object.token_amount)).unsigned = true;
                            else if (typeof object.token_amount === "string")
                                message.token_amount = parseInt(object.token_amount, 10);
                            else if (typeof object.token_amount === "number")
                                message.token_amount = object.token_amount;
                            else if (typeof object.token_amount === "object")
                                message.token_amount = new $util.LongBits(object.token_amount.low >>> 0, object.token_amount.high >>> 0).toNumber(true);
                        if (object.claimed != null)
                            message.claimed = Boolean(object.claimed);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a claim_status message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.claim.claim_status
                     * @static
                     * @param {koinos.contracts.claim.claim_status} message claim_status
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    claim_status.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.token_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.token_amount = options.longs === String ? "0" : 0;
                            object.claimed = false;
                        }
                        if (message.token_amount != null && message.hasOwnProperty("token_amount"))
                            if (typeof message.token_amount === "number")
                                object.token_amount = options.longs === String ? String(message.token_amount) : message.token_amount;
                            else
                                object.token_amount = options.longs === String ? $util.Long.prototype.toString.call(message.token_amount) : options.longs === Number ? new $util.LongBits(message.token_amount.low >>> 0, message.token_amount.high >>> 0).toNumber(true) : message.token_amount;
                        if (message.claimed != null && message.hasOwnProperty("claimed"))
                            object.claimed = message.claimed;
                        return object;
                    };
    
                    /**
                     * Converts this claim_status to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.claim.claim_status
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    claim_status.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return claim_status;
                })();
    
                claim.claim_arguments = (function() {
    
                    /**
                     * Properties of a claim_arguments.
                     * @memberof koinos.contracts.claim
                     * @interface Iclaim_arguments
                     * @property {Uint8Array|null} [eth_address] claim_arguments eth_address
                     */
    
                    /**
                     * Constructs a new claim_arguments.
                     * @memberof koinos.contracts.claim
                     * @classdesc Represents a claim_arguments.
                     * @implements Iclaim_arguments
                     * @constructor
                     * @param {koinos.contracts.claim.Iclaim_arguments=} [properties] Properties to set
                     */
                    function claim_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * claim_arguments eth_address.
                     * @member {Uint8Array} eth_address
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @instance
                     */
                    claim_arguments.prototype.eth_address = $util.newBuffer([]);
    
                    /**
                     * Creates a new claim_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.claim.claim_arguments} claim_arguments instance
                     */
                    claim_arguments.create = function create(properties) {
                        return new claim_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified claim_arguments message. Does not implicitly {@link koinos.contracts.claim.claim_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_arguments} message claim_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    claim_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.eth_address != null && Object.hasOwnProperty.call(message, "eth_address"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.eth_address);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified claim_arguments message, length delimited. Does not implicitly {@link koinos.contracts.claim.claim_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_arguments} message claim_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    claim_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a claim_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.claim.claim_arguments} claim_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    claim_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.claim.claim_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.eth_address = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a claim_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.claim.claim_arguments} claim_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    claim_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a claim_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    claim_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                            if (!(message.eth_address && typeof message.eth_address.length === "number" || $util.isString(message.eth_address)))
                                return "eth_address: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a claim_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.claim.claim_arguments} claim_arguments
                     */
                    claim_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.claim.claim_arguments)
                            return object;
                        var message = new $root.koinos.contracts.claim.claim_arguments();
                        if (object.eth_address != null)
                            if (typeof object.eth_address === "string")
                                $util.base64.decode(object.eth_address, message.eth_address = $util.newBuffer($util.base64.length(object.eth_address)), 0);
                            else if (object.eth_address.length)
                                message.eth_address = object.eth_address;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a claim_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @static
                     * @param {koinos.contracts.claim.claim_arguments} message claim_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    claim_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.eth_address = "";
                            else {
                                object.eth_address = [];
                                if (options.bytes !== Array)
                                    object.eth_address = $util.newBuffer(object.eth_address);
                            }
                        if (message.eth_address != null && message.hasOwnProperty("eth_address"))
                            object.eth_address = options.bytes === String ? $util.base64.encode(message.eth_address, 0, message.eth_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.eth_address) : message.eth_address;
                        return object;
                    };
    
                    /**
                     * Converts this claim_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.claim.claim_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    claim_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return claim_arguments;
                })();
    
                claim.claim_result = (function() {
    
                    /**
                     * Properties of a claim_result.
                     * @memberof koinos.contracts.claim
                     * @interface Iclaim_result
                     */
    
                    /**
                     * Constructs a new claim_result.
                     * @memberof koinos.contracts.claim
                     * @classdesc Represents a claim_result.
                     * @implements Iclaim_result
                     * @constructor
                     * @param {koinos.contracts.claim.Iclaim_result=} [properties] Properties to set
                     */
                    function claim_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new claim_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_result=} [properties] Properties to set
                     * @returns {koinos.contracts.claim.claim_result} claim_result instance
                     */
                    claim_result.create = function create(properties) {
                        return new claim_result(properties);
                    };
    
                    /**
                     * Encodes the specified claim_result message. Does not implicitly {@link koinos.contracts.claim.claim_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_result} message claim_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    claim_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified claim_result message, length delimited. Does not implicitly {@link koinos.contracts.claim.claim_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {koinos.contracts.claim.Iclaim_result} message claim_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    claim_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a claim_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.claim.claim_result} claim_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    claim_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.claim.claim_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a claim_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.claim.claim_result} claim_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    claim_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a claim_result message.
                     * @function verify
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    claim_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a claim_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.claim.claim_result} claim_result
                     */
                    claim_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.claim.claim_result)
                            return object;
                        return new $root.koinos.contracts.claim.claim_result();
                    };
    
                    /**
                     * Creates a plain object from a claim_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.claim.claim_result
                     * @static
                     * @param {koinos.contracts.claim.claim_result} message claim_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    claim_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this claim_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.claim.claim_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    claim_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return claim_result;
                })();
    
                return claim;
            })();
    
            contracts.pob = (function() {
    
                /**
                 * Namespace pob.
                 * @memberof koinos.contracts
                 * @namespace
                 */
                var pob = {};
    
                pob.consensus_parameters = (function() {
    
                    /**
                     * Properties of a consensus_parameters.
                     * @memberof koinos.contracts.pob
                     * @interface Iconsensus_parameters
                     * @property {number|null} [target_annual_inflation_rate] consensus_parameters target_annual_inflation_rate
                     * @property {number|null} [target_burn_percent] consensus_parameters target_burn_percent
                     * @property {number|null} [target_block_interval] consensus_parameters target_block_interval
                     * @property {number|null} [quantum_length] consensus_parameters quantum_length
                     */
    
                    /**
                     * Constructs a new consensus_parameters.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a consensus_parameters.
                     * @implements Iconsensus_parameters
                     * @constructor
                     * @param {koinos.contracts.pob.Iconsensus_parameters=} [properties] Properties to set
                     */
                    function consensus_parameters(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * consensus_parameters target_annual_inflation_rate.
                     * @member {number} target_annual_inflation_rate
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @instance
                     */
                    consensus_parameters.prototype.target_annual_inflation_rate = 0;
    
                    /**
                     * consensus_parameters target_burn_percent.
                     * @member {number} target_burn_percent
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @instance
                     */
                    consensus_parameters.prototype.target_burn_percent = 0;
    
                    /**
                     * consensus_parameters target_block_interval.
                     * @member {number} target_block_interval
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @instance
                     */
                    consensus_parameters.prototype.target_block_interval = 0;
    
                    /**
                     * consensus_parameters quantum_length.
                     * @member {number} quantum_length
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @instance
                     */
                    consensus_parameters.prototype.quantum_length = 0;
    
                    /**
                     * Creates a new consensus_parameters instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {koinos.contracts.pob.Iconsensus_parameters=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.consensus_parameters} consensus_parameters instance
                     */
                    consensus_parameters.create = function create(properties) {
                        return new consensus_parameters(properties);
                    };
    
                    /**
                     * Encodes the specified consensus_parameters message. Does not implicitly {@link koinos.contracts.pob.consensus_parameters.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {koinos.contracts.pob.Iconsensus_parameters} message consensus_parameters message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    consensus_parameters.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.target_annual_inflation_rate != null && Object.hasOwnProperty.call(message, "target_annual_inflation_rate"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.target_annual_inflation_rate);
                        if (message.target_burn_percent != null && Object.hasOwnProperty.call(message, "target_burn_percent"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.target_burn_percent);
                        if (message.target_block_interval != null && Object.hasOwnProperty.call(message, "target_block_interval"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.target_block_interval);
                        if (message.quantum_length != null && Object.hasOwnProperty.call(message, "quantum_length"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.quantum_length);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified consensus_parameters message, length delimited. Does not implicitly {@link koinos.contracts.pob.consensus_parameters.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {koinos.contracts.pob.Iconsensus_parameters} message consensus_parameters message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    consensus_parameters.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a consensus_parameters message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.consensus_parameters} consensus_parameters
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    consensus_parameters.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.consensus_parameters();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.target_annual_inflation_rate = reader.uint32();
                                break;
                            case 2:
                                message.target_burn_percent = reader.uint32();
                                break;
                            case 3:
                                message.target_block_interval = reader.uint32();
                                break;
                            case 4:
                                message.quantum_length = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a consensus_parameters message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.consensus_parameters} consensus_parameters
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    consensus_parameters.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a consensus_parameters message.
                     * @function verify
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    consensus_parameters.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.target_annual_inflation_rate != null && message.hasOwnProperty("target_annual_inflation_rate"))
                            if (!$util.isInteger(message.target_annual_inflation_rate))
                                return "target_annual_inflation_rate: integer expected";
                        if (message.target_burn_percent != null && message.hasOwnProperty("target_burn_percent"))
                            if (!$util.isInteger(message.target_burn_percent))
                                return "target_burn_percent: integer expected";
                        if (message.target_block_interval != null && message.hasOwnProperty("target_block_interval"))
                            if (!$util.isInteger(message.target_block_interval))
                                return "target_block_interval: integer expected";
                        if (message.quantum_length != null && message.hasOwnProperty("quantum_length"))
                            if (!$util.isInteger(message.quantum_length))
                                return "quantum_length: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a consensus_parameters message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.consensus_parameters} consensus_parameters
                     */
                    consensus_parameters.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.consensus_parameters)
                            return object;
                        var message = new $root.koinos.contracts.pob.consensus_parameters();
                        if (object.target_annual_inflation_rate != null)
                            message.target_annual_inflation_rate = object.target_annual_inflation_rate >>> 0;
                        if (object.target_burn_percent != null)
                            message.target_burn_percent = object.target_burn_percent >>> 0;
                        if (object.target_block_interval != null)
                            message.target_block_interval = object.target_block_interval >>> 0;
                        if (object.quantum_length != null)
                            message.quantum_length = object.quantum_length >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a consensus_parameters message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @static
                     * @param {koinos.contracts.pob.consensus_parameters} message consensus_parameters
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    consensus_parameters.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.target_annual_inflation_rate = 0;
                            object.target_burn_percent = 0;
                            object.target_block_interval = 0;
                            object.quantum_length = 0;
                        }
                        if (message.target_annual_inflation_rate != null && message.hasOwnProperty("target_annual_inflation_rate"))
                            object.target_annual_inflation_rate = message.target_annual_inflation_rate;
                        if (message.target_burn_percent != null && message.hasOwnProperty("target_burn_percent"))
                            object.target_burn_percent = message.target_burn_percent;
                        if (message.target_block_interval != null && message.hasOwnProperty("target_block_interval"))
                            object.target_block_interval = message.target_block_interval;
                        if (message.quantum_length != null && message.hasOwnProperty("quantum_length"))
                            object.quantum_length = message.quantum_length;
                        return object;
                    };
    
                    /**
                     * Converts this consensus_parameters to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.consensus_parameters
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    consensus_parameters.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return consensus_parameters;
                })();
    
                pob.public_key_record = (function() {
    
                    /**
                     * Properties of a public_key_record.
                     * @memberof koinos.contracts.pob
                     * @interface Ipublic_key_record
                     * @property {Uint8Array|null} [public_key] public_key_record public_key
                     */
    
                    /**
                     * Constructs a new public_key_record.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a public_key_record.
                     * @implements Ipublic_key_record
                     * @constructor
                     * @param {koinos.contracts.pob.Ipublic_key_record=} [properties] Properties to set
                     */
                    function public_key_record(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * public_key_record public_key.
                     * @member {Uint8Array} public_key
                     * @memberof koinos.contracts.pob.public_key_record
                     * @instance
                     */
                    public_key_record.prototype.public_key = $util.newBuffer([]);
    
                    /**
                     * Creates a new public_key_record instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {koinos.contracts.pob.Ipublic_key_record=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.public_key_record} public_key_record instance
                     */
                    public_key_record.create = function create(properties) {
                        return new public_key_record(properties);
                    };
    
                    /**
                     * Encodes the specified public_key_record message. Does not implicitly {@link koinos.contracts.pob.public_key_record.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {koinos.contracts.pob.Ipublic_key_record} message public_key_record message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public_key_record.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.public_key != null && Object.hasOwnProperty.call(message, "public_key"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.public_key);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified public_key_record message, length delimited. Does not implicitly {@link koinos.contracts.pob.public_key_record.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {koinos.contracts.pob.Ipublic_key_record} message public_key_record message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    public_key_record.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a public_key_record message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.public_key_record} public_key_record
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public_key_record.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.public_key_record();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.public_key = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a public_key_record message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.public_key_record} public_key_record
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    public_key_record.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a public_key_record message.
                     * @function verify
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    public_key_record.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.public_key != null && message.hasOwnProperty("public_key"))
                            if (!(message.public_key && typeof message.public_key.length === "number" || $util.isString(message.public_key)))
                                return "public_key: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a public_key_record message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.public_key_record} public_key_record
                     */
                    public_key_record.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.public_key_record)
                            return object;
                        var message = new $root.koinos.contracts.pob.public_key_record();
                        if (object.public_key != null)
                            if (typeof object.public_key === "string")
                                $util.base64.decode(object.public_key, message.public_key = $util.newBuffer($util.base64.length(object.public_key)), 0);
                            else if (object.public_key.length)
                                message.public_key = object.public_key;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a public_key_record message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.public_key_record
                     * @static
                     * @param {koinos.contracts.pob.public_key_record} message public_key_record
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    public_key_record.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.public_key = "";
                            else {
                                object.public_key = [];
                                if (options.bytes !== Array)
                                    object.public_key = $util.newBuffer(object.public_key);
                            }
                        if (message.public_key != null && message.hasOwnProperty("public_key"))
                            object.public_key = options.bytes === String ? $util.base64.encode(message.public_key, 0, message.public_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_key) : message.public_key;
                        return object;
                    };
    
                    /**
                     * Converts this public_key_record to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.public_key_record
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    public_key_record.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return public_key_record;
                })();
    
                pob.metadata = (function() {
    
                    /**
                     * Properties of a metadata.
                     * @memberof koinos.contracts.pob
                     * @interface Imetadata
                     * @property {Uint8Array|null} [seed] metadata seed
                     * @property {Uint8Array|null} [difficulty] metadata difficulty
                     * @property {number|Long|null} [last_block_time] metadata last_block_time
                     */
    
                    /**
                     * Constructs a new metadata.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a metadata.
                     * @implements Imetadata
                     * @constructor
                     * @param {koinos.contracts.pob.Imetadata=} [properties] Properties to set
                     */
                    function metadata(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * metadata seed.
                     * @member {Uint8Array} seed
                     * @memberof koinos.contracts.pob.metadata
                     * @instance
                     */
                    metadata.prototype.seed = $util.newBuffer([]);
    
                    /**
                     * metadata difficulty.
                     * @member {Uint8Array} difficulty
                     * @memberof koinos.contracts.pob.metadata
                     * @instance
                     */
                    metadata.prototype.difficulty = $util.newBuffer([]);
    
                    /**
                     * metadata last_block_time.
                     * @member {number|Long} last_block_time
                     * @memberof koinos.contracts.pob.metadata
                     * @instance
                     */
                    metadata.prototype.last_block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new metadata instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {koinos.contracts.pob.Imetadata=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.metadata} metadata instance
                     */
                    metadata.create = function create(properties) {
                        return new metadata(properties);
                    };
    
                    /**
                     * Encodes the specified metadata message. Does not implicitly {@link koinos.contracts.pob.metadata.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {koinos.contracts.pob.Imetadata} message metadata message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    metadata.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.seed);
                        if (message.difficulty != null && Object.hasOwnProperty.call(message, "difficulty"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.difficulty);
                        if (message.last_block_time != null && Object.hasOwnProperty.call(message, "last_block_time"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.last_block_time);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified metadata message, length delimited. Does not implicitly {@link koinos.contracts.pob.metadata.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {koinos.contracts.pob.Imetadata} message metadata message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    metadata.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a metadata message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.metadata} metadata
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    metadata.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.metadata();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.seed = reader.bytes();
                                break;
                            case 2:
                                message.difficulty = reader.bytes();
                                break;
                            case 3:
                                message.last_block_time = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a metadata message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.metadata} metadata
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    metadata.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a metadata message.
                     * @function verify
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    metadata.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.seed != null && message.hasOwnProperty("seed"))
                            if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                                return "seed: buffer expected";
                        if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                            if (!(message.difficulty && typeof message.difficulty.length === "number" || $util.isString(message.difficulty)))
                                return "difficulty: buffer expected";
                        if (message.last_block_time != null && message.hasOwnProperty("last_block_time"))
                            if (!$util.isInteger(message.last_block_time) && !(message.last_block_time && $util.isInteger(message.last_block_time.low) && $util.isInteger(message.last_block_time.high)))
                                return "last_block_time: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a metadata message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.metadata} metadata
                     */
                    metadata.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.metadata)
                            return object;
                        var message = new $root.koinos.contracts.pob.metadata();
                        if (object.seed != null)
                            if (typeof object.seed === "string")
                                $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                            else if (object.seed.length)
                                message.seed = object.seed;
                        if (object.difficulty != null)
                            if (typeof object.difficulty === "string")
                                $util.base64.decode(object.difficulty, message.difficulty = $util.newBuffer($util.base64.length(object.difficulty)), 0);
                            else if (object.difficulty.length)
                                message.difficulty = object.difficulty;
                        if (object.last_block_time != null)
                            if ($util.Long)
                                (message.last_block_time = $util.Long.fromValue(object.last_block_time)).unsigned = true;
                            else if (typeof object.last_block_time === "string")
                                message.last_block_time = parseInt(object.last_block_time, 10);
                            else if (typeof object.last_block_time === "number")
                                message.last_block_time = object.last_block_time;
                            else if (typeof object.last_block_time === "object")
                                message.last_block_time = new $util.LongBits(object.last_block_time.low >>> 0, object.last_block_time.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a metadata message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.metadata
                     * @static
                     * @param {koinos.contracts.pob.metadata} message metadata
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    metadata.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.seed = "";
                            else {
                                object.seed = [];
                                if (options.bytes !== Array)
                                    object.seed = $util.newBuffer(object.seed);
                            }
                            if (options.bytes === String)
                                object.difficulty = "";
                            else {
                                object.difficulty = [];
                                if (options.bytes !== Array)
                                    object.difficulty = $util.newBuffer(object.difficulty);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.last_block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.last_block_time = options.longs === String ? "0" : 0;
                        }
                        if (message.seed != null && message.hasOwnProperty("seed"))
                            object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
                        if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                            object.difficulty = options.bytes === String ? $util.base64.encode(message.difficulty, 0, message.difficulty.length) : options.bytes === Array ? Array.prototype.slice.call(message.difficulty) : message.difficulty;
                        if (message.last_block_time != null && message.hasOwnProperty("last_block_time"))
                            if (typeof message.last_block_time === "number")
                                object.last_block_time = options.longs === String ? String(message.last_block_time) : message.last_block_time;
                            else
                                object.last_block_time = options.longs === String ? $util.Long.prototype.toString.call(message.last_block_time) : options.longs === Number ? new $util.LongBits(message.last_block_time.low >>> 0, message.last_block_time.high >>> 0).toNumber(true) : message.last_block_time;
                        return object;
                    };
    
                    /**
                     * Converts this metadata to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.metadata
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    metadata.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return metadata;
                })();
    
                pob.signature_data = (function() {
    
                    /**
                     * Properties of a signature_data.
                     * @memberof koinos.contracts.pob
                     * @interface Isignature_data
                     * @property {Uint8Array|null} [vrf_proof] signature_data vrf_proof
                     * @property {Uint8Array|null} [vrf_hash] signature_data vrf_hash
                     * @property {Uint8Array|null} [signature] signature_data signature
                     */
    
                    /**
                     * Constructs a new signature_data.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a signature_data.
                     * @implements Isignature_data
                     * @constructor
                     * @param {koinos.contracts.pob.Isignature_data=} [properties] Properties to set
                     */
                    function signature_data(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * signature_data vrf_proof.
                     * @member {Uint8Array} vrf_proof
                     * @memberof koinos.contracts.pob.signature_data
                     * @instance
                     */
                    signature_data.prototype.vrf_proof = $util.newBuffer([]);
    
                    /**
                     * signature_data vrf_hash.
                     * @member {Uint8Array} vrf_hash
                     * @memberof koinos.contracts.pob.signature_data
                     * @instance
                     */
                    signature_data.prototype.vrf_hash = $util.newBuffer([]);
    
                    /**
                     * signature_data signature.
                     * @member {Uint8Array} signature
                     * @memberof koinos.contracts.pob.signature_data
                     * @instance
                     */
                    signature_data.prototype.signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new signature_data instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {koinos.contracts.pob.Isignature_data=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.signature_data} signature_data instance
                     */
                    signature_data.create = function create(properties) {
                        return new signature_data(properties);
                    };
    
                    /**
                     * Encodes the specified signature_data message. Does not implicitly {@link koinos.contracts.pob.signature_data.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {koinos.contracts.pob.Isignature_data} message signature_data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    signature_data.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.vrf_proof != null && Object.hasOwnProperty.call(message, "vrf_proof"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.vrf_proof);
                        if (message.vrf_hash != null && Object.hasOwnProperty.call(message, "vrf_hash"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.vrf_hash);
                        if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified signature_data message, length delimited. Does not implicitly {@link koinos.contracts.pob.signature_data.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {koinos.contracts.pob.Isignature_data} message signature_data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    signature_data.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a signature_data message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.signature_data} signature_data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    signature_data.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.signature_data();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.vrf_proof = reader.bytes();
                                break;
                            case 2:
                                message.vrf_hash = reader.bytes();
                                break;
                            case 3:
                                message.signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a signature_data message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.signature_data} signature_data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    signature_data.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a signature_data message.
                     * @function verify
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    signature_data.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.vrf_proof != null && message.hasOwnProperty("vrf_proof"))
                            if (!(message.vrf_proof && typeof message.vrf_proof.length === "number" || $util.isString(message.vrf_proof)))
                                return "vrf_proof: buffer expected";
                        if (message.vrf_hash != null && message.hasOwnProperty("vrf_hash"))
                            if (!(message.vrf_hash && typeof message.vrf_hash.length === "number" || $util.isString(message.vrf_hash)))
                                return "vrf_hash: buffer expected";
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                                return "signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a signature_data message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.signature_data} signature_data
                     */
                    signature_data.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.signature_data)
                            return object;
                        var message = new $root.koinos.contracts.pob.signature_data();
                        if (object.vrf_proof != null)
                            if (typeof object.vrf_proof === "string")
                                $util.base64.decode(object.vrf_proof, message.vrf_proof = $util.newBuffer($util.base64.length(object.vrf_proof)), 0);
                            else if (object.vrf_proof.length)
                                message.vrf_proof = object.vrf_proof;
                        if (object.vrf_hash != null)
                            if (typeof object.vrf_hash === "string")
                                $util.base64.decode(object.vrf_hash, message.vrf_hash = $util.newBuffer($util.base64.length(object.vrf_hash)), 0);
                            else if (object.vrf_hash.length)
                                message.vrf_hash = object.vrf_hash;
                        if (object.signature != null)
                            if (typeof object.signature === "string")
                                $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                            else if (object.signature.length)
                                message.signature = object.signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a signature_data message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.signature_data
                     * @static
                     * @param {koinos.contracts.pob.signature_data} message signature_data
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    signature_data.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.vrf_proof = "";
                            else {
                                object.vrf_proof = [];
                                if (options.bytes !== Array)
                                    object.vrf_proof = $util.newBuffer(object.vrf_proof);
                            }
                            if (options.bytes === String)
                                object.vrf_hash = "";
                            else {
                                object.vrf_hash = [];
                                if (options.bytes !== Array)
                                    object.vrf_hash = $util.newBuffer(object.vrf_hash);
                            }
                            if (options.bytes === String)
                                object.signature = "";
                            else {
                                object.signature = [];
                                if (options.bytes !== Array)
                                    object.signature = $util.newBuffer(object.signature);
                            }
                        }
                        if (message.vrf_proof != null && message.hasOwnProperty("vrf_proof"))
                            object.vrf_proof = options.bytes === String ? $util.base64.encode(message.vrf_proof, 0, message.vrf_proof.length) : options.bytes === Array ? Array.prototype.slice.call(message.vrf_proof) : message.vrf_proof;
                        if (message.vrf_hash != null && message.hasOwnProperty("vrf_hash"))
                            object.vrf_hash = options.bytes === String ? $util.base64.encode(message.vrf_hash, 0, message.vrf_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.vrf_hash) : message.vrf_hash;
                        if (message.signature != null && message.hasOwnProperty("signature"))
                            object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                        return object;
                    };
    
                    /**
                     * Converts this signature_data to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.signature_data
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    signature_data.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return signature_data;
                })();
    
                pob.vrf_payload = (function() {
    
                    /**
                     * Properties of a vrf_payload.
                     * @memberof koinos.contracts.pob
                     * @interface Ivrf_payload
                     * @property {Uint8Array|null} [seed] vrf_payload seed
                     * @property {number|Long|null} [block_time] vrf_payload block_time
                     */
    
                    /**
                     * Constructs a new vrf_payload.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a vrf_payload.
                     * @implements Ivrf_payload
                     * @constructor
                     * @param {koinos.contracts.pob.Ivrf_payload=} [properties] Properties to set
                     */
                    function vrf_payload(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * vrf_payload seed.
                     * @member {Uint8Array} seed
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @instance
                     */
                    vrf_payload.prototype.seed = $util.newBuffer([]);
    
                    /**
                     * vrf_payload block_time.
                     * @member {number|Long} block_time
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @instance
                     */
                    vrf_payload.prototype.block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new vrf_payload instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {koinos.contracts.pob.Ivrf_payload=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.vrf_payload} vrf_payload instance
                     */
                    vrf_payload.create = function create(properties) {
                        return new vrf_payload(properties);
                    };
    
                    /**
                     * Encodes the specified vrf_payload message. Does not implicitly {@link koinos.contracts.pob.vrf_payload.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {koinos.contracts.pob.Ivrf_payload} message vrf_payload message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    vrf_payload.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.seed);
                        if (message.block_time != null && Object.hasOwnProperty.call(message, "block_time"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_time);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified vrf_payload message, length delimited. Does not implicitly {@link koinos.contracts.pob.vrf_payload.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {koinos.contracts.pob.Ivrf_payload} message vrf_payload message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    vrf_payload.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a vrf_payload message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.vrf_payload} vrf_payload
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    vrf_payload.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.vrf_payload();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.seed = reader.bytes();
                                break;
                            case 2:
                                message.block_time = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a vrf_payload message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.vrf_payload} vrf_payload
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    vrf_payload.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a vrf_payload message.
                     * @function verify
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    vrf_payload.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.seed != null && message.hasOwnProperty("seed"))
                            if (!(message.seed && typeof message.seed.length === "number" || $util.isString(message.seed)))
                                return "seed: buffer expected";
                        if (message.block_time != null && message.hasOwnProperty("block_time"))
                            if (!$util.isInteger(message.block_time) && !(message.block_time && $util.isInteger(message.block_time.low) && $util.isInteger(message.block_time.high)))
                                return "block_time: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a vrf_payload message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.vrf_payload} vrf_payload
                     */
                    vrf_payload.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.vrf_payload)
                            return object;
                        var message = new $root.koinos.contracts.pob.vrf_payload();
                        if (object.seed != null)
                            if (typeof object.seed === "string")
                                $util.base64.decode(object.seed, message.seed = $util.newBuffer($util.base64.length(object.seed)), 0);
                            else if (object.seed.length)
                                message.seed = object.seed;
                        if (object.block_time != null)
                            if ($util.Long)
                                (message.block_time = $util.Long.fromValue(object.block_time)).unsigned = true;
                            else if (typeof object.block_time === "string")
                                message.block_time = parseInt(object.block_time, 10);
                            else if (typeof object.block_time === "number")
                                message.block_time = object.block_time;
                            else if (typeof object.block_time === "object")
                                message.block_time = new $util.LongBits(object.block_time.low >>> 0, object.block_time.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a vrf_payload message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @static
                     * @param {koinos.contracts.pob.vrf_payload} message vrf_payload
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    vrf_payload.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.seed = "";
                            else {
                                object.seed = [];
                                if (options.bytes !== Array)
                                    object.seed = $util.newBuffer(object.seed);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.block_time = options.longs === String ? "0" : 0;
                        }
                        if (message.seed != null && message.hasOwnProperty("seed"))
                            object.seed = options.bytes === String ? $util.base64.encode(message.seed, 0, message.seed.length) : options.bytes === Array ? Array.prototype.slice.call(message.seed) : message.seed;
                        if (message.block_time != null && message.hasOwnProperty("block_time"))
                            if (typeof message.block_time === "number")
                                object.block_time = options.longs === String ? String(message.block_time) : message.block_time;
                            else
                                object.block_time = options.longs === String ? $util.Long.prototype.toString.call(message.block_time) : options.longs === Number ? new $util.LongBits(message.block_time.low >>> 0, message.block_time.high >>> 0).toNumber(true) : message.block_time;
                        return object;
                    };
    
                    /**
                     * Converts this vrf_payload to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.vrf_payload
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    vrf_payload.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return vrf_payload;
                })();
    
                pob.register_public_key_arguments = (function() {
    
                    /**
                     * Properties of a register_public_key_arguments.
                     * @memberof koinos.contracts.pob
                     * @interface Iregister_public_key_arguments
                     * @property {Uint8Array|null} [producer] register_public_key_arguments producer
                     * @property {Uint8Array|null} [public_key] register_public_key_arguments public_key
                     */
    
                    /**
                     * Constructs a new register_public_key_arguments.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a register_public_key_arguments.
                     * @implements Iregister_public_key_arguments
                     * @constructor
                     * @param {koinos.contracts.pob.Iregister_public_key_arguments=} [properties] Properties to set
                     */
                    function register_public_key_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * register_public_key_arguments producer.
                     * @member {Uint8Array} producer
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @instance
                     */
                    register_public_key_arguments.prototype.producer = $util.newBuffer([]);
    
                    /**
                     * register_public_key_arguments public_key.
                     * @member {Uint8Array} public_key
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @instance
                     */
                    register_public_key_arguments.prototype.public_key = $util.newBuffer([]);
    
                    /**
                     * Creates a new register_public_key_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.register_public_key_arguments} register_public_key_arguments instance
                     */
                    register_public_key_arguments.create = function create(properties) {
                        return new register_public_key_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified register_public_key_arguments message. Does not implicitly {@link koinos.contracts.pob.register_public_key_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_arguments} message register_public_key_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    register_public_key_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.producer != null && Object.hasOwnProperty.call(message, "producer"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.producer);
                        if (message.public_key != null && Object.hasOwnProperty.call(message, "public_key"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.public_key);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified register_public_key_arguments message, length delimited. Does not implicitly {@link koinos.contracts.pob.register_public_key_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_arguments} message register_public_key_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    register_public_key_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a register_public_key_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.register_public_key_arguments} register_public_key_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    register_public_key_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.register_public_key_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.producer = reader.bytes();
                                break;
                            case 2:
                                message.public_key = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a register_public_key_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.register_public_key_arguments} register_public_key_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    register_public_key_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a register_public_key_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    register_public_key_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.producer != null && message.hasOwnProperty("producer"))
                            if (!(message.producer && typeof message.producer.length === "number" || $util.isString(message.producer)))
                                return "producer: buffer expected";
                        if (message.public_key != null && message.hasOwnProperty("public_key"))
                            if (!(message.public_key && typeof message.public_key.length === "number" || $util.isString(message.public_key)))
                                return "public_key: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a register_public_key_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.register_public_key_arguments} register_public_key_arguments
                     */
                    register_public_key_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.register_public_key_arguments)
                            return object;
                        var message = new $root.koinos.contracts.pob.register_public_key_arguments();
                        if (object.producer != null)
                            if (typeof object.producer === "string")
                                $util.base64.decode(object.producer, message.producer = $util.newBuffer($util.base64.length(object.producer)), 0);
                            else if (object.producer.length)
                                message.producer = object.producer;
                        if (object.public_key != null)
                            if (typeof object.public_key === "string")
                                $util.base64.decode(object.public_key, message.public_key = $util.newBuffer($util.base64.length(object.public_key)), 0);
                            else if (object.public_key.length)
                                message.public_key = object.public_key;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a register_public_key_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @static
                     * @param {koinos.contracts.pob.register_public_key_arguments} message register_public_key_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    register_public_key_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.producer = "";
                            else {
                                object.producer = [];
                                if (options.bytes !== Array)
                                    object.producer = $util.newBuffer(object.producer);
                            }
                            if (options.bytes === String)
                                object.public_key = "";
                            else {
                                object.public_key = [];
                                if (options.bytes !== Array)
                                    object.public_key = $util.newBuffer(object.public_key);
                            }
                        }
                        if (message.producer != null && message.hasOwnProperty("producer"))
                            object.producer = options.bytes === String ? $util.base64.encode(message.producer, 0, message.producer.length) : options.bytes === Array ? Array.prototype.slice.call(message.producer) : message.producer;
                        if (message.public_key != null && message.hasOwnProperty("public_key"))
                            object.public_key = options.bytes === String ? $util.base64.encode(message.public_key, 0, message.public_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_key) : message.public_key;
                        return object;
                    };
    
                    /**
                     * Converts this register_public_key_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.register_public_key_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    register_public_key_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return register_public_key_arguments;
                })();
    
                pob.register_public_key_result = (function() {
    
                    /**
                     * Properties of a register_public_key_result.
                     * @memberof koinos.contracts.pob
                     * @interface Iregister_public_key_result
                     */
    
                    /**
                     * Constructs a new register_public_key_result.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a register_public_key_result.
                     * @implements Iregister_public_key_result
                     * @constructor
                     * @param {koinos.contracts.pob.Iregister_public_key_result=} [properties] Properties to set
                     */
                    function register_public_key_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new register_public_key_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_result=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.register_public_key_result} register_public_key_result instance
                     */
                    register_public_key_result.create = function create(properties) {
                        return new register_public_key_result(properties);
                    };
    
                    /**
                     * Encodes the specified register_public_key_result message. Does not implicitly {@link koinos.contracts.pob.register_public_key_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_result} message register_public_key_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    register_public_key_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified register_public_key_result message, length delimited. Does not implicitly {@link koinos.contracts.pob.register_public_key_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_result} message register_public_key_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    register_public_key_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a register_public_key_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.register_public_key_result} register_public_key_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    register_public_key_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.register_public_key_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a register_public_key_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.register_public_key_result} register_public_key_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    register_public_key_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a register_public_key_result message.
                     * @function verify
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    register_public_key_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a register_public_key_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.register_public_key_result} register_public_key_result
                     */
                    register_public_key_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.register_public_key_result)
                            return object;
                        return new $root.koinos.contracts.pob.register_public_key_result();
                    };
    
                    /**
                     * Creates a plain object from a register_public_key_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @static
                     * @param {koinos.contracts.pob.register_public_key_result} message register_public_key_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    register_public_key_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this register_public_key_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.register_public_key_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    register_public_key_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return register_public_key_result;
                })();
    
                pob.burn_arguments = (function() {
    
                    /**
                     * Properties of a burn_arguments.
                     * @memberof koinos.contracts.pob
                     * @interface Iburn_arguments
                     * @property {number|Long|null} [token_amount] burn_arguments token_amount
                     * @property {Uint8Array|null} [burn_address] burn_arguments burn_address
                     * @property {Uint8Array|null} [vhp_address] burn_arguments vhp_address
                     */
    
                    /**
                     * Constructs a new burn_arguments.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a burn_arguments.
                     * @implements Iburn_arguments
                     * @constructor
                     * @param {koinos.contracts.pob.Iburn_arguments=} [properties] Properties to set
                     */
                    function burn_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * burn_arguments token_amount.
                     * @member {number|Long} token_amount
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @instance
                     */
                    burn_arguments.prototype.token_amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * burn_arguments burn_address.
                     * @member {Uint8Array} burn_address
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @instance
                     */
                    burn_arguments.prototype.burn_address = $util.newBuffer([]);
    
                    /**
                     * burn_arguments vhp_address.
                     * @member {Uint8Array} vhp_address
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @instance
                     */
                    burn_arguments.prototype.vhp_address = $util.newBuffer([]);
    
                    /**
                     * Creates a new burn_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iburn_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.burn_arguments} burn_arguments instance
                     */
                    burn_arguments.create = function create(properties) {
                        return new burn_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified burn_arguments message. Does not implicitly {@link koinos.contracts.pob.burn_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iburn_arguments} message burn_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.token_amount != null && Object.hasOwnProperty.call(message, "token_amount"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.token_amount);
                        if (message.burn_address != null && Object.hasOwnProperty.call(message, "burn_address"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.burn_address);
                        if (message.vhp_address != null && Object.hasOwnProperty.call(message, "vhp_address"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.vhp_address);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified burn_arguments message, length delimited. Does not implicitly {@link koinos.contracts.pob.burn_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iburn_arguments} message burn_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a burn_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.burn_arguments} burn_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.burn_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.token_amount = reader.uint64();
                                break;
                            case 2:
                                message.burn_address = reader.bytes();
                                break;
                            case 3:
                                message.vhp_address = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a burn_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.burn_arguments} burn_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a burn_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    burn_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.token_amount != null && message.hasOwnProperty("token_amount"))
                            if (!$util.isInteger(message.token_amount) && !(message.token_amount && $util.isInteger(message.token_amount.low) && $util.isInteger(message.token_amount.high)))
                                return "token_amount: integer|Long expected";
                        if (message.burn_address != null && message.hasOwnProperty("burn_address"))
                            if (!(message.burn_address && typeof message.burn_address.length === "number" || $util.isString(message.burn_address)))
                                return "burn_address: buffer expected";
                        if (message.vhp_address != null && message.hasOwnProperty("vhp_address"))
                            if (!(message.vhp_address && typeof message.vhp_address.length === "number" || $util.isString(message.vhp_address)))
                                return "vhp_address: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a burn_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.burn_arguments} burn_arguments
                     */
                    burn_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.burn_arguments)
                            return object;
                        var message = new $root.koinos.contracts.pob.burn_arguments();
                        if (object.token_amount != null)
                            if ($util.Long)
                                (message.token_amount = $util.Long.fromValue(object.token_amount)).unsigned = true;
                            else if (typeof object.token_amount === "string")
                                message.token_amount = parseInt(object.token_amount, 10);
                            else if (typeof object.token_amount === "number")
                                message.token_amount = object.token_amount;
                            else if (typeof object.token_amount === "object")
                                message.token_amount = new $util.LongBits(object.token_amount.low >>> 0, object.token_amount.high >>> 0).toNumber(true);
                        if (object.burn_address != null)
                            if (typeof object.burn_address === "string")
                                $util.base64.decode(object.burn_address, message.burn_address = $util.newBuffer($util.base64.length(object.burn_address)), 0);
                            else if (object.burn_address.length)
                                message.burn_address = object.burn_address;
                        if (object.vhp_address != null)
                            if (typeof object.vhp_address === "string")
                                $util.base64.decode(object.vhp_address, message.vhp_address = $util.newBuffer($util.base64.length(object.vhp_address)), 0);
                            else if (object.vhp_address.length)
                                message.vhp_address = object.vhp_address;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a burn_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @static
                     * @param {koinos.contracts.pob.burn_arguments} message burn_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    burn_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.token_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.token_amount = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.burn_address = "";
                            else {
                                object.burn_address = [];
                                if (options.bytes !== Array)
                                    object.burn_address = $util.newBuffer(object.burn_address);
                            }
                            if (options.bytes === String)
                                object.vhp_address = "";
                            else {
                                object.vhp_address = [];
                                if (options.bytes !== Array)
                                    object.vhp_address = $util.newBuffer(object.vhp_address);
                            }
                        }
                        if (message.token_amount != null && message.hasOwnProperty("token_amount"))
                            if (typeof message.token_amount === "number")
                                object.token_amount = options.longs === String ? String(message.token_amount) : message.token_amount;
                            else
                                object.token_amount = options.longs === String ? $util.Long.prototype.toString.call(message.token_amount) : options.longs === Number ? new $util.LongBits(message.token_amount.low >>> 0, message.token_amount.high >>> 0).toNumber(true) : message.token_amount;
                        if (message.burn_address != null && message.hasOwnProperty("burn_address"))
                            object.burn_address = options.bytes === String ? $util.base64.encode(message.burn_address, 0, message.burn_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.burn_address) : message.burn_address;
                        if (message.vhp_address != null && message.hasOwnProperty("vhp_address"))
                            object.vhp_address = options.bytes === String ? $util.base64.encode(message.vhp_address, 0, message.vhp_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.vhp_address) : message.vhp_address;
                        return object;
                    };
    
                    /**
                     * Converts this burn_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.burn_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    burn_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return burn_arguments;
                })();
    
                pob.burn_result = (function() {
    
                    /**
                     * Properties of a burn_result.
                     * @memberof koinos.contracts.pob
                     * @interface Iburn_result
                     */
    
                    /**
                     * Constructs a new burn_result.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a burn_result.
                     * @implements Iburn_result
                     * @constructor
                     * @param {koinos.contracts.pob.Iburn_result=} [properties] Properties to set
                     */
                    function burn_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new burn_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {koinos.contracts.pob.Iburn_result=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.burn_result} burn_result instance
                     */
                    burn_result.create = function create(properties) {
                        return new burn_result(properties);
                    };
    
                    /**
                     * Encodes the specified burn_result message. Does not implicitly {@link koinos.contracts.pob.burn_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {koinos.contracts.pob.Iburn_result} message burn_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified burn_result message, length delimited. Does not implicitly {@link koinos.contracts.pob.burn_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {koinos.contracts.pob.Iburn_result} message burn_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a burn_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.burn_result} burn_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.burn_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a burn_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.burn_result} burn_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a burn_result message.
                     * @function verify
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    burn_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a burn_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.burn_result} burn_result
                     */
                    burn_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.burn_result)
                            return object;
                        return new $root.koinos.contracts.pob.burn_result();
                    };
    
                    /**
                     * Creates a plain object from a burn_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.burn_result
                     * @static
                     * @param {koinos.contracts.pob.burn_result} message burn_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    burn_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this burn_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.burn_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    burn_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return burn_result;
                })();
    
                pob.get_consensus_parameters_arguments = (function() {
    
                    /**
                     * Properties of a get_consensus_parameters_arguments.
                     * @memberof koinos.contracts.pob
                     * @interface Iget_consensus_parameters_arguments
                     */
    
                    /**
                     * Constructs a new get_consensus_parameters_arguments.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a get_consensus_parameters_arguments.
                     * @implements Iget_consensus_parameters_arguments
                     * @constructor
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_arguments=} [properties] Properties to set
                     */
                    function get_consensus_parameters_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_consensus_parameters_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.get_consensus_parameters_arguments} get_consensus_parameters_arguments instance
                     */
                    get_consensus_parameters_arguments.create = function create(properties) {
                        return new get_consensus_parameters_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_consensus_parameters_arguments message. Does not implicitly {@link koinos.contracts.pob.get_consensus_parameters_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_arguments} message get_consensus_parameters_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_consensus_parameters_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_consensus_parameters_arguments message, length delimited. Does not implicitly {@link koinos.contracts.pob.get_consensus_parameters_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_arguments} message get_consensus_parameters_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_consensus_parameters_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_consensus_parameters_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.get_consensus_parameters_arguments} get_consensus_parameters_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_consensus_parameters_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.get_consensus_parameters_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_consensus_parameters_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.get_consensus_parameters_arguments} get_consensus_parameters_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_consensus_parameters_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_consensus_parameters_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_consensus_parameters_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_consensus_parameters_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.get_consensus_parameters_arguments} get_consensus_parameters_arguments
                     */
                    get_consensus_parameters_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.get_consensus_parameters_arguments)
                            return object;
                        return new $root.koinos.contracts.pob.get_consensus_parameters_arguments();
                    };
    
                    /**
                     * Creates a plain object from a get_consensus_parameters_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @static
                     * @param {koinos.contracts.pob.get_consensus_parameters_arguments} message get_consensus_parameters_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_consensus_parameters_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_consensus_parameters_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.get_consensus_parameters_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_consensus_parameters_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_consensus_parameters_arguments;
                })();
    
                pob.get_consensus_parameters_result = (function() {
    
                    /**
                     * Properties of a get_consensus_parameters_result.
                     * @memberof koinos.contracts.pob
                     * @interface Iget_consensus_parameters_result
                     * @property {koinos.contracts.pob.Iconsensus_parameters|null} [value] get_consensus_parameters_result value
                     */
    
                    /**
                     * Constructs a new get_consensus_parameters_result.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a get_consensus_parameters_result.
                     * @implements Iget_consensus_parameters_result
                     * @constructor
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_result=} [properties] Properties to set
                     */
                    function get_consensus_parameters_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_consensus_parameters_result value.
                     * @member {koinos.contracts.pob.Iconsensus_parameters|null|undefined} value
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @instance
                     */
                    get_consensus_parameters_result.prototype.value = null;
    
                    /**
                     * Creates a new get_consensus_parameters_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_result=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.get_consensus_parameters_result} get_consensus_parameters_result instance
                     */
                    get_consensus_parameters_result.create = function create(properties) {
                        return new get_consensus_parameters_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_consensus_parameters_result message. Does not implicitly {@link koinos.contracts.pob.get_consensus_parameters_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_result} message get_consensus_parameters_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_consensus_parameters_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            $root.koinos.contracts.pob.consensus_parameters.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_consensus_parameters_result message, length delimited. Does not implicitly {@link koinos.contracts.pob.get_consensus_parameters_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {koinos.contracts.pob.Iget_consensus_parameters_result} message get_consensus_parameters_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_consensus_parameters_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_consensus_parameters_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.get_consensus_parameters_result} get_consensus_parameters_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_consensus_parameters_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.get_consensus_parameters_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = $root.koinos.contracts.pob.consensus_parameters.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_consensus_parameters_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.get_consensus_parameters_result} get_consensus_parameters_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_consensus_parameters_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_consensus_parameters_result message.
                     * @function verify
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_consensus_parameters_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            var error = $root.koinos.contracts.pob.consensus_parameters.verify(message.value);
                            if (error)
                                return "value." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_consensus_parameters_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.get_consensus_parameters_result} get_consensus_parameters_result
                     */
                    get_consensus_parameters_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.get_consensus_parameters_result)
                            return object;
                        var message = new $root.koinos.contracts.pob.get_consensus_parameters_result();
                        if (object.value != null) {
                            if (typeof object.value !== "object")
                                throw TypeError(".koinos.contracts.pob.get_consensus_parameters_result.value: object expected");
                            message.value = $root.koinos.contracts.pob.consensus_parameters.fromObject(object.value);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_consensus_parameters_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @static
                     * @param {koinos.contracts.pob.get_consensus_parameters_result} message get_consensus_parameters_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_consensus_parameters_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = null;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = $root.koinos.contracts.pob.consensus_parameters.toObject(message.value, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_consensus_parameters_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.get_consensus_parameters_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_consensus_parameters_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_consensus_parameters_result;
                })();
    
                pob.get_metadata_arguments = (function() {
    
                    /**
                     * Properties of a get_metadata_arguments.
                     * @memberof koinos.contracts.pob
                     * @interface Iget_metadata_arguments
                     */
    
                    /**
                     * Constructs a new get_metadata_arguments.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a get_metadata_arguments.
                     * @implements Iget_metadata_arguments
                     * @constructor
                     * @param {koinos.contracts.pob.Iget_metadata_arguments=} [properties] Properties to set
                     */
                    function get_metadata_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_metadata_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iget_metadata_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.get_metadata_arguments} get_metadata_arguments instance
                     */
                    get_metadata_arguments.create = function create(properties) {
                        return new get_metadata_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_metadata_arguments message. Does not implicitly {@link koinos.contracts.pob.get_metadata_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iget_metadata_arguments} message get_metadata_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_metadata_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_metadata_arguments message, length delimited. Does not implicitly {@link koinos.contracts.pob.get_metadata_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pob.Iget_metadata_arguments} message get_metadata_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_metadata_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_metadata_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.get_metadata_arguments} get_metadata_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_metadata_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.get_metadata_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_metadata_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.get_metadata_arguments} get_metadata_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_metadata_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_metadata_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_metadata_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_metadata_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.get_metadata_arguments} get_metadata_arguments
                     */
                    get_metadata_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.get_metadata_arguments)
                            return object;
                        return new $root.koinos.contracts.pob.get_metadata_arguments();
                    };
    
                    /**
                     * Creates a plain object from a get_metadata_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pob.get_metadata_arguments} message get_metadata_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_metadata_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_metadata_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.get_metadata_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_metadata_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_metadata_arguments;
                })();
    
                pob.get_metadata_result = (function() {
    
                    /**
                     * Properties of a get_metadata_result.
                     * @memberof koinos.contracts.pob
                     * @interface Iget_metadata_result
                     * @property {koinos.contracts.pob.Imetadata|null} [value] get_metadata_result value
                     */
    
                    /**
                     * Constructs a new get_metadata_result.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a get_metadata_result.
                     * @implements Iget_metadata_result
                     * @constructor
                     * @param {koinos.contracts.pob.Iget_metadata_result=} [properties] Properties to set
                     */
                    function get_metadata_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_metadata_result value.
                     * @member {koinos.contracts.pob.Imetadata|null|undefined} value
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @instance
                     */
                    get_metadata_result.prototype.value = null;
    
                    /**
                     * Creates a new get_metadata_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {koinos.contracts.pob.Iget_metadata_result=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.get_metadata_result} get_metadata_result instance
                     */
                    get_metadata_result.create = function create(properties) {
                        return new get_metadata_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_metadata_result message. Does not implicitly {@link koinos.contracts.pob.get_metadata_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {koinos.contracts.pob.Iget_metadata_result} message get_metadata_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_metadata_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            $root.koinos.contracts.pob.metadata.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_metadata_result message, length delimited. Does not implicitly {@link koinos.contracts.pob.get_metadata_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {koinos.contracts.pob.Iget_metadata_result} message get_metadata_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_metadata_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_metadata_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.get_metadata_result} get_metadata_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_metadata_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.get_metadata_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = $root.koinos.contracts.pob.metadata.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_metadata_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.get_metadata_result} get_metadata_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_metadata_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_metadata_result message.
                     * @function verify
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_metadata_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            var error = $root.koinos.contracts.pob.metadata.verify(message.value);
                            if (error)
                                return "value." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_metadata_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.get_metadata_result} get_metadata_result
                     */
                    get_metadata_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.get_metadata_result)
                            return object;
                        var message = new $root.koinos.contracts.pob.get_metadata_result();
                        if (object.value != null) {
                            if (typeof object.value !== "object")
                                throw TypeError(".koinos.contracts.pob.get_metadata_result.value: object expected");
                            message.value = $root.koinos.contracts.pob.metadata.fromObject(object.value);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_metadata_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @static
                     * @param {koinos.contracts.pob.get_metadata_result} message get_metadata_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_metadata_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = null;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = $root.koinos.contracts.pob.metadata.toObject(message.value, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_metadata_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.get_metadata_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_metadata_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_metadata_result;
                })();
    
                pob.register_public_key_event = (function() {
    
                    /**
                     * Properties of a register_public_key_event.
                     * @memberof koinos.contracts.pob
                     * @interface Iregister_public_key_event
                     * @property {Uint8Array|null} [public_key] register_public_key_event public_key
                     * @property {Uint8Array|null} [address] register_public_key_event address
                     */
    
                    /**
                     * Constructs a new register_public_key_event.
                     * @memberof koinos.contracts.pob
                     * @classdesc Represents a register_public_key_event.
                     * @implements Iregister_public_key_event
                     * @constructor
                     * @param {koinos.contracts.pob.Iregister_public_key_event=} [properties] Properties to set
                     */
                    function register_public_key_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * register_public_key_event public_key.
                     * @member {Uint8Array} public_key
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @instance
                     */
                    register_public_key_event.prototype.public_key = $util.newBuffer([]);
    
                    /**
                     * register_public_key_event address.
                     * @member {Uint8Array} address
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @instance
                     */
                    register_public_key_event.prototype.address = $util.newBuffer([]);
    
                    /**
                     * Creates a new register_public_key_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_event=} [properties] Properties to set
                     * @returns {koinos.contracts.pob.register_public_key_event} register_public_key_event instance
                     */
                    register_public_key_event.create = function create(properties) {
                        return new register_public_key_event(properties);
                    };
    
                    /**
                     * Encodes the specified register_public_key_event message. Does not implicitly {@link koinos.contracts.pob.register_public_key_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_event} message register_public_key_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    register_public_key_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.public_key != null && Object.hasOwnProperty.call(message, "public_key"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.public_key);
                        if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified register_public_key_event message, length delimited. Does not implicitly {@link koinos.contracts.pob.register_public_key_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {koinos.contracts.pob.Iregister_public_key_event} message register_public_key_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    register_public_key_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a register_public_key_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pob.register_public_key_event} register_public_key_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    register_public_key_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pob.register_public_key_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.public_key = reader.bytes();
                                break;
                            case 2:
                                message.address = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a register_public_key_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pob.register_public_key_event} register_public_key_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    register_public_key_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a register_public_key_event message.
                     * @function verify
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    register_public_key_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.public_key != null && message.hasOwnProperty("public_key"))
                            if (!(message.public_key && typeof message.public_key.length === "number" || $util.isString(message.public_key)))
                                return "public_key: buffer expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                                return "address: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a register_public_key_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pob.register_public_key_event} register_public_key_event
                     */
                    register_public_key_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pob.register_public_key_event)
                            return object;
                        var message = new $root.koinos.contracts.pob.register_public_key_event();
                        if (object.public_key != null)
                            if (typeof object.public_key === "string")
                                $util.base64.decode(object.public_key, message.public_key = $util.newBuffer($util.base64.length(object.public_key)), 0);
                            else if (object.public_key.length)
                                message.public_key = object.public_key;
                        if (object.address != null)
                            if (typeof object.address === "string")
                                $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                            else if (object.address.length)
                                message.address = object.address;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a register_public_key_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @static
                     * @param {koinos.contracts.pob.register_public_key_event} message register_public_key_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    register_public_key_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.public_key = "";
                            else {
                                object.public_key = [];
                                if (options.bytes !== Array)
                                    object.public_key = $util.newBuffer(object.public_key);
                            }
                            if (options.bytes === String)
                                object.address = "";
                            else {
                                object.address = [];
                                if (options.bytes !== Array)
                                    object.address = $util.newBuffer(object.address);
                            }
                        }
                        if (message.public_key != null && message.hasOwnProperty("public_key"))
                            object.public_key = options.bytes === String ? $util.base64.encode(message.public_key, 0, message.public_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_key) : message.public_key;
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                        return object;
                    };
    
                    /**
                     * Converts this register_public_key_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pob.register_public_key_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    register_public_key_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return register_public_key_event;
                })();
    
                return pob;
            })();
    
            contracts.resources = (function() {
    
                /**
                 * Namespace resources.
                 * @memberof koinos.contracts
                 * @namespace
                 */
                var resources = {};
    
                resources.market = (function() {
    
                    /**
                     * Properties of a market.
                     * @memberof koinos.contracts.resources
                     * @interface Imarket
                     * @property {number|Long|null} [resource_supply] market resource_supply
                     * @property {number|Long|null} [rc_reserve] market rc_reserve
                     * @property {number|Long|null} [block_budget] market block_budget
                     * @property {number|Long|null} [block_limit] market block_limit
                     */
    
                    /**
                     * Constructs a new market.
                     * @memberof koinos.contracts.resources
                     * @classdesc Represents a market.
                     * @implements Imarket
                     * @constructor
                     * @param {koinos.contracts.resources.Imarket=} [properties] Properties to set
                     */
                    function market(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * market resource_supply.
                     * @member {number|Long} resource_supply
                     * @memberof koinos.contracts.resources.market
                     * @instance
                     */
                    market.prototype.resource_supply = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * market rc_reserve.
                     * @member {number|Long} rc_reserve
                     * @memberof koinos.contracts.resources.market
                     * @instance
                     */
                    market.prototype.rc_reserve = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * market block_budget.
                     * @member {number|Long} block_budget
                     * @memberof koinos.contracts.resources.market
                     * @instance
                     */
                    market.prototype.block_budget = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * market block_limit.
                     * @member {number|Long} block_limit
                     * @memberof koinos.contracts.resources.market
                     * @instance
                     */
                    market.prototype.block_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new market instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {koinos.contracts.resources.Imarket=} [properties] Properties to set
                     * @returns {koinos.contracts.resources.market} market instance
                     */
                    market.create = function create(properties) {
                        return new market(properties);
                    };
    
                    /**
                     * Encodes the specified market message. Does not implicitly {@link koinos.contracts.resources.market.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {koinos.contracts.resources.Imarket} message market message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    market.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.resource_supply != null && Object.hasOwnProperty.call(message, "resource_supply"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.resource_supply);
                        if (message.rc_reserve != null && Object.hasOwnProperty.call(message, "rc_reserve"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rc_reserve);
                        if (message.block_budget != null && Object.hasOwnProperty.call(message, "block_budget"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.block_budget);
                        if (message.block_limit != null && Object.hasOwnProperty.call(message, "block_limit"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.block_limit);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified market message, length delimited. Does not implicitly {@link koinos.contracts.resources.market.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {koinos.contracts.resources.Imarket} message market message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    market.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a market message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.resources.market} market
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    market.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.resources.market();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.resource_supply = reader.uint64();
                                break;
                            case 2:
                                message.rc_reserve = reader.uint64();
                                break;
                            case 3:
                                message.block_budget = reader.uint64();
                                break;
                            case 4:
                                message.block_limit = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a market message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.resources.market} market
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    market.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a market message.
                     * @function verify
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    market.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.resource_supply != null && message.hasOwnProperty("resource_supply"))
                            if (!$util.isInteger(message.resource_supply) && !(message.resource_supply && $util.isInteger(message.resource_supply.low) && $util.isInteger(message.resource_supply.high)))
                                return "resource_supply: integer|Long expected";
                        if (message.rc_reserve != null && message.hasOwnProperty("rc_reserve"))
                            if (!$util.isInteger(message.rc_reserve) && !(message.rc_reserve && $util.isInteger(message.rc_reserve.low) && $util.isInteger(message.rc_reserve.high)))
                                return "rc_reserve: integer|Long expected";
                        if (message.block_budget != null && message.hasOwnProperty("block_budget"))
                            if (!$util.isInteger(message.block_budget) && !(message.block_budget && $util.isInteger(message.block_budget.low) && $util.isInteger(message.block_budget.high)))
                                return "block_budget: integer|Long expected";
                        if (message.block_limit != null && message.hasOwnProperty("block_limit"))
                            if (!$util.isInteger(message.block_limit) && !(message.block_limit && $util.isInteger(message.block_limit.low) && $util.isInteger(message.block_limit.high)))
                                return "block_limit: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a market message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.resources.market} market
                     */
                    market.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.resources.market)
                            return object;
                        var message = new $root.koinos.contracts.resources.market();
                        if (object.resource_supply != null)
                            if ($util.Long)
                                (message.resource_supply = $util.Long.fromValue(object.resource_supply)).unsigned = true;
                            else if (typeof object.resource_supply === "string")
                                message.resource_supply = parseInt(object.resource_supply, 10);
                            else if (typeof object.resource_supply === "number")
                                message.resource_supply = object.resource_supply;
                            else if (typeof object.resource_supply === "object")
                                message.resource_supply = new $util.LongBits(object.resource_supply.low >>> 0, object.resource_supply.high >>> 0).toNumber(true);
                        if (object.rc_reserve != null)
                            if ($util.Long)
                                (message.rc_reserve = $util.Long.fromValue(object.rc_reserve)).unsigned = true;
                            else if (typeof object.rc_reserve === "string")
                                message.rc_reserve = parseInt(object.rc_reserve, 10);
                            else if (typeof object.rc_reserve === "number")
                                message.rc_reserve = object.rc_reserve;
                            else if (typeof object.rc_reserve === "object")
                                message.rc_reserve = new $util.LongBits(object.rc_reserve.low >>> 0, object.rc_reserve.high >>> 0).toNumber(true);
                        if (object.block_budget != null)
                            if ($util.Long)
                                (message.block_budget = $util.Long.fromValue(object.block_budget)).unsigned = true;
                            else if (typeof object.block_budget === "string")
                                message.block_budget = parseInt(object.block_budget, 10);
                            else if (typeof object.block_budget === "number")
                                message.block_budget = object.block_budget;
                            else if (typeof object.block_budget === "object")
                                message.block_budget = new $util.LongBits(object.block_budget.low >>> 0, object.block_budget.high >>> 0).toNumber(true);
                        if (object.block_limit != null)
                            if ($util.Long)
                                (message.block_limit = $util.Long.fromValue(object.block_limit)).unsigned = true;
                            else if (typeof object.block_limit === "string")
                                message.block_limit = parseInt(object.block_limit, 10);
                            else if (typeof object.block_limit === "number")
                                message.block_limit = object.block_limit;
                            else if (typeof object.block_limit === "object")
                                message.block_limit = new $util.LongBits(object.block_limit.low >>> 0, object.block_limit.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a market message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.resources.market
                     * @static
                     * @param {koinos.contracts.resources.market} message market
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    market.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.resource_supply = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.resource_supply = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.rc_reserve = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.rc_reserve = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.block_budget = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.block_budget = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.block_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.block_limit = options.longs === String ? "0" : 0;
                        }
                        if (message.resource_supply != null && message.hasOwnProperty("resource_supply"))
                            if (typeof message.resource_supply === "number")
                                object.resource_supply = options.longs === String ? String(message.resource_supply) : message.resource_supply;
                            else
                                object.resource_supply = options.longs === String ? $util.Long.prototype.toString.call(message.resource_supply) : options.longs === Number ? new $util.LongBits(message.resource_supply.low >>> 0, message.resource_supply.high >>> 0).toNumber(true) : message.resource_supply;
                        if (message.rc_reserve != null && message.hasOwnProperty("rc_reserve"))
                            if (typeof message.rc_reserve === "number")
                                object.rc_reserve = options.longs === String ? String(message.rc_reserve) : message.rc_reserve;
                            else
                                object.rc_reserve = options.longs === String ? $util.Long.prototype.toString.call(message.rc_reserve) : options.longs === Number ? new $util.LongBits(message.rc_reserve.low >>> 0, message.rc_reserve.high >>> 0).toNumber(true) : message.rc_reserve;
                        if (message.block_budget != null && message.hasOwnProperty("block_budget"))
                            if (typeof message.block_budget === "number")
                                object.block_budget = options.longs === String ? String(message.block_budget) : message.block_budget;
                            else
                                object.block_budget = options.longs === String ? $util.Long.prototype.toString.call(message.block_budget) : options.longs === Number ? new $util.LongBits(message.block_budget.low >>> 0, message.block_budget.high >>> 0).toNumber(true) : message.block_budget;
                        if (message.block_limit != null && message.hasOwnProperty("block_limit"))
                            if (typeof message.block_limit === "number")
                                object.block_limit = options.longs === String ? String(message.block_limit) : message.block_limit;
                            else
                                object.block_limit = options.longs === String ? $util.Long.prototype.toString.call(message.block_limit) : options.longs === Number ? new $util.LongBits(message.block_limit.low >>> 0, message.block_limit.high >>> 0).toNumber(true) : message.block_limit;
                        return object;
                    };
    
                    /**
                     * Converts this market to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.resources.market
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    market.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return market;
                })();
    
                resources.resource_markets = (function() {
    
                    /**
                     * Properties of a resource_markets.
                     * @memberof koinos.contracts.resources
                     * @interface Iresource_markets
                     * @property {koinos.contracts.resources.Imarket|null} [disk_storage] resource_markets disk_storage
                     * @property {koinos.contracts.resources.Imarket|null} [network_bandwidth] resource_markets network_bandwidth
                     * @property {koinos.contracts.resources.Imarket|null} [compute_bandwidth] resource_markets compute_bandwidth
                     */
    
                    /**
                     * Constructs a new resource_markets.
                     * @memberof koinos.contracts.resources
                     * @classdesc Represents a resource_markets.
                     * @implements Iresource_markets
                     * @constructor
                     * @param {koinos.contracts.resources.Iresource_markets=} [properties] Properties to set
                     */
                    function resource_markets(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * resource_markets disk_storage.
                     * @member {koinos.contracts.resources.Imarket|null|undefined} disk_storage
                     * @memberof koinos.contracts.resources.resource_markets
                     * @instance
                     */
                    resource_markets.prototype.disk_storage = null;
    
                    /**
                     * resource_markets network_bandwidth.
                     * @member {koinos.contracts.resources.Imarket|null|undefined} network_bandwidth
                     * @memberof koinos.contracts.resources.resource_markets
                     * @instance
                     */
                    resource_markets.prototype.network_bandwidth = null;
    
                    /**
                     * resource_markets compute_bandwidth.
                     * @member {koinos.contracts.resources.Imarket|null|undefined} compute_bandwidth
                     * @memberof koinos.contracts.resources.resource_markets
                     * @instance
                     */
                    resource_markets.prototype.compute_bandwidth = null;
    
                    /**
                     * Creates a new resource_markets instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {koinos.contracts.resources.Iresource_markets=} [properties] Properties to set
                     * @returns {koinos.contracts.resources.resource_markets} resource_markets instance
                     */
                    resource_markets.create = function create(properties) {
                        return new resource_markets(properties);
                    };
    
                    /**
                     * Encodes the specified resource_markets message. Does not implicitly {@link koinos.contracts.resources.resource_markets.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {koinos.contracts.resources.Iresource_markets} message resource_markets message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    resource_markets.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.disk_storage != null && Object.hasOwnProperty.call(message, "disk_storage"))
                            $root.koinos.contracts.resources.market.encode(message.disk_storage, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.network_bandwidth != null && Object.hasOwnProperty.call(message, "network_bandwidth"))
                            $root.koinos.contracts.resources.market.encode(message.network_bandwidth, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.compute_bandwidth != null && Object.hasOwnProperty.call(message, "compute_bandwidth"))
                            $root.koinos.contracts.resources.market.encode(message.compute_bandwidth, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified resource_markets message, length delimited. Does not implicitly {@link koinos.contracts.resources.resource_markets.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {koinos.contracts.resources.Iresource_markets} message resource_markets message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    resource_markets.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a resource_markets message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.resources.resource_markets} resource_markets
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    resource_markets.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.resources.resource_markets();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.disk_storage = $root.koinos.contracts.resources.market.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.network_bandwidth = $root.koinos.contracts.resources.market.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.compute_bandwidth = $root.koinos.contracts.resources.market.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a resource_markets message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.resources.resource_markets} resource_markets
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    resource_markets.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a resource_markets message.
                     * @function verify
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    resource_markets.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.disk_storage != null && message.hasOwnProperty("disk_storage")) {
                            var error = $root.koinos.contracts.resources.market.verify(message.disk_storage);
                            if (error)
                                return "disk_storage." + error;
                        }
                        if (message.network_bandwidth != null && message.hasOwnProperty("network_bandwidth")) {
                            var error = $root.koinos.contracts.resources.market.verify(message.network_bandwidth);
                            if (error)
                                return "network_bandwidth." + error;
                        }
                        if (message.compute_bandwidth != null && message.hasOwnProperty("compute_bandwidth")) {
                            var error = $root.koinos.contracts.resources.market.verify(message.compute_bandwidth);
                            if (error)
                                return "compute_bandwidth." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a resource_markets message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.resources.resource_markets} resource_markets
                     */
                    resource_markets.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.resources.resource_markets)
                            return object;
                        var message = new $root.koinos.contracts.resources.resource_markets();
                        if (object.disk_storage != null) {
                            if (typeof object.disk_storage !== "object")
                                throw TypeError(".koinos.contracts.resources.resource_markets.disk_storage: object expected");
                            message.disk_storage = $root.koinos.contracts.resources.market.fromObject(object.disk_storage);
                        }
                        if (object.network_bandwidth != null) {
                            if (typeof object.network_bandwidth !== "object")
                                throw TypeError(".koinos.contracts.resources.resource_markets.network_bandwidth: object expected");
                            message.network_bandwidth = $root.koinos.contracts.resources.market.fromObject(object.network_bandwidth);
                        }
                        if (object.compute_bandwidth != null) {
                            if (typeof object.compute_bandwidth !== "object")
                                throw TypeError(".koinos.contracts.resources.resource_markets.compute_bandwidth: object expected");
                            message.compute_bandwidth = $root.koinos.contracts.resources.market.fromObject(object.compute_bandwidth);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a resource_markets message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.resources.resource_markets
                     * @static
                     * @param {koinos.contracts.resources.resource_markets} message resource_markets
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    resource_markets.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.disk_storage = null;
                            object.network_bandwidth = null;
                            object.compute_bandwidth = null;
                        }
                        if (message.disk_storage != null && message.hasOwnProperty("disk_storage"))
                            object.disk_storage = $root.koinos.contracts.resources.market.toObject(message.disk_storage, options);
                        if (message.network_bandwidth != null && message.hasOwnProperty("network_bandwidth"))
                            object.network_bandwidth = $root.koinos.contracts.resources.market.toObject(message.network_bandwidth, options);
                        if (message.compute_bandwidth != null && message.hasOwnProperty("compute_bandwidth"))
                            object.compute_bandwidth = $root.koinos.contracts.resources.market.toObject(message.compute_bandwidth, options);
                        return object;
                    };
    
                    /**
                     * Converts this resource_markets to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.resources.resource_markets
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    resource_markets.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return resource_markets;
                })();
    
                resources.get_resource_markets_arguments = (function() {
    
                    /**
                     * Properties of a get_resource_markets_arguments.
                     * @memberof koinos.contracts.resources
                     * @interface Iget_resource_markets_arguments
                     */
    
                    /**
                     * Constructs a new get_resource_markets_arguments.
                     * @memberof koinos.contracts.resources
                     * @classdesc Represents a get_resource_markets_arguments.
                     * @implements Iget_resource_markets_arguments
                     * @constructor
                     * @param {koinos.contracts.resources.Iget_resource_markets_arguments=} [properties] Properties to set
                     */
                    function get_resource_markets_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_resource_markets_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {koinos.contracts.resources.Iget_resource_markets_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.resources.get_resource_markets_arguments} get_resource_markets_arguments instance
                     */
                    get_resource_markets_arguments.create = function create(properties) {
                        return new get_resource_markets_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_resource_markets_arguments message. Does not implicitly {@link koinos.contracts.resources.get_resource_markets_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {koinos.contracts.resources.Iget_resource_markets_arguments} message get_resource_markets_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_markets_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_resource_markets_arguments message, length delimited. Does not implicitly {@link koinos.contracts.resources.get_resource_markets_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {koinos.contracts.resources.Iget_resource_markets_arguments} message get_resource_markets_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_markets_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_resource_markets_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.resources.get_resource_markets_arguments} get_resource_markets_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_markets_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.resources.get_resource_markets_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_resource_markets_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.resources.get_resource_markets_arguments} get_resource_markets_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_markets_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_resource_markets_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_resource_markets_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_resource_markets_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.resources.get_resource_markets_arguments} get_resource_markets_arguments
                     */
                    get_resource_markets_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.resources.get_resource_markets_arguments)
                            return object;
                        return new $root.koinos.contracts.resources.get_resource_markets_arguments();
                    };
    
                    /**
                     * Creates a plain object from a get_resource_markets_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @static
                     * @param {koinos.contracts.resources.get_resource_markets_arguments} message get_resource_markets_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_resource_markets_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_resource_markets_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.resources.get_resource_markets_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_resource_markets_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_resource_markets_arguments;
                })();
    
                resources.get_resource_markets_result = (function() {
    
                    /**
                     * Properties of a get_resource_markets_result.
                     * @memberof koinos.contracts.resources
                     * @interface Iget_resource_markets_result
                     * @property {koinos.contracts.resources.Iresource_markets|null} [value] get_resource_markets_result value
                     */
    
                    /**
                     * Constructs a new get_resource_markets_result.
                     * @memberof koinos.contracts.resources
                     * @classdesc Represents a get_resource_markets_result.
                     * @implements Iget_resource_markets_result
                     * @constructor
                     * @param {koinos.contracts.resources.Iget_resource_markets_result=} [properties] Properties to set
                     */
                    function get_resource_markets_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_resource_markets_result value.
                     * @member {koinos.contracts.resources.Iresource_markets|null|undefined} value
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @instance
                     */
                    get_resource_markets_result.prototype.value = null;
    
                    /**
                     * Creates a new get_resource_markets_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {koinos.contracts.resources.Iget_resource_markets_result=} [properties] Properties to set
                     * @returns {koinos.contracts.resources.get_resource_markets_result} get_resource_markets_result instance
                     */
                    get_resource_markets_result.create = function create(properties) {
                        return new get_resource_markets_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_resource_markets_result message. Does not implicitly {@link koinos.contracts.resources.get_resource_markets_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {koinos.contracts.resources.Iget_resource_markets_result} message get_resource_markets_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_markets_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            $root.koinos.contracts.resources.resource_markets.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_resource_markets_result message, length delimited. Does not implicitly {@link koinos.contracts.resources.get_resource_markets_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {koinos.contracts.resources.Iget_resource_markets_result} message get_resource_markets_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_markets_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_resource_markets_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.resources.get_resource_markets_result} get_resource_markets_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_markets_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.resources.get_resource_markets_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = $root.koinos.contracts.resources.resource_markets.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_resource_markets_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.resources.get_resource_markets_result} get_resource_markets_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_markets_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_resource_markets_result message.
                     * @function verify
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_resource_markets_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            var error = $root.koinos.contracts.resources.resource_markets.verify(message.value);
                            if (error)
                                return "value." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_resource_markets_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.resources.get_resource_markets_result} get_resource_markets_result
                     */
                    get_resource_markets_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.resources.get_resource_markets_result)
                            return object;
                        var message = new $root.koinos.contracts.resources.get_resource_markets_result();
                        if (object.value != null) {
                            if (typeof object.value !== "object")
                                throw TypeError(".koinos.contracts.resources.get_resource_markets_result.value: object expected");
                            message.value = $root.koinos.contracts.resources.resource_markets.fromObject(object.value);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_resource_markets_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @static
                     * @param {koinos.contracts.resources.get_resource_markets_result} message get_resource_markets_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_resource_markets_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = null;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = $root.koinos.contracts.resources.resource_markets.toObject(message.value, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_resource_markets_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.resources.get_resource_markets_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_resource_markets_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_resource_markets_result;
                })();
    
                return resources;
            })();
    
            contracts.governance = (function() {
    
                /**
                 * Namespace governance.
                 * @memberof koinos.contracts
                 * @namespace
                 */
                var governance = {};
    
                /**
                 * proposal_status enum.
                 * @name koinos.contracts.governance.proposal_status
                 * @enum {number}
                 * @property {number} pending=0 pending value
                 * @property {number} active=1 active value
                 * @property {number} approved=2 approved value
                 * @property {number} expired=3 expired value
                 * @property {number} applied=4 applied value
                 * @property {number} failed=5 failed value
                 * @property {number} reverted=6 reverted value
                 */
                governance.proposal_status = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "pending"] = 0;
                    values[valuesById[1] = "active"] = 1;
                    values[valuesById[2] = "approved"] = 2;
                    values[valuesById[3] = "expired"] = 3;
                    values[valuesById[4] = "applied"] = 4;
                    values[valuesById[5] = "failed"] = 5;
                    values[valuesById[6] = "reverted"] = 6;
                    return values;
                })();
    
                governance.proposal_record = (function() {
    
                    /**
                     * Properties of a proposal_record.
                     * @memberof koinos.contracts.governance
                     * @interface Iproposal_record
                     * @property {Array.<koinos.protocol.Ioperation>|null} [operations] proposal_record operations
                     * @property {Uint8Array|null} [operation_merkle_root] proposal_record operation_merkle_root
                     * @property {number|Long|null} [vote_start_height] proposal_record vote_start_height
                     * @property {number|Long|null} [vote_tally] proposal_record vote_tally
                     * @property {number|Long|null} [vote_threshold] proposal_record vote_threshold
                     * @property {boolean|null} [shall_authorize] proposal_record shall_authorize
                     * @property {boolean|null} [updates_governance] proposal_record updates_governance
                     * @property {koinos.contracts.governance.proposal_status|null} [status] proposal_record status
                     * @property {number|Long|null} [fee] proposal_record fee
                     */
    
                    /**
                     * Constructs a new proposal_record.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a proposal_record.
                     * @implements Iproposal_record
                     * @constructor
                     * @param {koinos.contracts.governance.Iproposal_record=} [properties] Properties to set
                     */
                    function proposal_record(properties) {
                        this.operations = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * proposal_record operations.
                     * @member {Array.<koinos.protocol.Ioperation>} operations
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.operations = $util.emptyArray;
    
                    /**
                     * proposal_record operation_merkle_root.
                     * @member {Uint8Array} operation_merkle_root
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.operation_merkle_root = $util.newBuffer([]);
    
                    /**
                     * proposal_record vote_start_height.
                     * @member {number|Long} vote_start_height
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.vote_start_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * proposal_record vote_tally.
                     * @member {number|Long} vote_tally
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.vote_tally = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * proposal_record vote_threshold.
                     * @member {number|Long} vote_threshold
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.vote_threshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * proposal_record shall_authorize.
                     * @member {boolean} shall_authorize
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.shall_authorize = false;
    
                    /**
                     * proposal_record updates_governance.
                     * @member {boolean} updates_governance
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.updates_governance = false;
    
                    /**
                     * proposal_record status.
                     * @member {koinos.contracts.governance.proposal_status} status
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.status = 0;
    
                    /**
                     * proposal_record fee.
                     * @member {number|Long} fee
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     */
                    proposal_record.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new proposal_record instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_record=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.proposal_record} proposal_record instance
                     */
                    proposal_record.create = function create(properties) {
                        return new proposal_record(properties);
                    };
    
                    /**
                     * Encodes the specified proposal_record message. Does not implicitly {@link koinos.contracts.governance.proposal_record.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_record} message proposal_record message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_record.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.operations != null && message.operations.length)
                            for (var i = 0; i < message.operations.length; ++i)
                                $root.koinos.protocol.operation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.operation_merkle_root != null && Object.hasOwnProperty.call(message, "operation_merkle_root"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.operation_merkle_root);
                        if (message.vote_start_height != null && Object.hasOwnProperty.call(message, "vote_start_height"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.vote_start_height);
                        if (message.vote_tally != null && Object.hasOwnProperty.call(message, "vote_tally"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.vote_tally);
                        if (message.vote_threshold != null && Object.hasOwnProperty.call(message, "vote_threshold"))
                            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.vote_threshold);
                        if (message.shall_authorize != null && Object.hasOwnProperty.call(message, "shall_authorize"))
                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.shall_authorize);
                        if (message.updates_governance != null && Object.hasOwnProperty.call(message, "updates_governance"))
                            writer.uint32(/* id 7, wireType 0 =*/56).bool(message.updates_governance);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 8, wireType 0 =*/64).int32(message.status);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.fee);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified proposal_record message, length delimited. Does not implicitly {@link koinos.contracts.governance.proposal_record.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_record} message proposal_record message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_record.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a proposal_record message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.proposal_record} proposal_record
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_record.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.proposal_record();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.operations && message.operations.length))
                                    message.operations = [];
                                message.operations.push($root.koinos.protocol.operation.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.operation_merkle_root = reader.bytes();
                                break;
                            case 3:
                                message.vote_start_height = reader.uint64();
                                break;
                            case 4:
                                message.vote_tally = reader.uint64();
                                break;
                            case 5:
                                message.vote_threshold = reader.uint64();
                                break;
                            case 6:
                                message.shall_authorize = reader.bool();
                                break;
                            case 7:
                                message.updates_governance = reader.bool();
                                break;
                            case 8:
                                message.status = reader.int32();
                                break;
                            case 9:
                                message.fee = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a proposal_record message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.proposal_record} proposal_record
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_record.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a proposal_record message.
                     * @function verify
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    proposal_record.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.operations != null && message.hasOwnProperty("operations")) {
                            if (!Array.isArray(message.operations))
                                return "operations: array expected";
                            for (var i = 0; i < message.operations.length; ++i) {
                                var error = $root.koinos.protocol.operation.verify(message.operations[i]);
                                if (error)
                                    return "operations." + error;
                            }
                        }
                        if (message.operation_merkle_root != null && message.hasOwnProperty("operation_merkle_root"))
                            if (!(message.operation_merkle_root && typeof message.operation_merkle_root.length === "number" || $util.isString(message.operation_merkle_root)))
                                return "operation_merkle_root: buffer expected";
                        if (message.vote_start_height != null && message.hasOwnProperty("vote_start_height"))
                            if (!$util.isInteger(message.vote_start_height) && !(message.vote_start_height && $util.isInteger(message.vote_start_height.low) && $util.isInteger(message.vote_start_height.high)))
                                return "vote_start_height: integer|Long expected";
                        if (message.vote_tally != null && message.hasOwnProperty("vote_tally"))
                            if (!$util.isInteger(message.vote_tally) && !(message.vote_tally && $util.isInteger(message.vote_tally.low) && $util.isInteger(message.vote_tally.high)))
                                return "vote_tally: integer|Long expected";
                        if (message.vote_threshold != null && message.hasOwnProperty("vote_threshold"))
                            if (!$util.isInteger(message.vote_threshold) && !(message.vote_threshold && $util.isInteger(message.vote_threshold.low) && $util.isInteger(message.vote_threshold.high)))
                                return "vote_threshold: integer|Long expected";
                        if (message.shall_authorize != null && message.hasOwnProperty("shall_authorize"))
                            if (typeof message.shall_authorize !== "boolean")
                                return "shall_authorize: boolean expected";
                        if (message.updates_governance != null && message.hasOwnProperty("updates_governance"))
                            if (typeof message.updates_governance !== "boolean")
                                return "updates_governance: boolean expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a proposal_record message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.proposal_record} proposal_record
                     */
                    proposal_record.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.proposal_record)
                            return object;
                        var message = new $root.koinos.contracts.governance.proposal_record();
                        if (object.operations) {
                            if (!Array.isArray(object.operations))
                                throw TypeError(".koinos.contracts.governance.proposal_record.operations: array expected");
                            message.operations = [];
                            for (var i = 0; i < object.operations.length; ++i) {
                                if (typeof object.operations[i] !== "object")
                                    throw TypeError(".koinos.contracts.governance.proposal_record.operations: object expected");
                                message.operations[i] = $root.koinos.protocol.operation.fromObject(object.operations[i]);
                            }
                        }
                        if (object.operation_merkle_root != null)
                            if (typeof object.operation_merkle_root === "string")
                                $util.base64.decode(object.operation_merkle_root, message.operation_merkle_root = $util.newBuffer($util.base64.length(object.operation_merkle_root)), 0);
                            else if (object.operation_merkle_root.length)
                                message.operation_merkle_root = object.operation_merkle_root;
                        if (object.vote_start_height != null)
                            if ($util.Long)
                                (message.vote_start_height = $util.Long.fromValue(object.vote_start_height)).unsigned = true;
                            else if (typeof object.vote_start_height === "string")
                                message.vote_start_height = parseInt(object.vote_start_height, 10);
                            else if (typeof object.vote_start_height === "number")
                                message.vote_start_height = object.vote_start_height;
                            else if (typeof object.vote_start_height === "object")
                                message.vote_start_height = new $util.LongBits(object.vote_start_height.low >>> 0, object.vote_start_height.high >>> 0).toNumber(true);
                        if (object.vote_tally != null)
                            if ($util.Long)
                                (message.vote_tally = $util.Long.fromValue(object.vote_tally)).unsigned = true;
                            else if (typeof object.vote_tally === "string")
                                message.vote_tally = parseInt(object.vote_tally, 10);
                            else if (typeof object.vote_tally === "number")
                                message.vote_tally = object.vote_tally;
                            else if (typeof object.vote_tally === "object")
                                message.vote_tally = new $util.LongBits(object.vote_tally.low >>> 0, object.vote_tally.high >>> 0).toNumber(true);
                        if (object.vote_threshold != null)
                            if ($util.Long)
                                (message.vote_threshold = $util.Long.fromValue(object.vote_threshold)).unsigned = true;
                            else if (typeof object.vote_threshold === "string")
                                message.vote_threshold = parseInt(object.vote_threshold, 10);
                            else if (typeof object.vote_threshold === "number")
                                message.vote_threshold = object.vote_threshold;
                            else if (typeof object.vote_threshold === "object")
                                message.vote_threshold = new $util.LongBits(object.vote_threshold.low >>> 0, object.vote_threshold.high >>> 0).toNumber(true);
                        if (object.shall_authorize != null)
                            message.shall_authorize = Boolean(object.shall_authorize);
                        if (object.updates_governance != null)
                            message.updates_governance = Boolean(object.updates_governance);
                        switch (object.status) {
                        case "pending":
                        case 0:
                            message.status = 0;
                            break;
                        case "active":
                        case 1:
                            message.status = 1;
                            break;
                        case "approved":
                        case 2:
                            message.status = 2;
                            break;
                        case "expired":
                        case 3:
                            message.status = 3;
                            break;
                        case "applied":
                        case 4:
                            message.status = 4;
                            break;
                        case "failed":
                        case 5:
                            message.status = 5;
                            break;
                        case "reverted":
                        case 6:
                            message.status = 6;
                            break;
                        }
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a proposal_record message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.proposal_record
                     * @static
                     * @param {koinos.contracts.governance.proposal_record} message proposal_record
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    proposal_record.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.operations = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.operation_merkle_root = "";
                            else {
                                object.operation_merkle_root = [];
                                if (options.bytes !== Array)
                                    object.operation_merkle_root = $util.newBuffer(object.operation_merkle_root);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.vote_start_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.vote_start_height = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.vote_tally = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.vote_tally = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.vote_threshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.vote_threshold = options.longs === String ? "0" : 0;
                            object.shall_authorize = false;
                            object.updates_governance = false;
                            object.status = options.enums === String ? "pending" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                        }
                        if (message.operations && message.operations.length) {
                            object.operations = [];
                            for (var j = 0; j < message.operations.length; ++j)
                                object.operations[j] = $root.koinos.protocol.operation.toObject(message.operations[j], options);
                        }
                        if (message.operation_merkle_root != null && message.hasOwnProperty("operation_merkle_root"))
                            object.operation_merkle_root = options.bytes === String ? $util.base64.encode(message.operation_merkle_root, 0, message.operation_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.operation_merkle_root) : message.operation_merkle_root;
                        if (message.vote_start_height != null && message.hasOwnProperty("vote_start_height"))
                            if (typeof message.vote_start_height === "number")
                                object.vote_start_height = options.longs === String ? String(message.vote_start_height) : message.vote_start_height;
                            else
                                object.vote_start_height = options.longs === String ? $util.Long.prototype.toString.call(message.vote_start_height) : options.longs === Number ? new $util.LongBits(message.vote_start_height.low >>> 0, message.vote_start_height.high >>> 0).toNumber(true) : message.vote_start_height;
                        if (message.vote_tally != null && message.hasOwnProperty("vote_tally"))
                            if (typeof message.vote_tally === "number")
                                object.vote_tally = options.longs === String ? String(message.vote_tally) : message.vote_tally;
                            else
                                object.vote_tally = options.longs === String ? $util.Long.prototype.toString.call(message.vote_tally) : options.longs === Number ? new $util.LongBits(message.vote_tally.low >>> 0, message.vote_tally.high >>> 0).toNumber(true) : message.vote_tally;
                        if (message.vote_threshold != null && message.hasOwnProperty("vote_threshold"))
                            if (typeof message.vote_threshold === "number")
                                object.vote_threshold = options.longs === String ? String(message.vote_threshold) : message.vote_threshold;
                            else
                                object.vote_threshold = options.longs === String ? $util.Long.prototype.toString.call(message.vote_threshold) : options.longs === Number ? new $util.LongBits(message.vote_threshold.low >>> 0, message.vote_threshold.high >>> 0).toNumber(true) : message.vote_threshold;
                        if (message.shall_authorize != null && message.hasOwnProperty("shall_authorize"))
                            object.shall_authorize = message.shall_authorize;
                        if (message.updates_governance != null && message.hasOwnProperty("updates_governance"))
                            object.updates_governance = message.updates_governance;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.koinos.contracts.governance.proposal_status[message.status] : message.status;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        return object;
                    };
    
                    /**
                     * Converts this proposal_record to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.proposal_record
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    proposal_record.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return proposal_record;
                })();
    
                governance.submit_proposal_arguments = (function() {
    
                    /**
                     * Properties of a submit_proposal_arguments.
                     * @memberof koinos.contracts.governance
                     * @interface Isubmit_proposal_arguments
                     * @property {Array.<koinos.protocol.Ioperation>|null} [operations] submit_proposal_arguments operations
                     * @property {Uint8Array|null} [operation_merkle_root] submit_proposal_arguments operation_merkle_root
                     * @property {number|Long|null} [fee] submit_proposal_arguments fee
                     */
    
                    /**
                     * Constructs a new submit_proposal_arguments.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a submit_proposal_arguments.
                     * @implements Isubmit_proposal_arguments
                     * @constructor
                     * @param {koinos.contracts.governance.Isubmit_proposal_arguments=} [properties] Properties to set
                     */
                    function submit_proposal_arguments(properties) {
                        this.operations = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * submit_proposal_arguments operations.
                     * @member {Array.<koinos.protocol.Ioperation>} operations
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @instance
                     */
                    submit_proposal_arguments.prototype.operations = $util.emptyArray;
    
                    /**
                     * submit_proposal_arguments operation_merkle_root.
                     * @member {Uint8Array} operation_merkle_root
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @instance
                     */
                    submit_proposal_arguments.prototype.operation_merkle_root = $util.newBuffer([]);
    
                    /**
                     * submit_proposal_arguments fee.
                     * @member {number|Long} fee
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @instance
                     */
                    submit_proposal_arguments.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new submit_proposal_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {koinos.contracts.governance.Isubmit_proposal_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.submit_proposal_arguments} submit_proposal_arguments instance
                     */
                    submit_proposal_arguments.create = function create(properties) {
                        return new submit_proposal_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified submit_proposal_arguments message. Does not implicitly {@link koinos.contracts.governance.submit_proposal_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {koinos.contracts.governance.Isubmit_proposal_arguments} message submit_proposal_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_proposal_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.operations != null && message.operations.length)
                            for (var i = 0; i < message.operations.length; ++i)
                                $root.koinos.protocol.operation.encode(message.operations[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.operation_merkle_root != null && Object.hasOwnProperty.call(message, "operation_merkle_root"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.operation_merkle_root);
                        if (message.fee != null && Object.hasOwnProperty.call(message, "fee"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fee);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified submit_proposal_arguments message, length delimited. Does not implicitly {@link koinos.contracts.governance.submit_proposal_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {koinos.contracts.governance.Isubmit_proposal_arguments} message submit_proposal_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_proposal_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a submit_proposal_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.submit_proposal_arguments} submit_proposal_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_proposal_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.submit_proposal_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.operations && message.operations.length))
                                    message.operations = [];
                                message.operations.push($root.koinos.protocol.operation.decode(reader, reader.uint32()));
                                break;
                            case 2:
                                message.operation_merkle_root = reader.bytes();
                                break;
                            case 3:
                                message.fee = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a submit_proposal_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.submit_proposal_arguments} submit_proposal_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_proposal_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a submit_proposal_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    submit_proposal_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.operations != null && message.hasOwnProperty("operations")) {
                            if (!Array.isArray(message.operations))
                                return "operations: array expected";
                            for (var i = 0; i < message.operations.length; ++i) {
                                var error = $root.koinos.protocol.operation.verify(message.operations[i]);
                                if (error)
                                    return "operations." + error;
                            }
                        }
                        if (message.operation_merkle_root != null && message.hasOwnProperty("operation_merkle_root"))
                            if (!(message.operation_merkle_root && typeof message.operation_merkle_root.length === "number" || $util.isString(message.operation_merkle_root)))
                                return "operation_merkle_root: buffer expected";
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                                return "fee: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a submit_proposal_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.submit_proposal_arguments} submit_proposal_arguments
                     */
                    submit_proposal_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.submit_proposal_arguments)
                            return object;
                        var message = new $root.koinos.contracts.governance.submit_proposal_arguments();
                        if (object.operations) {
                            if (!Array.isArray(object.operations))
                                throw TypeError(".koinos.contracts.governance.submit_proposal_arguments.operations: array expected");
                            message.operations = [];
                            for (var i = 0; i < object.operations.length; ++i) {
                                if (typeof object.operations[i] !== "object")
                                    throw TypeError(".koinos.contracts.governance.submit_proposal_arguments.operations: object expected");
                                message.operations[i] = $root.koinos.protocol.operation.fromObject(object.operations[i]);
                            }
                        }
                        if (object.operation_merkle_root != null)
                            if (typeof object.operation_merkle_root === "string")
                                $util.base64.decode(object.operation_merkle_root, message.operation_merkle_root = $util.newBuffer($util.base64.length(object.operation_merkle_root)), 0);
                            else if (object.operation_merkle_root.length)
                                message.operation_merkle_root = object.operation_merkle_root;
                        if (object.fee != null)
                            if ($util.Long)
                                (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                            else if (typeof object.fee === "string")
                                message.fee = parseInt(object.fee, 10);
                            else if (typeof object.fee === "number")
                                message.fee = object.fee;
                            else if (typeof object.fee === "object")
                                message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a submit_proposal_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @static
                     * @param {koinos.contracts.governance.submit_proposal_arguments} message submit_proposal_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    submit_proposal_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.operations = [];
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.operation_merkle_root = "";
                            else {
                                object.operation_merkle_root = [];
                                if (options.bytes !== Array)
                                    object.operation_merkle_root = $util.newBuffer(object.operation_merkle_root);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.fee = options.longs === String ? "0" : 0;
                        }
                        if (message.operations && message.operations.length) {
                            object.operations = [];
                            for (var j = 0; j < message.operations.length; ++j)
                                object.operations[j] = $root.koinos.protocol.operation.toObject(message.operations[j], options);
                        }
                        if (message.operation_merkle_root != null && message.hasOwnProperty("operation_merkle_root"))
                            object.operation_merkle_root = options.bytes === String ? $util.base64.encode(message.operation_merkle_root, 0, message.operation_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.operation_merkle_root) : message.operation_merkle_root;
                        if (message.fee != null && message.hasOwnProperty("fee"))
                            if (typeof message.fee === "number")
                                object.fee = options.longs === String ? String(message.fee) : message.fee;
                            else
                                object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
                        return object;
                    };
    
                    /**
                     * Converts this submit_proposal_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.submit_proposal_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    submit_proposal_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return submit_proposal_arguments;
                })();
    
                governance.submit_proposal_result = (function() {
    
                    /**
                     * Properties of a submit_proposal_result.
                     * @memberof koinos.contracts.governance
                     * @interface Isubmit_proposal_result
                     */
    
                    /**
                     * Constructs a new submit_proposal_result.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a submit_proposal_result.
                     * @implements Isubmit_proposal_result
                     * @constructor
                     * @param {koinos.contracts.governance.Isubmit_proposal_result=} [properties] Properties to set
                     */
                    function submit_proposal_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new submit_proposal_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {koinos.contracts.governance.Isubmit_proposal_result=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.submit_proposal_result} submit_proposal_result instance
                     */
                    submit_proposal_result.create = function create(properties) {
                        return new submit_proposal_result(properties);
                    };
    
                    /**
                     * Encodes the specified submit_proposal_result message. Does not implicitly {@link koinos.contracts.governance.submit_proposal_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {koinos.contracts.governance.Isubmit_proposal_result} message submit_proposal_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_proposal_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified submit_proposal_result message, length delimited. Does not implicitly {@link koinos.contracts.governance.submit_proposal_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {koinos.contracts.governance.Isubmit_proposal_result} message submit_proposal_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_proposal_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a submit_proposal_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.submit_proposal_result} submit_proposal_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_proposal_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.submit_proposal_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a submit_proposal_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.submit_proposal_result} submit_proposal_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_proposal_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a submit_proposal_result message.
                     * @function verify
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    submit_proposal_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a submit_proposal_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.submit_proposal_result} submit_proposal_result
                     */
                    submit_proposal_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.submit_proposal_result)
                            return object;
                        return new $root.koinos.contracts.governance.submit_proposal_result();
                    };
    
                    /**
                     * Creates a plain object from a submit_proposal_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @static
                     * @param {koinos.contracts.governance.submit_proposal_result} message submit_proposal_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    submit_proposal_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this submit_proposal_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.submit_proposal_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    submit_proposal_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return submit_proposal_result;
                })();
    
                governance.get_proposal_by_id_arguments = (function() {
    
                    /**
                     * Properties of a get_proposal_by_id_arguments.
                     * @memberof koinos.contracts.governance
                     * @interface Iget_proposal_by_id_arguments
                     * @property {Uint8Array|null} [proposal_id] get_proposal_by_id_arguments proposal_id
                     */
    
                    /**
                     * Constructs a new get_proposal_by_id_arguments.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a get_proposal_by_id_arguments.
                     * @implements Iget_proposal_by_id_arguments
                     * @constructor
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_arguments=} [properties] Properties to set
                     */
                    function get_proposal_by_id_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_proposal_by_id_arguments proposal_id.
                     * @member {Uint8Array} proposal_id
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @instance
                     */
                    get_proposal_by_id_arguments.prototype.proposal_id = $util.newBuffer([]);
    
                    /**
                     * Creates a new get_proposal_by_id_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.get_proposal_by_id_arguments} get_proposal_by_id_arguments instance
                     */
                    get_proposal_by_id_arguments.create = function create(properties) {
                        return new get_proposal_by_id_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_proposal_by_id_arguments message. Does not implicitly {@link koinos.contracts.governance.get_proposal_by_id_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_arguments} message get_proposal_by_id_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposal_by_id_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.proposal_id != null && Object.hasOwnProperty.call(message, "proposal_id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.proposal_id);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_proposal_by_id_arguments message, length delimited. Does not implicitly {@link koinos.contracts.governance.get_proposal_by_id_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_arguments} message get_proposal_by_id_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposal_by_id_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_proposal_by_id_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.get_proposal_by_id_arguments} get_proposal_by_id_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposal_by_id_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.get_proposal_by_id_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.proposal_id = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_proposal_by_id_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.get_proposal_by_id_arguments} get_proposal_by_id_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposal_by_id_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_proposal_by_id_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_proposal_by_id_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                            if (!(message.proposal_id && typeof message.proposal_id.length === "number" || $util.isString(message.proposal_id)))
                                return "proposal_id: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_proposal_by_id_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.get_proposal_by_id_arguments} get_proposal_by_id_arguments
                     */
                    get_proposal_by_id_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.get_proposal_by_id_arguments)
                            return object;
                        var message = new $root.koinos.contracts.governance.get_proposal_by_id_arguments();
                        if (object.proposal_id != null)
                            if (typeof object.proposal_id === "string")
                                $util.base64.decode(object.proposal_id, message.proposal_id = $util.newBuffer($util.base64.length(object.proposal_id)), 0);
                            else if (object.proposal_id.length)
                                message.proposal_id = object.proposal_id;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_proposal_by_id_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @static
                     * @param {koinos.contracts.governance.get_proposal_by_id_arguments} message get_proposal_by_id_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_proposal_by_id_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.proposal_id = "";
                            else {
                                object.proposal_id = [];
                                if (options.bytes !== Array)
                                    object.proposal_id = $util.newBuffer(object.proposal_id);
                            }
                        if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                            object.proposal_id = options.bytes === String ? $util.base64.encode(message.proposal_id, 0, message.proposal_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposal_id) : message.proposal_id;
                        return object;
                    };
    
                    /**
                     * Converts this get_proposal_by_id_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.get_proposal_by_id_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_proposal_by_id_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_proposal_by_id_arguments;
                })();
    
                governance.get_proposal_by_id_result = (function() {
    
                    /**
                     * Properties of a get_proposal_by_id_result.
                     * @memberof koinos.contracts.governance
                     * @interface Iget_proposal_by_id_result
                     * @property {koinos.contracts.governance.Iproposal_record|null} [value] get_proposal_by_id_result value
                     */
    
                    /**
                     * Constructs a new get_proposal_by_id_result.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a get_proposal_by_id_result.
                     * @implements Iget_proposal_by_id_result
                     * @constructor
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_result=} [properties] Properties to set
                     */
                    function get_proposal_by_id_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_proposal_by_id_result value.
                     * @member {koinos.contracts.governance.Iproposal_record|null|undefined} value
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @instance
                     */
                    get_proposal_by_id_result.prototype.value = null;
    
                    /**
                     * Creates a new get_proposal_by_id_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_result=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.get_proposal_by_id_result} get_proposal_by_id_result instance
                     */
                    get_proposal_by_id_result.create = function create(properties) {
                        return new get_proposal_by_id_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_proposal_by_id_result message. Does not implicitly {@link koinos.contracts.governance.get_proposal_by_id_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_result} message get_proposal_by_id_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposal_by_id_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            $root.koinos.contracts.governance.proposal_record.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_proposal_by_id_result message, length delimited. Does not implicitly {@link koinos.contracts.governance.get_proposal_by_id_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposal_by_id_result} message get_proposal_by_id_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposal_by_id_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_proposal_by_id_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.get_proposal_by_id_result} get_proposal_by_id_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposal_by_id_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.get_proposal_by_id_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = $root.koinos.contracts.governance.proposal_record.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_proposal_by_id_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.get_proposal_by_id_result} get_proposal_by_id_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposal_by_id_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_proposal_by_id_result message.
                     * @function verify
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_proposal_by_id_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            var error = $root.koinos.contracts.governance.proposal_record.verify(message.value);
                            if (error)
                                return "value." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_proposal_by_id_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.get_proposal_by_id_result} get_proposal_by_id_result
                     */
                    get_proposal_by_id_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.get_proposal_by_id_result)
                            return object;
                        var message = new $root.koinos.contracts.governance.get_proposal_by_id_result();
                        if (object.value != null) {
                            if (typeof object.value !== "object")
                                throw TypeError(".koinos.contracts.governance.get_proposal_by_id_result.value: object expected");
                            message.value = $root.koinos.contracts.governance.proposal_record.fromObject(object.value);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_proposal_by_id_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @static
                     * @param {koinos.contracts.governance.get_proposal_by_id_result} message get_proposal_by_id_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_proposal_by_id_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = null;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = $root.koinos.contracts.governance.proposal_record.toObject(message.value, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_proposal_by_id_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.get_proposal_by_id_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_proposal_by_id_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_proposal_by_id_result;
                })();
    
                governance.get_proposals_by_status_arguments = (function() {
    
                    /**
                     * Properties of a get_proposals_by_status_arguments.
                     * @memberof koinos.contracts.governance
                     * @interface Iget_proposals_by_status_arguments
                     * @property {Uint8Array|null} [start_proposal] get_proposals_by_status_arguments start_proposal
                     * @property {number|Long|null} [limit] get_proposals_by_status_arguments limit
                     * @property {koinos.contracts.governance.proposal_status|null} [status] get_proposals_by_status_arguments status
                     */
    
                    /**
                     * Constructs a new get_proposals_by_status_arguments.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a get_proposals_by_status_arguments.
                     * @implements Iget_proposals_by_status_arguments
                     * @constructor
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_arguments=} [properties] Properties to set
                     */
                    function get_proposals_by_status_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_proposals_by_status_arguments start_proposal.
                     * @member {Uint8Array} start_proposal
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @instance
                     */
                    get_proposals_by_status_arguments.prototype.start_proposal = $util.newBuffer([]);
    
                    /**
                     * get_proposals_by_status_arguments limit.
                     * @member {number|Long} limit
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @instance
                     */
                    get_proposals_by_status_arguments.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * get_proposals_by_status_arguments status.
                     * @member {koinos.contracts.governance.proposal_status} status
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @instance
                     */
                    get_proposals_by_status_arguments.prototype.status = 0;
    
                    /**
                     * Creates a new get_proposals_by_status_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.get_proposals_by_status_arguments} get_proposals_by_status_arguments instance
                     */
                    get_proposals_by_status_arguments.create = function create(properties) {
                        return new get_proposals_by_status_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_proposals_by_status_arguments message. Does not implicitly {@link koinos.contracts.governance.get_proposals_by_status_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_arguments} message get_proposals_by_status_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_by_status_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start_proposal != null && Object.hasOwnProperty.call(message, "start_proposal"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.start_proposal);
                        if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.limit);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_proposals_by_status_arguments message, length delimited. Does not implicitly {@link koinos.contracts.governance.get_proposals_by_status_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_arguments} message get_proposals_by_status_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_by_status_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_proposals_by_status_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.get_proposals_by_status_arguments} get_proposals_by_status_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_by_status_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.get_proposals_by_status_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start_proposal = reader.bytes();
                                break;
                            case 2:
                                message.limit = reader.uint64();
                                break;
                            case 3:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_proposals_by_status_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.get_proposals_by_status_arguments} get_proposals_by_status_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_by_status_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_proposals_by_status_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_proposals_by_status_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start_proposal != null && message.hasOwnProperty("start_proposal"))
                            if (!(message.start_proposal && typeof message.start_proposal.length === "number" || $util.isString(message.start_proposal)))
                                return "start_proposal: buffer expected";
                        if (message.limit != null && message.hasOwnProperty("limit"))
                            if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                                return "limit: integer|Long expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a get_proposals_by_status_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.get_proposals_by_status_arguments} get_proposals_by_status_arguments
                     */
                    get_proposals_by_status_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.get_proposals_by_status_arguments)
                            return object;
                        var message = new $root.koinos.contracts.governance.get_proposals_by_status_arguments();
                        if (object.start_proposal != null)
                            if (typeof object.start_proposal === "string")
                                $util.base64.decode(object.start_proposal, message.start_proposal = $util.newBuffer($util.base64.length(object.start_proposal)), 0);
                            else if (object.start_proposal.length)
                                message.start_proposal = object.start_proposal;
                        if (object.limit != null)
                            if ($util.Long)
                                (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                            else if (typeof object.limit === "string")
                                message.limit = parseInt(object.limit, 10);
                            else if (typeof object.limit === "number")
                                message.limit = object.limit;
                            else if (typeof object.limit === "object")
                                message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                        switch (object.status) {
                        case "pending":
                        case 0:
                            message.status = 0;
                            break;
                        case "active":
                        case 1:
                            message.status = 1;
                            break;
                        case "approved":
                        case 2:
                            message.status = 2;
                            break;
                        case "expired":
                        case 3:
                            message.status = 3;
                            break;
                        case "applied":
                        case 4:
                            message.status = 4;
                            break;
                        case "failed":
                        case 5:
                            message.status = 5;
                            break;
                        case "reverted":
                        case 6:
                            message.status = 6;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_proposals_by_status_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @static
                     * @param {koinos.contracts.governance.get_proposals_by_status_arguments} message get_proposals_by_status_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_proposals_by_status_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.start_proposal = "";
                            else {
                                object.start_proposal = [];
                                if (options.bytes !== Array)
                                    object.start_proposal = $util.newBuffer(object.start_proposal);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.limit = options.longs === String ? "0" : 0;
                            object.status = options.enums === String ? "pending" : 0;
                        }
                        if (message.start_proposal != null && message.hasOwnProperty("start_proposal"))
                            object.start_proposal = options.bytes === String ? $util.base64.encode(message.start_proposal, 0, message.start_proposal.length) : options.bytes === Array ? Array.prototype.slice.call(message.start_proposal) : message.start_proposal;
                        if (message.limit != null && message.hasOwnProperty("limit"))
                            if (typeof message.limit === "number")
                                object.limit = options.longs === String ? String(message.limit) : message.limit;
                            else
                                object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.koinos.contracts.governance.proposal_status[message.status] : message.status;
                        return object;
                    };
    
                    /**
                     * Converts this get_proposals_by_status_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.get_proposals_by_status_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_proposals_by_status_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_proposals_by_status_arguments;
                })();
    
                governance.get_proposals_by_status_result = (function() {
    
                    /**
                     * Properties of a get_proposals_by_status_result.
                     * @memberof koinos.contracts.governance
                     * @interface Iget_proposals_by_status_result
                     * @property {Array.<koinos.contracts.governance.Iproposal_record>|null} [value] get_proposals_by_status_result value
                     */
    
                    /**
                     * Constructs a new get_proposals_by_status_result.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a get_proposals_by_status_result.
                     * @implements Iget_proposals_by_status_result
                     * @constructor
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_result=} [properties] Properties to set
                     */
                    function get_proposals_by_status_result(properties) {
                        this.value = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_proposals_by_status_result value.
                     * @member {Array.<koinos.contracts.governance.Iproposal_record>} value
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @instance
                     */
                    get_proposals_by_status_result.prototype.value = $util.emptyArray;
    
                    /**
                     * Creates a new get_proposals_by_status_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_result=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.get_proposals_by_status_result} get_proposals_by_status_result instance
                     */
                    get_proposals_by_status_result.create = function create(properties) {
                        return new get_proposals_by_status_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_proposals_by_status_result message. Does not implicitly {@link koinos.contracts.governance.get_proposals_by_status_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_result} message get_proposals_by_status_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_by_status_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.value.length)
                            for (var i = 0; i < message.value.length; ++i)
                                $root.koinos.contracts.governance.proposal_record.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_proposals_by_status_result message, length delimited. Does not implicitly {@link koinos.contracts.governance.get_proposals_by_status_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_by_status_result} message get_proposals_by_status_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_by_status_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_proposals_by_status_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.get_proposals_by_status_result} get_proposals_by_status_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_by_status_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.get_proposals_by_status_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                message.value.push($root.koinos.contracts.governance.proposal_record.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_proposals_by_status_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.get_proposals_by_status_result} get_proposals_by_status_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_by_status_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_proposals_by_status_result message.
                     * @function verify
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_proposals_by_status_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            if (!Array.isArray(message.value))
                                return "value: array expected";
                            for (var i = 0; i < message.value.length; ++i) {
                                var error = $root.koinos.contracts.governance.proposal_record.verify(message.value[i]);
                                if (error)
                                    return "value." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_proposals_by_status_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.get_proposals_by_status_result} get_proposals_by_status_result
                     */
                    get_proposals_by_status_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.get_proposals_by_status_result)
                            return object;
                        var message = new $root.koinos.contracts.governance.get_proposals_by_status_result();
                        if (object.value) {
                            if (!Array.isArray(object.value))
                                throw TypeError(".koinos.contracts.governance.get_proposals_by_status_result.value: array expected");
                            message.value = [];
                            for (var i = 0; i < object.value.length; ++i) {
                                if (typeof object.value[i] !== "object")
                                    throw TypeError(".koinos.contracts.governance.get_proposals_by_status_result.value: object expected");
                                message.value[i] = $root.koinos.contracts.governance.proposal_record.fromObject(object.value[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_proposals_by_status_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @static
                     * @param {koinos.contracts.governance.get_proposals_by_status_result} message get_proposals_by_status_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_proposals_by_status_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.value = [];
                        if (message.value && message.value.length) {
                            object.value = [];
                            for (var j = 0; j < message.value.length; ++j)
                                object.value[j] = $root.koinos.contracts.governance.proposal_record.toObject(message.value[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_proposals_by_status_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.get_proposals_by_status_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_proposals_by_status_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_proposals_by_status_result;
                })();
    
                governance.get_proposals_arguments = (function() {
    
                    /**
                     * Properties of a get_proposals_arguments.
                     * @memberof koinos.contracts.governance
                     * @interface Iget_proposals_arguments
                     * @property {Uint8Array|null} [start_proposal] get_proposals_arguments start_proposal
                     * @property {number|Long|null} [limit] get_proposals_arguments limit
                     */
    
                    /**
                     * Constructs a new get_proposals_arguments.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a get_proposals_arguments.
                     * @implements Iget_proposals_arguments
                     * @constructor
                     * @param {koinos.contracts.governance.Iget_proposals_arguments=} [properties] Properties to set
                     */
                    function get_proposals_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_proposals_arguments start_proposal.
                     * @member {Uint8Array} start_proposal
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @instance
                     */
                    get_proposals_arguments.prototype.start_proposal = $util.newBuffer([]);
    
                    /**
                     * get_proposals_arguments limit.
                     * @member {number|Long} limit
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @instance
                     */
                    get_proposals_arguments.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new get_proposals_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.get_proposals_arguments} get_proposals_arguments instance
                     */
                    get_proposals_arguments.create = function create(properties) {
                        return new get_proposals_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_proposals_arguments message. Does not implicitly {@link koinos.contracts.governance.get_proposals_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_arguments} message get_proposals_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start_proposal != null && Object.hasOwnProperty.call(message, "start_proposal"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.start_proposal);
                        if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.limit);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_proposals_arguments message, length delimited. Does not implicitly {@link koinos.contracts.governance.get_proposals_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_arguments} message get_proposals_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_proposals_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.get_proposals_arguments} get_proposals_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.get_proposals_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start_proposal = reader.bytes();
                                break;
                            case 2:
                                message.limit = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_proposals_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.get_proposals_arguments} get_proposals_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_proposals_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_proposals_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start_proposal != null && message.hasOwnProperty("start_proposal"))
                            if (!(message.start_proposal && typeof message.start_proposal.length === "number" || $util.isString(message.start_proposal)))
                                return "start_proposal: buffer expected";
                        if (message.limit != null && message.hasOwnProperty("limit"))
                            if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                                return "limit: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_proposals_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.get_proposals_arguments} get_proposals_arguments
                     */
                    get_proposals_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.get_proposals_arguments)
                            return object;
                        var message = new $root.koinos.contracts.governance.get_proposals_arguments();
                        if (object.start_proposal != null)
                            if (typeof object.start_proposal === "string")
                                $util.base64.decode(object.start_proposal, message.start_proposal = $util.newBuffer($util.base64.length(object.start_proposal)), 0);
                            else if (object.start_proposal.length)
                                message.start_proposal = object.start_proposal;
                        if (object.limit != null)
                            if ($util.Long)
                                (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                            else if (typeof object.limit === "string")
                                message.limit = parseInt(object.limit, 10);
                            else if (typeof object.limit === "number")
                                message.limit = object.limit;
                            else if (typeof object.limit === "object")
                                message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_proposals_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @static
                     * @param {koinos.contracts.governance.get_proposals_arguments} message get_proposals_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_proposals_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.start_proposal = "";
                            else {
                                object.start_proposal = [];
                                if (options.bytes !== Array)
                                    object.start_proposal = $util.newBuffer(object.start_proposal);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.limit = options.longs === String ? "0" : 0;
                        }
                        if (message.start_proposal != null && message.hasOwnProperty("start_proposal"))
                            object.start_proposal = options.bytes === String ? $util.base64.encode(message.start_proposal, 0, message.start_proposal.length) : options.bytes === Array ? Array.prototype.slice.call(message.start_proposal) : message.start_proposal;
                        if (message.limit != null && message.hasOwnProperty("limit"))
                            if (typeof message.limit === "number")
                                object.limit = options.longs === String ? String(message.limit) : message.limit;
                            else
                                object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                        return object;
                    };
    
                    /**
                     * Converts this get_proposals_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.get_proposals_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_proposals_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_proposals_arguments;
                })();
    
                governance.get_proposals_result = (function() {
    
                    /**
                     * Properties of a get_proposals_result.
                     * @memberof koinos.contracts.governance
                     * @interface Iget_proposals_result
                     * @property {Array.<koinos.contracts.governance.Iproposal_record>|null} [value] get_proposals_result value
                     */
    
                    /**
                     * Constructs a new get_proposals_result.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a get_proposals_result.
                     * @implements Iget_proposals_result
                     * @constructor
                     * @param {koinos.contracts.governance.Iget_proposals_result=} [properties] Properties to set
                     */
                    function get_proposals_result(properties) {
                        this.value = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_proposals_result value.
                     * @member {Array.<koinos.contracts.governance.Iproposal_record>} value
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @instance
                     */
                    get_proposals_result.prototype.value = $util.emptyArray;
    
                    /**
                     * Creates a new get_proposals_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_result=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.get_proposals_result} get_proposals_result instance
                     */
                    get_proposals_result.create = function create(properties) {
                        return new get_proposals_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_proposals_result message. Does not implicitly {@link koinos.contracts.governance.get_proposals_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_result} message get_proposals_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.value.length)
                            for (var i = 0; i < message.value.length; ++i)
                                $root.koinos.contracts.governance.proposal_record.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_proposals_result message, length delimited. Does not implicitly {@link koinos.contracts.governance.get_proposals_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {koinos.contracts.governance.Iget_proposals_result} message get_proposals_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_proposals_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_proposals_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.get_proposals_result} get_proposals_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.get_proposals_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                message.value.push($root.koinos.contracts.governance.proposal_record.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_proposals_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.get_proposals_result} get_proposals_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_proposals_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_proposals_result message.
                     * @function verify
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_proposals_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            if (!Array.isArray(message.value))
                                return "value: array expected";
                            for (var i = 0; i < message.value.length; ++i) {
                                var error = $root.koinos.contracts.governance.proposal_record.verify(message.value[i]);
                                if (error)
                                    return "value." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_proposals_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.get_proposals_result} get_proposals_result
                     */
                    get_proposals_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.get_proposals_result)
                            return object;
                        var message = new $root.koinos.contracts.governance.get_proposals_result();
                        if (object.value) {
                            if (!Array.isArray(object.value))
                                throw TypeError(".koinos.contracts.governance.get_proposals_result.value: array expected");
                            message.value = [];
                            for (var i = 0; i < object.value.length; ++i) {
                                if (typeof object.value[i] !== "object")
                                    throw TypeError(".koinos.contracts.governance.get_proposals_result.value: object expected");
                                message.value[i] = $root.koinos.contracts.governance.proposal_record.fromObject(object.value[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_proposals_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @static
                     * @param {koinos.contracts.governance.get_proposals_result} message get_proposals_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_proposals_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.value = [];
                        if (message.value && message.value.length) {
                            object.value = [];
                            for (var j = 0; j < message.value.length; ++j)
                                object.value[j] = $root.koinos.contracts.governance.proposal_record.toObject(message.value[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_proposals_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.get_proposals_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_proposals_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_proposals_result;
                })();
    
                governance.proposal_submission_event = (function() {
    
                    /**
                     * Properties of a proposal_submission_event.
                     * @memberof koinos.contracts.governance
                     * @interface Iproposal_submission_event
                     * @property {koinos.contracts.governance.Iproposal_record|null} [proposal] proposal_submission_event proposal
                     */
    
                    /**
                     * Constructs a new proposal_submission_event.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a proposal_submission_event.
                     * @implements Iproposal_submission_event
                     * @constructor
                     * @param {koinos.contracts.governance.Iproposal_submission_event=} [properties] Properties to set
                     */
                    function proposal_submission_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * proposal_submission_event proposal.
                     * @member {koinos.contracts.governance.Iproposal_record|null|undefined} proposal
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @instance
                     */
                    proposal_submission_event.prototype.proposal = null;
    
                    /**
                     * Creates a new proposal_submission_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_submission_event=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.proposal_submission_event} proposal_submission_event instance
                     */
                    proposal_submission_event.create = function create(properties) {
                        return new proposal_submission_event(properties);
                    };
    
                    /**
                     * Encodes the specified proposal_submission_event message. Does not implicitly {@link koinos.contracts.governance.proposal_submission_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_submission_event} message proposal_submission_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_submission_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.proposal != null && Object.hasOwnProperty.call(message, "proposal"))
                            $root.koinos.contracts.governance.proposal_record.encode(message.proposal, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified proposal_submission_event message, length delimited. Does not implicitly {@link koinos.contracts.governance.proposal_submission_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_submission_event} message proposal_submission_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_submission_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a proposal_submission_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.proposal_submission_event} proposal_submission_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_submission_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.proposal_submission_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.proposal = $root.koinos.contracts.governance.proposal_record.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a proposal_submission_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.proposal_submission_event} proposal_submission_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_submission_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a proposal_submission_event message.
                     * @function verify
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    proposal_submission_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.proposal != null && message.hasOwnProperty("proposal")) {
                            var error = $root.koinos.contracts.governance.proposal_record.verify(message.proposal);
                            if (error)
                                return "proposal." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a proposal_submission_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.proposal_submission_event} proposal_submission_event
                     */
                    proposal_submission_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.proposal_submission_event)
                            return object;
                        var message = new $root.koinos.contracts.governance.proposal_submission_event();
                        if (object.proposal != null) {
                            if (typeof object.proposal !== "object")
                                throw TypeError(".koinos.contracts.governance.proposal_submission_event.proposal: object expected");
                            message.proposal = $root.koinos.contracts.governance.proposal_record.fromObject(object.proposal);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a proposal_submission_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @static
                     * @param {koinos.contracts.governance.proposal_submission_event} message proposal_submission_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    proposal_submission_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.proposal = null;
                        if (message.proposal != null && message.hasOwnProperty("proposal"))
                            object.proposal = $root.koinos.contracts.governance.proposal_record.toObject(message.proposal, options);
                        return object;
                    };
    
                    /**
                     * Converts this proposal_submission_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.proposal_submission_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    proposal_submission_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return proposal_submission_event;
                })();
    
                governance.proposal_status_event = (function() {
    
                    /**
                     * Properties of a proposal_status_event.
                     * @memberof koinos.contracts.governance
                     * @interface Iproposal_status_event
                     * @property {Uint8Array|null} [id] proposal_status_event id
                     * @property {koinos.contracts.governance.proposal_status|null} [status] proposal_status_event status
                     */
    
                    /**
                     * Constructs a new proposal_status_event.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a proposal_status_event.
                     * @implements Iproposal_status_event
                     * @constructor
                     * @param {koinos.contracts.governance.Iproposal_status_event=} [properties] Properties to set
                     */
                    function proposal_status_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * proposal_status_event id.
                     * @member {Uint8Array} id
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @instance
                     */
                    proposal_status_event.prototype.id = $util.newBuffer([]);
    
                    /**
                     * proposal_status_event status.
                     * @member {koinos.contracts.governance.proposal_status} status
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @instance
                     */
                    proposal_status_event.prototype.status = 0;
    
                    /**
                     * Creates a new proposal_status_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_status_event=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.proposal_status_event} proposal_status_event instance
                     */
                    proposal_status_event.create = function create(properties) {
                        return new proposal_status_event(properties);
                    };
    
                    /**
                     * Encodes the specified proposal_status_event message. Does not implicitly {@link koinos.contracts.governance.proposal_status_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_status_event} message proposal_status_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_status_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified proposal_status_event message, length delimited. Does not implicitly {@link koinos.contracts.governance.proposal_status_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_status_event} message proposal_status_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_status_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a proposal_status_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.proposal_status_event} proposal_status_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_status_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.proposal_status_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.bytes();
                                break;
                            case 2:
                                message.status = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a proposal_status_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.proposal_status_event} proposal_status_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_status_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a proposal_status_event message.
                     * @function verify
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    proposal_status_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                                return "id: buffer expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        return null;
                    };
    
                    /**
                     * Creates a proposal_status_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.proposal_status_event} proposal_status_event
                     */
                    proposal_status_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.proposal_status_event)
                            return object;
                        var message = new $root.koinos.contracts.governance.proposal_status_event();
                        if (object.id != null)
                            if (typeof object.id === "string")
                                $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                            else if (object.id.length)
                                message.id = object.id;
                        switch (object.status) {
                        case "pending":
                        case 0:
                            message.status = 0;
                            break;
                        case "active":
                        case 1:
                            message.status = 1;
                            break;
                        case "approved":
                        case 2:
                            message.status = 2;
                            break;
                        case "expired":
                        case 3:
                            message.status = 3;
                            break;
                        case "applied":
                        case 4:
                            message.status = 4;
                            break;
                        case "failed":
                        case 5:
                            message.status = 5;
                            break;
                        case "reverted":
                        case 6:
                            message.status = 6;
                            break;
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a proposal_status_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @static
                     * @param {koinos.contracts.governance.proposal_status_event} message proposal_status_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    proposal_status_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.id = "";
                            else {
                                object.id = [];
                                if (options.bytes !== Array)
                                    object.id = $util.newBuffer(object.id);
                            }
                            object.status = options.enums === String ? "pending" : 0;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.koinos.contracts.governance.proposal_status[message.status] : message.status;
                        return object;
                    };
    
                    /**
                     * Converts this proposal_status_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.proposal_status_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    proposal_status_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return proposal_status_event;
                })();
    
                governance.proposal_vote_event = (function() {
    
                    /**
                     * Properties of a proposal_vote_event.
                     * @memberof koinos.contracts.governance
                     * @interface Iproposal_vote_event
                     * @property {Uint8Array|null} [id] proposal_vote_event id
                     * @property {number|Long|null} [vote_tally] proposal_vote_event vote_tally
                     * @property {number|Long|null} [vote_threshold] proposal_vote_event vote_threshold
                     */
    
                    /**
                     * Constructs a new proposal_vote_event.
                     * @memberof koinos.contracts.governance
                     * @classdesc Represents a proposal_vote_event.
                     * @implements Iproposal_vote_event
                     * @constructor
                     * @param {koinos.contracts.governance.Iproposal_vote_event=} [properties] Properties to set
                     */
                    function proposal_vote_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * proposal_vote_event id.
                     * @member {Uint8Array} id
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @instance
                     */
                    proposal_vote_event.prototype.id = $util.newBuffer([]);
    
                    /**
                     * proposal_vote_event vote_tally.
                     * @member {number|Long} vote_tally
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @instance
                     */
                    proposal_vote_event.prototype.vote_tally = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * proposal_vote_event vote_threshold.
                     * @member {number|Long} vote_threshold
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @instance
                     */
                    proposal_vote_event.prototype.vote_threshold = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new proposal_vote_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_vote_event=} [properties] Properties to set
                     * @returns {koinos.contracts.governance.proposal_vote_event} proposal_vote_event instance
                     */
                    proposal_vote_event.create = function create(properties) {
                        return new proposal_vote_event(properties);
                    };
    
                    /**
                     * Encodes the specified proposal_vote_event message. Does not implicitly {@link koinos.contracts.governance.proposal_vote_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_vote_event} message proposal_vote_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_vote_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                        if (message.vote_tally != null && Object.hasOwnProperty.call(message, "vote_tally"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.vote_tally);
                        if (message.vote_threshold != null && Object.hasOwnProperty.call(message, "vote_threshold"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.vote_threshold);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified proposal_vote_event message, length delimited. Does not implicitly {@link koinos.contracts.governance.proposal_vote_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {koinos.contracts.governance.Iproposal_vote_event} message proposal_vote_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    proposal_vote_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a proposal_vote_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.governance.proposal_vote_event} proposal_vote_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_vote_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.governance.proposal_vote_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.bytes();
                                break;
                            case 2:
                                message.vote_tally = reader.uint64();
                                break;
                            case 3:
                                message.vote_threshold = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a proposal_vote_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.governance.proposal_vote_event} proposal_vote_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    proposal_vote_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a proposal_vote_event message.
                     * @function verify
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    proposal_vote_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                                return "id: buffer expected";
                        if (message.vote_tally != null && message.hasOwnProperty("vote_tally"))
                            if (!$util.isInteger(message.vote_tally) && !(message.vote_tally && $util.isInteger(message.vote_tally.low) && $util.isInteger(message.vote_tally.high)))
                                return "vote_tally: integer|Long expected";
                        if (message.vote_threshold != null && message.hasOwnProperty("vote_threshold"))
                            if (!$util.isInteger(message.vote_threshold) && !(message.vote_threshold && $util.isInteger(message.vote_threshold.low) && $util.isInteger(message.vote_threshold.high)))
                                return "vote_threshold: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a proposal_vote_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.governance.proposal_vote_event} proposal_vote_event
                     */
                    proposal_vote_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.governance.proposal_vote_event)
                            return object;
                        var message = new $root.koinos.contracts.governance.proposal_vote_event();
                        if (object.id != null)
                            if (typeof object.id === "string")
                                $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                            else if (object.id.length)
                                message.id = object.id;
                        if (object.vote_tally != null)
                            if ($util.Long)
                                (message.vote_tally = $util.Long.fromValue(object.vote_tally)).unsigned = true;
                            else if (typeof object.vote_tally === "string")
                                message.vote_tally = parseInt(object.vote_tally, 10);
                            else if (typeof object.vote_tally === "number")
                                message.vote_tally = object.vote_tally;
                            else if (typeof object.vote_tally === "object")
                                message.vote_tally = new $util.LongBits(object.vote_tally.low >>> 0, object.vote_tally.high >>> 0).toNumber(true);
                        if (object.vote_threshold != null)
                            if ($util.Long)
                                (message.vote_threshold = $util.Long.fromValue(object.vote_threshold)).unsigned = true;
                            else if (typeof object.vote_threshold === "string")
                                message.vote_threshold = parseInt(object.vote_threshold, 10);
                            else if (typeof object.vote_threshold === "number")
                                message.vote_threshold = object.vote_threshold;
                            else if (typeof object.vote_threshold === "object")
                                message.vote_threshold = new $util.LongBits(object.vote_threshold.low >>> 0, object.vote_threshold.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a proposal_vote_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @static
                     * @param {koinos.contracts.governance.proposal_vote_event} message proposal_vote_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    proposal_vote_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.id = "";
                            else {
                                object.id = [];
                                if (options.bytes !== Array)
                                    object.id = $util.newBuffer(object.id);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.vote_tally = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.vote_tally = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.vote_threshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.vote_threshold = options.longs === String ? "0" : 0;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                        if (message.vote_tally != null && message.hasOwnProperty("vote_tally"))
                            if (typeof message.vote_tally === "number")
                                object.vote_tally = options.longs === String ? String(message.vote_tally) : message.vote_tally;
                            else
                                object.vote_tally = options.longs === String ? $util.Long.prototype.toString.call(message.vote_tally) : options.longs === Number ? new $util.LongBits(message.vote_tally.low >>> 0, message.vote_tally.high >>> 0).toNumber(true) : message.vote_tally;
                        if (message.vote_threshold != null && message.hasOwnProperty("vote_threshold"))
                            if (typeof message.vote_threshold === "number")
                                object.vote_threshold = options.longs === String ? String(message.vote_threshold) : message.vote_threshold;
                            else
                                object.vote_threshold = options.longs === String ? $util.Long.prototype.toString.call(message.vote_threshold) : options.longs === Number ? new $util.LongBits(message.vote_threshold.low >>> 0, message.vote_threshold.high >>> 0).toNumber(true) : message.vote_threshold;
                        return object;
                    };
    
                    /**
                     * Converts this proposal_vote_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.governance.proposal_vote_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    proposal_vote_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return proposal_vote_event;
                })();
    
                return governance;
            })();
    
            contracts.pow = (function() {
    
                /**
                 * Namespace pow.
                 * @memberof koinos.contracts
                 * @namespace
                 */
                var pow = {};
    
                pow.difficulty_metadata = (function() {
    
                    /**
                     * Properties of a difficulty_metadata.
                     * @memberof koinos.contracts.pow
                     * @interface Idifficulty_metadata
                     * @property {Uint8Array|null} [target] difficulty_metadata target
                     * @property {number|Long|null} [last_block_time] difficulty_metadata last_block_time
                     * @property {Uint8Array|null} [difficulty] difficulty_metadata difficulty
                     * @property {number|Long|null} [target_block_interval] difficulty_metadata target_block_interval
                     */
    
                    /**
                     * Constructs a new difficulty_metadata.
                     * @memberof koinos.contracts.pow
                     * @classdesc Represents a difficulty_metadata.
                     * @implements Idifficulty_metadata
                     * @constructor
                     * @param {koinos.contracts.pow.Idifficulty_metadata=} [properties] Properties to set
                     */
                    function difficulty_metadata(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * difficulty_metadata target.
                     * @member {Uint8Array} target
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @instance
                     */
                    difficulty_metadata.prototype.target = $util.newBuffer([]);
    
                    /**
                     * difficulty_metadata last_block_time.
                     * @member {number|Long} last_block_time
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @instance
                     */
                    difficulty_metadata.prototype.last_block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * difficulty_metadata difficulty.
                     * @member {Uint8Array} difficulty
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @instance
                     */
                    difficulty_metadata.prototype.difficulty = $util.newBuffer([]);
    
                    /**
                     * difficulty_metadata target_block_interval.
                     * @member {number|Long} target_block_interval
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @instance
                     */
                    difficulty_metadata.prototype.target_block_interval = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new difficulty_metadata instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {koinos.contracts.pow.Idifficulty_metadata=} [properties] Properties to set
                     * @returns {koinos.contracts.pow.difficulty_metadata} difficulty_metadata instance
                     */
                    difficulty_metadata.create = function create(properties) {
                        return new difficulty_metadata(properties);
                    };
    
                    /**
                     * Encodes the specified difficulty_metadata message. Does not implicitly {@link koinos.contracts.pow.difficulty_metadata.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {koinos.contracts.pow.Idifficulty_metadata} message difficulty_metadata message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    difficulty_metadata.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.target);
                        if (message.last_block_time != null && Object.hasOwnProperty.call(message, "last_block_time"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.last_block_time);
                        if (message.difficulty != null && Object.hasOwnProperty.call(message, "difficulty"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.difficulty);
                        if (message.target_block_interval != null && Object.hasOwnProperty.call(message, "target_block_interval"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.target_block_interval);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified difficulty_metadata message, length delimited. Does not implicitly {@link koinos.contracts.pow.difficulty_metadata.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {koinos.contracts.pow.Idifficulty_metadata} message difficulty_metadata message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    difficulty_metadata.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a difficulty_metadata message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pow.difficulty_metadata} difficulty_metadata
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    difficulty_metadata.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pow.difficulty_metadata();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.target = reader.bytes();
                                break;
                            case 2:
                                message.last_block_time = reader.uint64();
                                break;
                            case 3:
                                message.difficulty = reader.bytes();
                                break;
                            case 4:
                                message.target_block_interval = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a difficulty_metadata message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pow.difficulty_metadata} difficulty_metadata
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    difficulty_metadata.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a difficulty_metadata message.
                     * @function verify
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    difficulty_metadata.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.target != null && message.hasOwnProperty("target"))
                            if (!(message.target && typeof message.target.length === "number" || $util.isString(message.target)))
                                return "target: buffer expected";
                        if (message.last_block_time != null && message.hasOwnProperty("last_block_time"))
                            if (!$util.isInteger(message.last_block_time) && !(message.last_block_time && $util.isInteger(message.last_block_time.low) && $util.isInteger(message.last_block_time.high)))
                                return "last_block_time: integer|Long expected";
                        if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                            if (!(message.difficulty && typeof message.difficulty.length === "number" || $util.isString(message.difficulty)))
                                return "difficulty: buffer expected";
                        if (message.target_block_interval != null && message.hasOwnProperty("target_block_interval"))
                            if (!$util.isInteger(message.target_block_interval) && !(message.target_block_interval && $util.isInteger(message.target_block_interval.low) && $util.isInteger(message.target_block_interval.high)))
                                return "target_block_interval: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a difficulty_metadata message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pow.difficulty_metadata} difficulty_metadata
                     */
                    difficulty_metadata.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pow.difficulty_metadata)
                            return object;
                        var message = new $root.koinos.contracts.pow.difficulty_metadata();
                        if (object.target != null)
                            if (typeof object.target === "string")
                                $util.base64.decode(object.target, message.target = $util.newBuffer($util.base64.length(object.target)), 0);
                            else if (object.target.length)
                                message.target = object.target;
                        if (object.last_block_time != null)
                            if ($util.Long)
                                (message.last_block_time = $util.Long.fromValue(object.last_block_time)).unsigned = true;
                            else if (typeof object.last_block_time === "string")
                                message.last_block_time = parseInt(object.last_block_time, 10);
                            else if (typeof object.last_block_time === "number")
                                message.last_block_time = object.last_block_time;
                            else if (typeof object.last_block_time === "object")
                                message.last_block_time = new $util.LongBits(object.last_block_time.low >>> 0, object.last_block_time.high >>> 0).toNumber(true);
                        if (object.difficulty != null)
                            if (typeof object.difficulty === "string")
                                $util.base64.decode(object.difficulty, message.difficulty = $util.newBuffer($util.base64.length(object.difficulty)), 0);
                            else if (object.difficulty.length)
                                message.difficulty = object.difficulty;
                        if (object.target_block_interval != null)
                            if ($util.Long)
                                (message.target_block_interval = $util.Long.fromValue(object.target_block_interval)).unsigned = true;
                            else if (typeof object.target_block_interval === "string")
                                message.target_block_interval = parseInt(object.target_block_interval, 10);
                            else if (typeof object.target_block_interval === "number")
                                message.target_block_interval = object.target_block_interval;
                            else if (typeof object.target_block_interval === "object")
                                message.target_block_interval = new $util.LongBits(object.target_block_interval.low >>> 0, object.target_block_interval.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a difficulty_metadata message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @static
                     * @param {koinos.contracts.pow.difficulty_metadata} message difficulty_metadata
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    difficulty_metadata.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.target = "";
                            else {
                                object.target = [];
                                if (options.bytes !== Array)
                                    object.target = $util.newBuffer(object.target);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.last_block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.last_block_time = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.difficulty = "";
                            else {
                                object.difficulty = [];
                                if (options.bytes !== Array)
                                    object.difficulty = $util.newBuffer(object.difficulty);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.target_block_interval = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.target_block_interval = options.longs === String ? "0" : 0;
                        }
                        if (message.target != null && message.hasOwnProperty("target"))
                            object.target = options.bytes === String ? $util.base64.encode(message.target, 0, message.target.length) : options.bytes === Array ? Array.prototype.slice.call(message.target) : message.target;
                        if (message.last_block_time != null && message.hasOwnProperty("last_block_time"))
                            if (typeof message.last_block_time === "number")
                                object.last_block_time = options.longs === String ? String(message.last_block_time) : message.last_block_time;
                            else
                                object.last_block_time = options.longs === String ? $util.Long.prototype.toString.call(message.last_block_time) : options.longs === Number ? new $util.LongBits(message.last_block_time.low >>> 0, message.last_block_time.high >>> 0).toNumber(true) : message.last_block_time;
                        if (message.difficulty != null && message.hasOwnProperty("difficulty"))
                            object.difficulty = options.bytes === String ? $util.base64.encode(message.difficulty, 0, message.difficulty.length) : options.bytes === Array ? Array.prototype.slice.call(message.difficulty) : message.difficulty;
                        if (message.target_block_interval != null && message.hasOwnProperty("target_block_interval"))
                            if (typeof message.target_block_interval === "number")
                                object.target_block_interval = options.longs === String ? String(message.target_block_interval) : message.target_block_interval;
                            else
                                object.target_block_interval = options.longs === String ? $util.Long.prototype.toString.call(message.target_block_interval) : options.longs === Number ? new $util.LongBits(message.target_block_interval.low >>> 0, message.target_block_interval.high >>> 0).toNumber(true) : message.target_block_interval;
                        return object;
                    };
    
                    /**
                     * Converts this difficulty_metadata to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pow.difficulty_metadata
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    difficulty_metadata.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return difficulty_metadata;
                })();
    
                pow.get_difficulty_metadata_arguments = (function() {
    
                    /**
                     * Properties of a get_difficulty_metadata_arguments.
                     * @memberof koinos.contracts.pow
                     * @interface Iget_difficulty_metadata_arguments
                     */
    
                    /**
                     * Constructs a new get_difficulty_metadata_arguments.
                     * @memberof koinos.contracts.pow
                     * @classdesc Represents a get_difficulty_metadata_arguments.
                     * @implements Iget_difficulty_metadata_arguments
                     * @constructor
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_arguments=} [properties] Properties to set
                     */
                    function get_difficulty_metadata_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_difficulty_metadata_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_arguments} get_difficulty_metadata_arguments instance
                     */
                    get_difficulty_metadata_arguments.create = function create(properties) {
                        return new get_difficulty_metadata_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified get_difficulty_metadata_arguments message. Does not implicitly {@link koinos.contracts.pow.get_difficulty_metadata_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_arguments} message get_difficulty_metadata_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_difficulty_metadata_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_difficulty_metadata_arguments message, length delimited. Does not implicitly {@link koinos.contracts.pow.get_difficulty_metadata_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_arguments} message get_difficulty_metadata_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_difficulty_metadata_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_difficulty_metadata_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_arguments} get_difficulty_metadata_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_difficulty_metadata_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pow.get_difficulty_metadata_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_difficulty_metadata_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_arguments} get_difficulty_metadata_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_difficulty_metadata_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_difficulty_metadata_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_difficulty_metadata_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_difficulty_metadata_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_arguments} get_difficulty_metadata_arguments
                     */
                    get_difficulty_metadata_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pow.get_difficulty_metadata_arguments)
                            return object;
                        return new $root.koinos.contracts.pow.get_difficulty_metadata_arguments();
                    };
    
                    /**
                     * Creates a plain object from a get_difficulty_metadata_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @static
                     * @param {koinos.contracts.pow.get_difficulty_metadata_arguments} message get_difficulty_metadata_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_difficulty_metadata_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_difficulty_metadata_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_difficulty_metadata_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_difficulty_metadata_arguments;
                })();
    
                pow.get_difficulty_metadata_result = (function() {
    
                    /**
                     * Properties of a get_difficulty_metadata_result.
                     * @memberof koinos.contracts.pow
                     * @interface Iget_difficulty_metadata_result
                     * @property {koinos.contracts.pow.Idifficulty_metadata|null} [value] get_difficulty_metadata_result value
                     */
    
                    /**
                     * Constructs a new get_difficulty_metadata_result.
                     * @memberof koinos.contracts.pow
                     * @classdesc Represents a get_difficulty_metadata_result.
                     * @implements Iget_difficulty_metadata_result
                     * @constructor
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_result=} [properties] Properties to set
                     */
                    function get_difficulty_metadata_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_difficulty_metadata_result value.
                     * @member {koinos.contracts.pow.Idifficulty_metadata|null|undefined} value
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @instance
                     */
                    get_difficulty_metadata_result.prototype.value = null;
    
                    /**
                     * Creates a new get_difficulty_metadata_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_result=} [properties] Properties to set
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_result} get_difficulty_metadata_result instance
                     */
                    get_difficulty_metadata_result.create = function create(properties) {
                        return new get_difficulty_metadata_result(properties);
                    };
    
                    /**
                     * Encodes the specified get_difficulty_metadata_result message. Does not implicitly {@link koinos.contracts.pow.get_difficulty_metadata_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_result} message get_difficulty_metadata_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_difficulty_metadata_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            $root.koinos.contracts.pow.difficulty_metadata.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_difficulty_metadata_result message, length delimited. Does not implicitly {@link koinos.contracts.pow.get_difficulty_metadata_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {koinos.contracts.pow.Iget_difficulty_metadata_result} message get_difficulty_metadata_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_difficulty_metadata_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_difficulty_metadata_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_result} get_difficulty_metadata_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_difficulty_metadata_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pow.get_difficulty_metadata_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = $root.koinos.contracts.pow.difficulty_metadata.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_difficulty_metadata_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_result} get_difficulty_metadata_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_difficulty_metadata_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_difficulty_metadata_result message.
                     * @function verify
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_difficulty_metadata_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            var error = $root.koinos.contracts.pow.difficulty_metadata.verify(message.value);
                            if (error)
                                return "value." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_difficulty_metadata_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pow.get_difficulty_metadata_result} get_difficulty_metadata_result
                     */
                    get_difficulty_metadata_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pow.get_difficulty_metadata_result)
                            return object;
                        var message = new $root.koinos.contracts.pow.get_difficulty_metadata_result();
                        if (object.value != null) {
                            if (typeof object.value !== "object")
                                throw TypeError(".koinos.contracts.pow.get_difficulty_metadata_result.value: object expected");
                            message.value = $root.koinos.contracts.pow.difficulty_metadata.fromObject(object.value);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_difficulty_metadata_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @static
                     * @param {koinos.contracts.pow.get_difficulty_metadata_result} message get_difficulty_metadata_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_difficulty_metadata_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = null;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = $root.koinos.contracts.pow.difficulty_metadata.toObject(message.value, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_difficulty_metadata_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pow.get_difficulty_metadata_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_difficulty_metadata_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_difficulty_metadata_result;
                })();
    
                pow.pow_signature_data = (function() {
    
                    /**
                     * Properties of a pow_signature_data.
                     * @memberof koinos.contracts.pow
                     * @interface Ipow_signature_data
                     * @property {Uint8Array|null} [nonce] pow_signature_data nonce
                     * @property {Uint8Array|null} [recoverable_signature] pow_signature_data recoverable_signature
                     */
    
                    /**
                     * Constructs a new pow_signature_data.
                     * @memberof koinos.contracts.pow
                     * @classdesc Represents a pow_signature_data.
                     * @implements Ipow_signature_data
                     * @constructor
                     * @param {koinos.contracts.pow.Ipow_signature_data=} [properties] Properties to set
                     */
                    function pow_signature_data(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * pow_signature_data nonce.
                     * @member {Uint8Array} nonce
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @instance
                     */
                    pow_signature_data.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * pow_signature_data recoverable_signature.
                     * @member {Uint8Array} recoverable_signature
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @instance
                     */
                    pow_signature_data.prototype.recoverable_signature = $util.newBuffer([]);
    
                    /**
                     * Creates a new pow_signature_data instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {koinos.contracts.pow.Ipow_signature_data=} [properties] Properties to set
                     * @returns {koinos.contracts.pow.pow_signature_data} pow_signature_data instance
                     */
                    pow_signature_data.create = function create(properties) {
                        return new pow_signature_data(properties);
                    };
    
                    /**
                     * Encodes the specified pow_signature_data message. Does not implicitly {@link koinos.contracts.pow.pow_signature_data.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {koinos.contracts.pow.Ipow_signature_data} message pow_signature_data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    pow_signature_data.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
                        if (message.recoverable_signature != null && Object.hasOwnProperty.call(message, "recoverable_signature"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.recoverable_signature);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified pow_signature_data message, length delimited. Does not implicitly {@link koinos.contracts.pow.pow_signature_data.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {koinos.contracts.pow.Ipow_signature_data} message pow_signature_data message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    pow_signature_data.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a pow_signature_data message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.pow.pow_signature_data} pow_signature_data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    pow_signature_data.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.pow.pow_signature_data();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nonce = reader.bytes();
                                break;
                            case 2:
                                message.recoverable_signature = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a pow_signature_data message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.pow.pow_signature_data} pow_signature_data
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    pow_signature_data.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a pow_signature_data message.
                     * @function verify
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    pow_signature_data.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        if (message.recoverable_signature != null && message.hasOwnProperty("recoverable_signature"))
                            if (!(message.recoverable_signature && typeof message.recoverable_signature.length === "number" || $util.isString(message.recoverable_signature)))
                                return "recoverable_signature: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a pow_signature_data message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.pow.pow_signature_data} pow_signature_data
                     */
                    pow_signature_data.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.pow.pow_signature_data)
                            return object;
                        var message = new $root.koinos.contracts.pow.pow_signature_data();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        if (object.recoverable_signature != null)
                            if (typeof object.recoverable_signature === "string")
                                $util.base64.decode(object.recoverable_signature, message.recoverable_signature = $util.newBuffer($util.base64.length(object.recoverable_signature)), 0);
                            else if (object.recoverable_signature.length)
                                message.recoverable_signature = object.recoverable_signature;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a pow_signature_data message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @static
                     * @param {koinos.contracts.pow.pow_signature_data} message pow_signature_data
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    pow_signature_data.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                            if (options.bytes === String)
                                object.recoverable_signature = "";
                            else {
                                object.recoverable_signature = [];
                                if (options.bytes !== Array)
                                    object.recoverable_signature = $util.newBuffer(object.recoverable_signature);
                            }
                        }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        if (message.recoverable_signature != null && message.hasOwnProperty("recoverable_signature"))
                            object.recoverable_signature = options.bytes === String ? $util.base64.encode(message.recoverable_signature, 0, message.recoverable_signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.recoverable_signature) : message.recoverable_signature;
                        return object;
                    };
    
                    /**
                     * Converts this pow_signature_data to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.pow.pow_signature_data
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    pow_signature_data.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return pow_signature_data;
                })();
    
                return pow;
            })();
    
            contracts.token = (function() {
    
                /**
                 * Namespace token.
                 * @memberof koinos.contracts
                 * @namespace
                 */
                var token = {};
    
                token.name_arguments = (function() {
    
                    /**
                     * Properties of a name_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Iname_arguments
                     */
    
                    /**
                     * Constructs a new name_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a name_arguments.
                     * @implements Iname_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Iname_arguments=} [properties] Properties to set
                     */
                    function name_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new name_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {koinos.contracts.token.Iname_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.name_arguments} name_arguments instance
                     */
                    name_arguments.create = function create(properties) {
                        return new name_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified name_arguments message. Does not implicitly {@link koinos.contracts.token.name_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {koinos.contracts.token.Iname_arguments} message name_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    name_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified name_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.name_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {koinos.contracts.token.Iname_arguments} message name_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    name_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a name_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.name_arguments} name_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    name_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.name_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a name_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.name_arguments} name_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    name_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a name_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    name_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a name_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.name_arguments} name_arguments
                     */
                    name_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.name_arguments)
                            return object;
                        return new $root.koinos.contracts.token.name_arguments();
                    };
    
                    /**
                     * Creates a plain object from a name_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.name_arguments
                     * @static
                     * @param {koinos.contracts.token.name_arguments} message name_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    name_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this name_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.name_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    name_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return name_arguments;
                })();
    
                token.name_result = (function() {
    
                    /**
                     * Properties of a name_result.
                     * @memberof koinos.contracts.token
                     * @interface Iname_result
                     * @property {string|null} [value] name_result value
                     */
    
                    /**
                     * Constructs a new name_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a name_result.
                     * @implements Iname_result
                     * @constructor
                     * @param {koinos.contracts.token.Iname_result=} [properties] Properties to set
                     */
                    function name_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * name_result value.
                     * @member {string} value
                     * @memberof koinos.contracts.token.name_result
                     * @instance
                     */
                    name_result.prototype.value = "";
    
                    /**
                     * Creates a new name_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {koinos.contracts.token.Iname_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.name_result} name_result instance
                     */
                    name_result.create = function create(properties) {
                        return new name_result(properties);
                    };
    
                    /**
                     * Encodes the specified name_result message. Does not implicitly {@link koinos.contracts.token.name_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {koinos.contracts.token.Iname_result} message name_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    name_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified name_result message, length delimited. Does not implicitly {@link koinos.contracts.token.name_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {koinos.contracts.token.Iname_result} message name_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    name_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a name_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.name_result} name_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    name_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.name_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a name_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.name_result} name_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    name_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a name_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    name_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a name_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.name_result} name_result
                     */
                    name_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.name_result)
                            return object;
                        var message = new $root.koinos.contracts.token.name_result();
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a name_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.name_result
                     * @static
                     * @param {koinos.contracts.token.name_result} message name_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    name_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = "";
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        return object;
                    };
    
                    /**
                     * Converts this name_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.name_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    name_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return name_result;
                })();
    
                token.symbol_arguments = (function() {
    
                    /**
                     * Properties of a symbol_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Isymbol_arguments
                     */
    
                    /**
                     * Constructs a new symbol_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a symbol_arguments.
                     * @implements Isymbol_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Isymbol_arguments=} [properties] Properties to set
                     */
                    function symbol_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new symbol_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {koinos.contracts.token.Isymbol_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.symbol_arguments} symbol_arguments instance
                     */
                    symbol_arguments.create = function create(properties) {
                        return new symbol_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified symbol_arguments message. Does not implicitly {@link koinos.contracts.token.symbol_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {koinos.contracts.token.Isymbol_arguments} message symbol_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    symbol_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified symbol_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.symbol_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {koinos.contracts.token.Isymbol_arguments} message symbol_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    symbol_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a symbol_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.symbol_arguments} symbol_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    symbol_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.symbol_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a symbol_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.symbol_arguments} symbol_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    symbol_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a symbol_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    symbol_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a symbol_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.symbol_arguments} symbol_arguments
                     */
                    symbol_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.symbol_arguments)
                            return object;
                        return new $root.koinos.contracts.token.symbol_arguments();
                    };
    
                    /**
                     * Creates a plain object from a symbol_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @static
                     * @param {koinos.contracts.token.symbol_arguments} message symbol_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    symbol_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this symbol_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.symbol_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    symbol_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return symbol_arguments;
                })();
    
                token.symbol_result = (function() {
    
                    /**
                     * Properties of a symbol_result.
                     * @memberof koinos.contracts.token
                     * @interface Isymbol_result
                     * @property {string|null} [value] symbol_result value
                     */
    
                    /**
                     * Constructs a new symbol_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a symbol_result.
                     * @implements Isymbol_result
                     * @constructor
                     * @param {koinos.contracts.token.Isymbol_result=} [properties] Properties to set
                     */
                    function symbol_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * symbol_result value.
                     * @member {string} value
                     * @memberof koinos.contracts.token.symbol_result
                     * @instance
                     */
                    symbol_result.prototype.value = "";
    
                    /**
                     * Creates a new symbol_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {koinos.contracts.token.Isymbol_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.symbol_result} symbol_result instance
                     */
                    symbol_result.create = function create(properties) {
                        return new symbol_result(properties);
                    };
    
                    /**
                     * Encodes the specified symbol_result message. Does not implicitly {@link koinos.contracts.token.symbol_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {koinos.contracts.token.Isymbol_result} message symbol_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    symbol_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified symbol_result message, length delimited. Does not implicitly {@link koinos.contracts.token.symbol_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {koinos.contracts.token.Isymbol_result} message symbol_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    symbol_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a symbol_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.symbol_result} symbol_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    symbol_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.symbol_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a symbol_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.symbol_result} symbol_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    symbol_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a symbol_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    symbol_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        return null;
                    };
    
                    /**
                     * Creates a symbol_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.symbol_result} symbol_result
                     */
                    symbol_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.symbol_result)
                            return object;
                        var message = new $root.koinos.contracts.token.symbol_result();
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a symbol_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.symbol_result
                     * @static
                     * @param {koinos.contracts.token.symbol_result} message symbol_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    symbol_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = "";
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        return object;
                    };
    
                    /**
                     * Converts this symbol_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.symbol_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    symbol_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return symbol_result;
                })();
    
                token.decimals_arguments = (function() {
    
                    /**
                     * Properties of a decimals_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Idecimals_arguments
                     */
    
                    /**
                     * Constructs a new decimals_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a decimals_arguments.
                     * @implements Idecimals_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Idecimals_arguments=} [properties] Properties to set
                     */
                    function decimals_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new decimals_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {koinos.contracts.token.Idecimals_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.decimals_arguments} decimals_arguments instance
                     */
                    decimals_arguments.create = function create(properties) {
                        return new decimals_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified decimals_arguments message. Does not implicitly {@link koinos.contracts.token.decimals_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {koinos.contracts.token.Idecimals_arguments} message decimals_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    decimals_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified decimals_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.decimals_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {koinos.contracts.token.Idecimals_arguments} message decimals_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    decimals_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a decimals_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.decimals_arguments} decimals_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    decimals_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.decimals_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a decimals_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.decimals_arguments} decimals_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    decimals_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a decimals_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    decimals_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a decimals_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.decimals_arguments} decimals_arguments
                     */
                    decimals_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.decimals_arguments)
                            return object;
                        return new $root.koinos.contracts.token.decimals_arguments();
                    };
    
                    /**
                     * Creates a plain object from a decimals_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @static
                     * @param {koinos.contracts.token.decimals_arguments} message decimals_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    decimals_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this decimals_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.decimals_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    decimals_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return decimals_arguments;
                })();
    
                token.decimals_result = (function() {
    
                    /**
                     * Properties of a decimals_result.
                     * @memberof koinos.contracts.token
                     * @interface Idecimals_result
                     * @property {number|null} [value] decimals_result value
                     */
    
                    /**
                     * Constructs a new decimals_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a decimals_result.
                     * @implements Idecimals_result
                     * @constructor
                     * @param {koinos.contracts.token.Idecimals_result=} [properties] Properties to set
                     */
                    function decimals_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * decimals_result value.
                     * @member {number} value
                     * @memberof koinos.contracts.token.decimals_result
                     * @instance
                     */
                    decimals_result.prototype.value = 0;
    
                    /**
                     * Creates a new decimals_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {koinos.contracts.token.Idecimals_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.decimals_result} decimals_result instance
                     */
                    decimals_result.create = function create(properties) {
                        return new decimals_result(properties);
                    };
    
                    /**
                     * Encodes the specified decimals_result message. Does not implicitly {@link koinos.contracts.token.decimals_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {koinos.contracts.token.Idecimals_result} message decimals_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    decimals_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified decimals_result message, length delimited. Does not implicitly {@link koinos.contracts.token.decimals_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {koinos.contracts.token.Idecimals_result} message decimals_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    decimals_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a decimals_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.decimals_result} decimals_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    decimals_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.decimals_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.uint32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a decimals_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.decimals_result} decimals_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    decimals_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a decimals_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    decimals_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value))
                                return "value: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a decimals_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.decimals_result} decimals_result
                     */
                    decimals_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.decimals_result)
                            return object;
                        var message = new $root.koinos.contracts.token.decimals_result();
                        if (object.value != null)
                            message.value = object.value >>> 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a decimals_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.decimals_result
                     * @static
                     * @param {koinos.contracts.token.decimals_result} message decimals_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    decimals_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = 0;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        return object;
                    };
    
                    /**
                     * Converts this decimals_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.decimals_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    decimals_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return decimals_result;
                })();
    
                token.total_supply_arguments = (function() {
    
                    /**
                     * Properties of a total_supply_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Itotal_supply_arguments
                     */
    
                    /**
                     * Constructs a new total_supply_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a total_supply_arguments.
                     * @implements Itotal_supply_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Itotal_supply_arguments=} [properties] Properties to set
                     */
                    function total_supply_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new total_supply_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {koinos.contracts.token.Itotal_supply_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.total_supply_arguments} total_supply_arguments instance
                     */
                    total_supply_arguments.create = function create(properties) {
                        return new total_supply_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified total_supply_arguments message. Does not implicitly {@link koinos.contracts.token.total_supply_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {koinos.contracts.token.Itotal_supply_arguments} message total_supply_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    total_supply_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified total_supply_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.total_supply_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {koinos.contracts.token.Itotal_supply_arguments} message total_supply_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    total_supply_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a total_supply_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.total_supply_arguments} total_supply_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    total_supply_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.total_supply_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a total_supply_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.total_supply_arguments} total_supply_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    total_supply_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a total_supply_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    total_supply_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a total_supply_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.total_supply_arguments} total_supply_arguments
                     */
                    total_supply_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.total_supply_arguments)
                            return object;
                        return new $root.koinos.contracts.token.total_supply_arguments();
                    };
    
                    /**
                     * Creates a plain object from a total_supply_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @static
                     * @param {koinos.contracts.token.total_supply_arguments} message total_supply_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    total_supply_arguments.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this total_supply_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.total_supply_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    total_supply_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return total_supply_arguments;
                })();
    
                token.total_supply_result = (function() {
    
                    /**
                     * Properties of a total_supply_result.
                     * @memberof koinos.contracts.token
                     * @interface Itotal_supply_result
                     * @property {number|Long|null} [value] total_supply_result value
                     */
    
                    /**
                     * Constructs a new total_supply_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a total_supply_result.
                     * @implements Itotal_supply_result
                     * @constructor
                     * @param {koinos.contracts.token.Itotal_supply_result=} [properties] Properties to set
                     */
                    function total_supply_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * total_supply_result value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.total_supply_result
                     * @instance
                     */
                    total_supply_result.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new total_supply_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {koinos.contracts.token.Itotal_supply_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.total_supply_result} total_supply_result instance
                     */
                    total_supply_result.create = function create(properties) {
                        return new total_supply_result(properties);
                    };
    
                    /**
                     * Encodes the specified total_supply_result message. Does not implicitly {@link koinos.contracts.token.total_supply_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {koinos.contracts.token.Itotal_supply_result} message total_supply_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    total_supply_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified total_supply_result message, length delimited. Does not implicitly {@link koinos.contracts.token.total_supply_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {koinos.contracts.token.Itotal_supply_result} message total_supply_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    total_supply_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a total_supply_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.total_supply_result} total_supply_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    total_supply_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.total_supply_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a total_supply_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.total_supply_result} total_supply_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    total_supply_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a total_supply_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    total_supply_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a total_supply_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.total_supply_result} total_supply_result
                     */
                    total_supply_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.total_supply_result)
                            return object;
                        var message = new $root.koinos.contracts.token.total_supply_result();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a total_supply_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.total_supply_result
                     * @static
                     * @param {koinos.contracts.token.total_supply_result} message total_supply_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    total_supply_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this total_supply_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.total_supply_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    total_supply_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return total_supply_result;
                })();
    
                token.balance_of_arguments = (function() {
    
                    /**
                     * Properties of a balance_of_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Ibalance_of_arguments
                     * @property {Uint8Array|null} [owner] balance_of_arguments owner
                     */
    
                    /**
                     * Constructs a new balance_of_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a balance_of_arguments.
                     * @implements Ibalance_of_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Ibalance_of_arguments=} [properties] Properties to set
                     */
                    function balance_of_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * balance_of_arguments owner.
                     * @member {Uint8Array} owner
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @instance
                     */
                    balance_of_arguments.prototype.owner = $util.newBuffer([]);
    
                    /**
                     * Creates a new balance_of_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {koinos.contracts.token.Ibalance_of_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.balance_of_arguments} balance_of_arguments instance
                     */
                    balance_of_arguments.create = function create(properties) {
                        return new balance_of_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified balance_of_arguments message. Does not implicitly {@link koinos.contracts.token.balance_of_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {koinos.contracts.token.Ibalance_of_arguments} message balance_of_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    balance_of_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified balance_of_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.balance_of_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {koinos.contracts.token.Ibalance_of_arguments} message balance_of_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    balance_of_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a balance_of_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.balance_of_arguments} balance_of_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    balance_of_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.balance_of_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.owner = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a balance_of_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.balance_of_arguments} balance_of_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    balance_of_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a balance_of_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    balance_of_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.owner != null && message.hasOwnProperty("owner"))
                            if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                                return "owner: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a balance_of_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.balance_of_arguments} balance_of_arguments
                     */
                    balance_of_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.balance_of_arguments)
                            return object;
                        var message = new $root.koinos.contracts.token.balance_of_arguments();
                        if (object.owner != null)
                            if (typeof object.owner === "string")
                                $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                            else if (object.owner.length)
                                message.owner = object.owner;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a balance_of_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @static
                     * @param {koinos.contracts.token.balance_of_arguments} message balance_of_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    balance_of_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.owner = "";
                            else {
                                object.owner = [];
                                if (options.bytes !== Array)
                                    object.owner = $util.newBuffer(object.owner);
                            }
                        if (message.owner != null && message.hasOwnProperty("owner"))
                            object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                        return object;
                    };
    
                    /**
                     * Converts this balance_of_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.balance_of_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    balance_of_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return balance_of_arguments;
                })();
    
                token.balance_of_result = (function() {
    
                    /**
                     * Properties of a balance_of_result.
                     * @memberof koinos.contracts.token
                     * @interface Ibalance_of_result
                     * @property {number|Long|null} [value] balance_of_result value
                     */
    
                    /**
                     * Constructs a new balance_of_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a balance_of_result.
                     * @implements Ibalance_of_result
                     * @constructor
                     * @param {koinos.contracts.token.Ibalance_of_result=} [properties] Properties to set
                     */
                    function balance_of_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * balance_of_result value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.balance_of_result
                     * @instance
                     */
                    balance_of_result.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new balance_of_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {koinos.contracts.token.Ibalance_of_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.balance_of_result} balance_of_result instance
                     */
                    balance_of_result.create = function create(properties) {
                        return new balance_of_result(properties);
                    };
    
                    /**
                     * Encodes the specified balance_of_result message. Does not implicitly {@link koinos.contracts.token.balance_of_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {koinos.contracts.token.Ibalance_of_result} message balance_of_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    balance_of_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified balance_of_result message, length delimited. Does not implicitly {@link koinos.contracts.token.balance_of_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {koinos.contracts.token.Ibalance_of_result} message balance_of_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    balance_of_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a balance_of_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.balance_of_result} balance_of_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    balance_of_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.balance_of_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a balance_of_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.balance_of_result} balance_of_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    balance_of_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a balance_of_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    balance_of_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a balance_of_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.balance_of_result} balance_of_result
                     */
                    balance_of_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.balance_of_result)
                            return object;
                        var message = new $root.koinos.contracts.token.balance_of_result();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a balance_of_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.balance_of_result
                     * @static
                     * @param {koinos.contracts.token.balance_of_result} message balance_of_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    balance_of_result.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this balance_of_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.balance_of_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    balance_of_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return balance_of_result;
                })();
    
                token.transfer_arguments = (function() {
    
                    /**
                     * Properties of a transfer_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Itransfer_arguments
                     * @property {Uint8Array|null} [from] transfer_arguments from
                     * @property {Uint8Array|null} [to] transfer_arguments to
                     * @property {number|Long|null} [value] transfer_arguments value
                     */
    
                    /**
                     * Constructs a new transfer_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a transfer_arguments.
                     * @implements Itransfer_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Itransfer_arguments=} [properties] Properties to set
                     */
                    function transfer_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * transfer_arguments from.
                     * @member {Uint8Array} from
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @instance
                     */
                    transfer_arguments.prototype.from = $util.newBuffer([]);
    
                    /**
                     * transfer_arguments to.
                     * @member {Uint8Array} to
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @instance
                     */
                    transfer_arguments.prototype.to = $util.newBuffer([]);
    
                    /**
                     * transfer_arguments value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @instance
                     */
                    transfer_arguments.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new transfer_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {koinos.contracts.token.Itransfer_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.transfer_arguments} transfer_arguments instance
                     */
                    transfer_arguments.create = function create(properties) {
                        return new transfer_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified transfer_arguments message. Does not implicitly {@link koinos.contracts.token.transfer_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {koinos.contracts.token.Itransfer_arguments} message transfer_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transfer_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified transfer_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.transfer_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {koinos.contracts.token.Itransfer_arguments} message transfer_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transfer_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a transfer_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.transfer_arguments} transfer_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transfer_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.transfer_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.to = reader.bytes();
                                break;
                            case 3:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a transfer_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.transfer_arguments} transfer_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transfer_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a transfer_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    transfer_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a transfer_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.transfer_arguments} transfer_arguments
                     */
                    transfer_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.transfer_arguments)
                            return object;
                        var message = new $root.koinos.contracts.token.transfer_arguments();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a transfer_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @static
                     * @param {koinos.contracts.token.transfer_arguments} message transfer_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    transfer_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this transfer_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.transfer_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    transfer_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return transfer_arguments;
                })();
    
                token.transfer_result = (function() {
    
                    /**
                     * Properties of a transfer_result.
                     * @memberof koinos.contracts.token
                     * @interface Itransfer_result
                     */
    
                    /**
                     * Constructs a new transfer_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a transfer_result.
                     * @implements Itransfer_result
                     * @constructor
                     * @param {koinos.contracts.token.Itransfer_result=} [properties] Properties to set
                     */
                    function transfer_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new transfer_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {koinos.contracts.token.Itransfer_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.transfer_result} transfer_result instance
                     */
                    transfer_result.create = function create(properties) {
                        return new transfer_result(properties);
                    };
    
                    /**
                     * Encodes the specified transfer_result message. Does not implicitly {@link koinos.contracts.token.transfer_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {koinos.contracts.token.Itransfer_result} message transfer_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transfer_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified transfer_result message, length delimited. Does not implicitly {@link koinos.contracts.token.transfer_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {koinos.contracts.token.Itransfer_result} message transfer_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transfer_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a transfer_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.transfer_result} transfer_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transfer_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.transfer_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a transfer_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.transfer_result} transfer_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transfer_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a transfer_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    transfer_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a transfer_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.transfer_result} transfer_result
                     */
                    transfer_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.transfer_result)
                            return object;
                        return new $root.koinos.contracts.token.transfer_result();
                    };
    
                    /**
                     * Creates a plain object from a transfer_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.transfer_result
                     * @static
                     * @param {koinos.contracts.token.transfer_result} message transfer_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    transfer_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this transfer_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.transfer_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    transfer_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return transfer_result;
                })();
    
                token.mint_arguments = (function() {
    
                    /**
                     * Properties of a mint_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Imint_arguments
                     * @property {Uint8Array|null} [to] mint_arguments to
                     * @property {number|Long|null} [value] mint_arguments value
                     */
    
                    /**
                     * Constructs a new mint_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a mint_arguments.
                     * @implements Imint_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Imint_arguments=} [properties] Properties to set
                     */
                    function mint_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * mint_arguments to.
                     * @member {Uint8Array} to
                     * @memberof koinos.contracts.token.mint_arguments
                     * @instance
                     */
                    mint_arguments.prototype.to = $util.newBuffer([]);
    
                    /**
                     * mint_arguments value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.mint_arguments
                     * @instance
                     */
                    mint_arguments.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new mint_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {koinos.contracts.token.Imint_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.mint_arguments} mint_arguments instance
                     */
                    mint_arguments.create = function create(properties) {
                        return new mint_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified mint_arguments message. Does not implicitly {@link koinos.contracts.token.mint_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {koinos.contracts.token.Imint_arguments} message mint_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mint_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.to);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified mint_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.mint_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {koinos.contracts.token.Imint_arguments} message mint_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mint_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a mint_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.mint_arguments} mint_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mint_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.mint_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.to = reader.bytes();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a mint_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.mint_arguments} mint_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mint_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a mint_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    mint_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a mint_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.mint_arguments} mint_arguments
                     */
                    mint_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.mint_arguments)
                            return object;
                        var message = new $root.koinos.contracts.token.mint_arguments();
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a mint_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.mint_arguments
                     * @static
                     * @param {koinos.contracts.token.mint_arguments} message mint_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    mint_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this mint_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.mint_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    mint_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return mint_arguments;
                })();
    
                token.mint_result = (function() {
    
                    /**
                     * Properties of a mint_result.
                     * @memberof koinos.contracts.token
                     * @interface Imint_result
                     */
    
                    /**
                     * Constructs a new mint_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a mint_result.
                     * @implements Imint_result
                     * @constructor
                     * @param {koinos.contracts.token.Imint_result=} [properties] Properties to set
                     */
                    function mint_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new mint_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {koinos.contracts.token.Imint_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.mint_result} mint_result instance
                     */
                    mint_result.create = function create(properties) {
                        return new mint_result(properties);
                    };
    
                    /**
                     * Encodes the specified mint_result message. Does not implicitly {@link koinos.contracts.token.mint_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {koinos.contracts.token.Imint_result} message mint_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mint_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified mint_result message, length delimited. Does not implicitly {@link koinos.contracts.token.mint_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {koinos.contracts.token.Imint_result} message mint_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mint_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a mint_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.mint_result} mint_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mint_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.mint_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a mint_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.mint_result} mint_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mint_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a mint_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    mint_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a mint_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.mint_result} mint_result
                     */
                    mint_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.mint_result)
                            return object;
                        return new $root.koinos.contracts.token.mint_result();
                    };
    
                    /**
                     * Creates a plain object from a mint_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.mint_result
                     * @static
                     * @param {koinos.contracts.token.mint_result} message mint_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    mint_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this mint_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.mint_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    mint_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return mint_result;
                })();
    
                token.burn_arguments = (function() {
    
                    /**
                     * Properties of a burn_arguments.
                     * @memberof koinos.contracts.token
                     * @interface Iburn_arguments
                     * @property {Uint8Array|null} [from] burn_arguments from
                     * @property {number|Long|null} [value] burn_arguments value
                     */
    
                    /**
                     * Constructs a new burn_arguments.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a burn_arguments.
                     * @implements Iburn_arguments
                     * @constructor
                     * @param {koinos.contracts.token.Iburn_arguments=} [properties] Properties to set
                     */
                    function burn_arguments(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * burn_arguments from.
                     * @member {Uint8Array} from
                     * @memberof koinos.contracts.token.burn_arguments
                     * @instance
                     */
                    burn_arguments.prototype.from = $util.newBuffer([]);
    
                    /**
                     * burn_arguments value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.burn_arguments
                     * @instance
                     */
                    burn_arguments.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new burn_arguments instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {koinos.contracts.token.Iburn_arguments=} [properties] Properties to set
                     * @returns {koinos.contracts.token.burn_arguments} burn_arguments instance
                     */
                    burn_arguments.create = function create(properties) {
                        return new burn_arguments(properties);
                    };
    
                    /**
                     * Encodes the specified burn_arguments message. Does not implicitly {@link koinos.contracts.token.burn_arguments.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {koinos.contracts.token.Iburn_arguments} message burn_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_arguments.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified burn_arguments message, length delimited. Does not implicitly {@link koinos.contracts.token.burn_arguments.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {koinos.contracts.token.Iburn_arguments} message burn_arguments message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a burn_arguments message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.burn_arguments} burn_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_arguments.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.burn_arguments();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a burn_arguments message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.burn_arguments} burn_arguments
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_arguments.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a burn_arguments message.
                     * @function verify
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    burn_arguments.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a burn_arguments message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.burn_arguments} burn_arguments
                     */
                    burn_arguments.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.burn_arguments)
                            return object;
                        var message = new $root.koinos.contracts.token.burn_arguments();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a burn_arguments message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.burn_arguments
                     * @static
                     * @param {koinos.contracts.token.burn_arguments} message burn_arguments
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    burn_arguments.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this burn_arguments to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.burn_arguments
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    burn_arguments.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return burn_arguments;
                })();
    
                token.burn_result = (function() {
    
                    /**
                     * Properties of a burn_result.
                     * @memberof koinos.contracts.token
                     * @interface Iburn_result
                     */
    
                    /**
                     * Constructs a new burn_result.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a burn_result.
                     * @implements Iburn_result
                     * @constructor
                     * @param {koinos.contracts.token.Iburn_result=} [properties] Properties to set
                     */
                    function burn_result(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new burn_result instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {koinos.contracts.token.Iburn_result=} [properties] Properties to set
                     * @returns {koinos.contracts.token.burn_result} burn_result instance
                     */
                    burn_result.create = function create(properties) {
                        return new burn_result(properties);
                    };
    
                    /**
                     * Encodes the specified burn_result message. Does not implicitly {@link koinos.contracts.token.burn_result.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {koinos.contracts.token.Iburn_result} message burn_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_result.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified burn_result message, length delimited. Does not implicitly {@link koinos.contracts.token.burn_result.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {koinos.contracts.token.Iburn_result} message burn_result message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_result.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a burn_result message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.burn_result} burn_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_result.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.burn_result();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a burn_result message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.burn_result} burn_result
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_result.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a burn_result message.
                     * @function verify
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    burn_result.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a burn_result message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.burn_result} burn_result
                     */
                    burn_result.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.burn_result)
                            return object;
                        return new $root.koinos.contracts.token.burn_result();
                    };
    
                    /**
                     * Creates a plain object from a burn_result message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.burn_result
                     * @static
                     * @param {koinos.contracts.token.burn_result} message burn_result
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    burn_result.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this burn_result to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.burn_result
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    burn_result.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return burn_result;
                })();
    
                token.balance_object = (function() {
    
                    /**
                     * Properties of a balance_object.
                     * @memberof koinos.contracts.token
                     * @interface Ibalance_object
                     * @property {number|Long|null} [value] balance_object value
                     */
    
                    /**
                     * Constructs a new balance_object.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a balance_object.
                     * @implements Ibalance_object
                     * @constructor
                     * @param {koinos.contracts.token.Ibalance_object=} [properties] Properties to set
                     */
                    function balance_object(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * balance_object value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.balance_object
                     * @instance
                     */
                    balance_object.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new balance_object instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {koinos.contracts.token.Ibalance_object=} [properties] Properties to set
                     * @returns {koinos.contracts.token.balance_object} balance_object instance
                     */
                    balance_object.create = function create(properties) {
                        return new balance_object(properties);
                    };
    
                    /**
                     * Encodes the specified balance_object message. Does not implicitly {@link koinos.contracts.token.balance_object.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {koinos.contracts.token.Ibalance_object} message balance_object message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    balance_object.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified balance_object message, length delimited. Does not implicitly {@link koinos.contracts.token.balance_object.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {koinos.contracts.token.Ibalance_object} message balance_object message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    balance_object.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a balance_object message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.balance_object} balance_object
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    balance_object.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.balance_object();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a balance_object message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.balance_object} balance_object
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    balance_object.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a balance_object message.
                     * @function verify
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    balance_object.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a balance_object message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.balance_object} balance_object
                     */
                    balance_object.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.balance_object)
                            return object;
                        var message = new $root.koinos.contracts.token.balance_object();
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a balance_object message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.balance_object
                     * @static
                     * @param {koinos.contracts.token.balance_object} message balance_object
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    balance_object.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this balance_object to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.balance_object
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    balance_object.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return balance_object;
                })();
    
                token.mana_balance_object = (function() {
    
                    /**
                     * Properties of a mana_balance_object.
                     * @memberof koinos.contracts.token
                     * @interface Imana_balance_object
                     * @property {number|Long|null} [balance] mana_balance_object balance
                     * @property {number|Long|null} [mana] mana_balance_object mana
                     * @property {number|Long|null} [last_mana_update] mana_balance_object last_mana_update
                     */
    
                    /**
                     * Constructs a new mana_balance_object.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a mana_balance_object.
                     * @implements Imana_balance_object
                     * @constructor
                     * @param {koinos.contracts.token.Imana_balance_object=} [properties] Properties to set
                     */
                    function mana_balance_object(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * mana_balance_object balance.
                     * @member {number|Long} balance
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @instance
                     */
                    mana_balance_object.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * mana_balance_object mana.
                     * @member {number|Long} mana
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @instance
                     */
                    mana_balance_object.prototype.mana = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * mana_balance_object last_mana_update.
                     * @member {number|Long} last_mana_update
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @instance
                     */
                    mana_balance_object.prototype.last_mana_update = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new mana_balance_object instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {koinos.contracts.token.Imana_balance_object=} [properties] Properties to set
                     * @returns {koinos.contracts.token.mana_balance_object} mana_balance_object instance
                     */
                    mana_balance_object.create = function create(properties) {
                        return new mana_balance_object(properties);
                    };
    
                    /**
                     * Encodes the specified mana_balance_object message. Does not implicitly {@link koinos.contracts.token.mana_balance_object.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {koinos.contracts.token.Imana_balance_object} message mana_balance_object message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mana_balance_object.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.balance);
                        if (message.mana != null && Object.hasOwnProperty.call(message, "mana"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.mana);
                        if (message.last_mana_update != null && Object.hasOwnProperty.call(message, "last_mana_update"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.last_mana_update);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified mana_balance_object message, length delimited. Does not implicitly {@link koinos.contracts.token.mana_balance_object.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {koinos.contracts.token.Imana_balance_object} message mana_balance_object message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mana_balance_object.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a mana_balance_object message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.mana_balance_object} mana_balance_object
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mana_balance_object.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.mana_balance_object();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.balance = reader.uint64();
                                break;
                            case 2:
                                message.mana = reader.uint64();
                                break;
                            case 3:
                                message.last_mana_update = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a mana_balance_object message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.mana_balance_object} mana_balance_object
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mana_balance_object.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a mana_balance_object message.
                     * @function verify
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    mana_balance_object.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                                return "balance: integer|Long expected";
                        if (message.mana != null && message.hasOwnProperty("mana"))
                            if (!$util.isInteger(message.mana) && !(message.mana && $util.isInteger(message.mana.low) && $util.isInteger(message.mana.high)))
                                return "mana: integer|Long expected";
                        if (message.last_mana_update != null && message.hasOwnProperty("last_mana_update"))
                            if (!$util.isInteger(message.last_mana_update) && !(message.last_mana_update && $util.isInteger(message.last_mana_update.low) && $util.isInteger(message.last_mana_update.high)))
                                return "last_mana_update: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a mana_balance_object message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.mana_balance_object} mana_balance_object
                     */
                    mana_balance_object.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.mana_balance_object)
                            return object;
                        var message = new $root.koinos.contracts.token.mana_balance_object();
                        if (object.balance != null)
                            if ($util.Long)
                                (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
                            else if (typeof object.balance === "string")
                                message.balance = parseInt(object.balance, 10);
                            else if (typeof object.balance === "number")
                                message.balance = object.balance;
                            else if (typeof object.balance === "object")
                                message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
                        if (object.mana != null)
                            if ($util.Long)
                                (message.mana = $util.Long.fromValue(object.mana)).unsigned = true;
                            else if (typeof object.mana === "string")
                                message.mana = parseInt(object.mana, 10);
                            else if (typeof object.mana === "number")
                                message.mana = object.mana;
                            else if (typeof object.mana === "object")
                                message.mana = new $util.LongBits(object.mana.low >>> 0, object.mana.high >>> 0).toNumber(true);
                        if (object.last_mana_update != null)
                            if ($util.Long)
                                (message.last_mana_update = $util.Long.fromValue(object.last_mana_update)).unsigned = true;
                            else if (typeof object.last_mana_update === "string")
                                message.last_mana_update = parseInt(object.last_mana_update, 10);
                            else if (typeof object.last_mana_update === "number")
                                message.last_mana_update = object.last_mana_update;
                            else if (typeof object.last_mana_update === "object")
                                message.last_mana_update = new $util.LongBits(object.last_mana_update.low >>> 0, object.last_mana_update.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a mana_balance_object message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @static
                     * @param {koinos.contracts.token.mana_balance_object} message mana_balance_object
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    mana_balance_object.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.balance = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.mana = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.mana = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.last_mana_update = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.last_mana_update = options.longs === String ? "0" : 0;
                        }
                        if (message.balance != null && message.hasOwnProperty("balance"))
                            if (typeof message.balance === "number")
                                object.balance = options.longs === String ? String(message.balance) : message.balance;
                            else
                                object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
                        if (message.mana != null && message.hasOwnProperty("mana"))
                            if (typeof message.mana === "number")
                                object.mana = options.longs === String ? String(message.mana) : message.mana;
                            else
                                object.mana = options.longs === String ? $util.Long.prototype.toString.call(message.mana) : options.longs === Number ? new $util.LongBits(message.mana.low >>> 0, message.mana.high >>> 0).toNumber(true) : message.mana;
                        if (message.last_mana_update != null && message.hasOwnProperty("last_mana_update"))
                            if (typeof message.last_mana_update === "number")
                                object.last_mana_update = options.longs === String ? String(message.last_mana_update) : message.last_mana_update;
                            else
                                object.last_mana_update = options.longs === String ? $util.Long.prototype.toString.call(message.last_mana_update) : options.longs === Number ? new $util.LongBits(message.last_mana_update.low >>> 0, message.last_mana_update.high >>> 0).toNumber(true) : message.last_mana_update;
                        return object;
                    };
    
                    /**
                     * Converts this mana_balance_object to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.mana_balance_object
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    mana_balance_object.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return mana_balance_object;
                })();
    
                token.burn_event = (function() {
    
                    /**
                     * Properties of a burn_event.
                     * @memberof koinos.contracts.token
                     * @interface Iburn_event
                     * @property {Uint8Array|null} [from] burn_event from
                     * @property {number|Long|null} [value] burn_event value
                     */
    
                    /**
                     * Constructs a new burn_event.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a burn_event.
                     * @implements Iburn_event
                     * @constructor
                     * @param {koinos.contracts.token.Iburn_event=} [properties] Properties to set
                     */
                    function burn_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * burn_event from.
                     * @member {Uint8Array} from
                     * @memberof koinos.contracts.token.burn_event
                     * @instance
                     */
                    burn_event.prototype.from = $util.newBuffer([]);
    
                    /**
                     * burn_event value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.burn_event
                     * @instance
                     */
                    burn_event.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new burn_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {koinos.contracts.token.Iburn_event=} [properties] Properties to set
                     * @returns {koinos.contracts.token.burn_event} burn_event instance
                     */
                    burn_event.create = function create(properties) {
                        return new burn_event(properties);
                    };
    
                    /**
                     * Encodes the specified burn_event message. Does not implicitly {@link koinos.contracts.token.burn_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {koinos.contracts.token.Iburn_event} message burn_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified burn_event message, length delimited. Does not implicitly {@link koinos.contracts.token.burn_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {koinos.contracts.token.Iburn_event} message burn_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    burn_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a burn_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.burn_event} burn_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.burn_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a burn_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.burn_event} burn_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    burn_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a burn_event message.
                     * @function verify
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    burn_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a burn_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.burn_event} burn_event
                     */
                    burn_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.burn_event)
                            return object;
                        var message = new $root.koinos.contracts.token.burn_event();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a burn_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.burn_event
                     * @static
                     * @param {koinos.contracts.token.burn_event} message burn_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    burn_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this burn_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.burn_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    burn_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return burn_event;
                })();
    
                token.mint_event = (function() {
    
                    /**
                     * Properties of a mint_event.
                     * @memberof koinos.contracts.token
                     * @interface Imint_event
                     * @property {Uint8Array|null} [to] mint_event to
                     * @property {number|Long|null} [value] mint_event value
                     */
    
                    /**
                     * Constructs a new mint_event.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a mint_event.
                     * @implements Imint_event
                     * @constructor
                     * @param {koinos.contracts.token.Imint_event=} [properties] Properties to set
                     */
                    function mint_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * mint_event to.
                     * @member {Uint8Array} to
                     * @memberof koinos.contracts.token.mint_event
                     * @instance
                     */
                    mint_event.prototype.to = $util.newBuffer([]);
    
                    /**
                     * mint_event value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.mint_event
                     * @instance
                     */
                    mint_event.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new mint_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {koinos.contracts.token.Imint_event=} [properties] Properties to set
                     * @returns {koinos.contracts.token.mint_event} mint_event instance
                     */
                    mint_event.create = function create(properties) {
                        return new mint_event(properties);
                    };
    
                    /**
                     * Encodes the specified mint_event message. Does not implicitly {@link koinos.contracts.token.mint_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {koinos.contracts.token.Imint_event} message mint_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mint_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.to);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified mint_event message, length delimited. Does not implicitly {@link koinos.contracts.token.mint_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {koinos.contracts.token.Imint_event} message mint_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mint_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a mint_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.mint_event} mint_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mint_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.mint_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.to = reader.bytes();
                                break;
                            case 2:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a mint_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.mint_event} mint_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mint_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a mint_event message.
                     * @function verify
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    mint_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a mint_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.mint_event} mint_event
                     */
                    mint_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.mint_event)
                            return object;
                        var message = new $root.koinos.contracts.token.mint_event();
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a mint_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.mint_event
                     * @static
                     * @param {koinos.contracts.token.mint_event} message mint_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    mint_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this mint_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.mint_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    mint_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return mint_event;
                })();
    
                token.transfer_event = (function() {
    
                    /**
                     * Properties of a transfer_event.
                     * @memberof koinos.contracts.token
                     * @interface Itransfer_event
                     * @property {Uint8Array|null} [from] transfer_event from
                     * @property {Uint8Array|null} [to] transfer_event to
                     * @property {number|Long|null} [value] transfer_event value
                     */
    
                    /**
                     * Constructs a new transfer_event.
                     * @memberof koinos.contracts.token
                     * @classdesc Represents a transfer_event.
                     * @implements Itransfer_event
                     * @constructor
                     * @param {koinos.contracts.token.Itransfer_event=} [properties] Properties to set
                     */
                    function transfer_event(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * transfer_event from.
                     * @member {Uint8Array} from
                     * @memberof koinos.contracts.token.transfer_event
                     * @instance
                     */
                    transfer_event.prototype.from = $util.newBuffer([]);
    
                    /**
                     * transfer_event to.
                     * @member {Uint8Array} to
                     * @memberof koinos.contracts.token.transfer_event
                     * @instance
                     */
                    transfer_event.prototype.to = $util.newBuffer([]);
    
                    /**
                     * transfer_event value.
                     * @member {number|Long} value
                     * @memberof koinos.contracts.token.transfer_event
                     * @instance
                     */
                    transfer_event.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new transfer_event instance using the specified properties.
                     * @function create
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {koinos.contracts.token.Itransfer_event=} [properties] Properties to set
                     * @returns {koinos.contracts.token.transfer_event} transfer_event instance
                     */
                    transfer_event.create = function create(properties) {
                        return new transfer_event(properties);
                    };
    
                    /**
                     * Encodes the specified transfer_event message. Does not implicitly {@link koinos.contracts.token.transfer_event.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {koinos.contracts.token.Itransfer_event} message transfer_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transfer_event.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
                        if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified transfer_event message, length delimited. Does not implicitly {@link koinos.contracts.token.transfer_event.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {koinos.contracts.token.Itransfer_event} message transfer_event message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transfer_event.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a transfer_event message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.contracts.token.transfer_event} transfer_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transfer_event.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contracts.token.transfer_event();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.from = reader.bytes();
                                break;
                            case 2:
                                message.to = reader.bytes();
                                break;
                            case 3:
                                message.value = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a transfer_event message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.contracts.token.transfer_event} transfer_event
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transfer_event.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a transfer_event message.
                     * @function verify
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    transfer_event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.from != null && message.hasOwnProperty("from"))
                            if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                                return "from: buffer expected";
                        if (message.to != null && message.hasOwnProperty("to"))
                            if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                                return "to: buffer expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a transfer_event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.contracts.token.transfer_event} transfer_event
                     */
                    transfer_event.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.contracts.token.transfer_event)
                            return object;
                        var message = new $root.koinos.contracts.token.transfer_event();
                        if (object.from != null)
                            if (typeof object.from === "string")
                                $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                            else if (object.from.length)
                                message.from = object.from;
                        if (object.to != null)
                            if (typeof object.to === "string")
                                $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                            else if (object.to.length)
                                message.to = object.to;
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a transfer_event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.contracts.token.transfer_event
                     * @static
                     * @param {koinos.contracts.token.transfer_event} message transfer_event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    transfer_event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.from = "";
                            else {
                                object.from = [];
                                if (options.bytes !== Array)
                                    object.from = $util.newBuffer(object.from);
                            }
                            if (options.bytes === String)
                                object.to = "";
                            else {
                                object.to = [];
                                if (options.bytes !== Array)
                                    object.to = $util.newBuffer(object.to);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.from != null && message.hasOwnProperty("from"))
                            object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
                        if (message.to != null && message.hasOwnProperty("to"))
                            object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this transfer_event to JSON.
                     * @function toJSON
                     * @memberof koinos.contracts.token.transfer_event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    transfer_event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return transfer_event;
                })();
    
                return token;
            })();
    
            return contracts;
        })();
    
        koinos.block_topology = (function() {
    
            /**
             * Properties of a block_topology.
             * @memberof koinos
             * @interface Iblock_topology
             * @property {Uint8Array|null} [id] block_topology id
             * @property {number|Long|null} [height] block_topology height
             * @property {Uint8Array|null} [previous] block_topology previous
             */
    
            /**
             * Constructs a new block_topology.
             * @memberof koinos
             * @classdesc Represents a block_topology.
             * @implements Iblock_topology
             * @constructor
             * @param {koinos.Iblock_topology=} [properties] Properties to set
             */
            function block_topology(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * block_topology id.
             * @member {Uint8Array} id
             * @memberof koinos.block_topology
             * @instance
             */
            block_topology.prototype.id = $util.newBuffer([]);
    
            /**
             * block_topology height.
             * @member {number|Long} height
             * @memberof koinos.block_topology
             * @instance
             */
            block_topology.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
            /**
             * block_topology previous.
             * @member {Uint8Array} previous
             * @memberof koinos.block_topology
             * @instance
             */
            block_topology.prototype.previous = $util.newBuffer([]);
    
            /**
             * Creates a new block_topology instance using the specified properties.
             * @function create
             * @memberof koinos.block_topology
             * @static
             * @param {koinos.Iblock_topology=} [properties] Properties to set
             * @returns {koinos.block_topology} block_topology instance
             */
            block_topology.create = function create(properties) {
                return new block_topology(properties);
            };
    
            /**
             * Encodes the specified block_topology message. Does not implicitly {@link koinos.block_topology.verify|verify} messages.
             * @function encode
             * @memberof koinos.block_topology
             * @static
             * @param {koinos.Iblock_topology} message block_topology message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            block_topology.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.height);
                if (message.previous != null && Object.hasOwnProperty.call(message, "previous"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.previous);
                return writer;
            };
    
            /**
             * Encodes the specified block_topology message, length delimited. Does not implicitly {@link koinos.block_topology.verify|verify} messages.
             * @function encodeDelimited
             * @memberof koinos.block_topology
             * @static
             * @param {koinos.Iblock_topology} message block_topology message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            block_topology.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a block_topology message from the specified reader or buffer.
             * @function decode
             * @memberof koinos.block_topology
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {koinos.block_topology} block_topology
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            block_topology.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.block_topology();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    case 2:
                        message.height = reader.uint64();
                        break;
                    case 3:
                        message.previous = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a block_topology message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof koinos.block_topology
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {koinos.block_topology} block_topology
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            block_topology.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a block_topology message.
             * @function verify
             * @memberof koinos.block_topology
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            block_topology.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                if (message.height != null && message.hasOwnProperty("height"))
                    if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                        return "height: integer|Long expected";
                if (message.previous != null && message.hasOwnProperty("previous"))
                    if (!(message.previous && typeof message.previous.length === "number" || $util.isString(message.previous)))
                        return "previous: buffer expected";
                return null;
            };
    
            /**
             * Creates a block_topology message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof koinos.block_topology
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {koinos.block_topology} block_topology
             */
            block_topology.fromObject = function fromObject(object) {
                if (object instanceof $root.koinos.block_topology)
                    return object;
                var message = new $root.koinos.block_topology();
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                if (object.height != null)
                    if ($util.Long)
                        (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                    else if (typeof object.height === "string")
                        message.height = parseInt(object.height, 10);
                    else if (typeof object.height === "number")
                        message.height = object.height;
                    else if (typeof object.height === "object")
                        message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                if (object.previous != null)
                    if (typeof object.previous === "string")
                        $util.base64.decode(object.previous, message.previous = $util.newBuffer($util.base64.length(object.previous)), 0);
                    else if (object.previous.length)
                        message.previous = object.previous;
                return message;
            };
    
            /**
             * Creates a plain object from a block_topology message. Also converts values to other types if specified.
             * @function toObject
             * @memberof koinos.block_topology
             * @static
             * @param {koinos.block_topology} message block_topology
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            block_topology.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.height = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.previous = "";
                    else {
                        object.previous = [];
                        if (options.bytes !== Array)
                            object.previous = $util.newBuffer(object.previous);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                if (message.height != null && message.hasOwnProperty("height"))
                    if (typeof message.height === "number")
                        object.height = options.longs === String ? String(message.height) : message.height;
                    else
                        object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                if (message.previous != null && message.hasOwnProperty("previous"))
                    object.previous = options.bytes === String ? $util.base64.encode(message.previous, 0, message.previous.length) : options.bytes === Array ? Array.prototype.slice.call(message.previous) : message.previous;
                return object;
            };
    
            /**
             * Converts this block_topology to JSON.
             * @function toJSON
             * @memberof koinos.block_topology
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            block_topology.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return block_topology;
        })();
    
        koinos.contract_meta_store = (function() {
    
            /**
             * Namespace contract_meta_store.
             * @memberof koinos
             * @namespace
             */
            var contract_meta_store = {};
    
            contract_meta_store.contract_meta_item = (function() {
    
                /**
                 * Properties of a contract_meta_item.
                 * @memberof koinos.contract_meta_store
                 * @interface Icontract_meta_item
                 * @property {string|null} [abi] contract_meta_item abi
                 */
    
                /**
                 * Constructs a new contract_meta_item.
                 * @memberof koinos.contract_meta_store
                 * @classdesc Represents a contract_meta_item.
                 * @implements Icontract_meta_item
                 * @constructor
                 * @param {koinos.contract_meta_store.Icontract_meta_item=} [properties] Properties to set
                 */
                function contract_meta_item(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * contract_meta_item abi.
                 * @member {string} abi
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @instance
                 */
                contract_meta_item.prototype.abi = "";
    
                /**
                 * Creates a new contract_meta_item instance using the specified properties.
                 * @function create
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {koinos.contract_meta_store.Icontract_meta_item=} [properties] Properties to set
                 * @returns {koinos.contract_meta_store.contract_meta_item} contract_meta_item instance
                 */
                contract_meta_item.create = function create(properties) {
                    return new contract_meta_item(properties);
                };
    
                /**
                 * Encodes the specified contract_meta_item message. Does not implicitly {@link koinos.contract_meta_store.contract_meta_item.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {koinos.contract_meta_store.Icontract_meta_item} message contract_meta_item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                contract_meta_item.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.abi != null && Object.hasOwnProperty.call(message, "abi"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.abi);
                    return writer;
                };
    
                /**
                 * Encodes the specified contract_meta_item message, length delimited. Does not implicitly {@link koinos.contract_meta_store.contract_meta_item.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {koinos.contract_meta_store.Icontract_meta_item} message contract_meta_item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                contract_meta_item.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a contract_meta_item message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.contract_meta_store.contract_meta_item} contract_meta_item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                contract_meta_item.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.contract_meta_store.contract_meta_item();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.abi = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a contract_meta_item message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.contract_meta_store.contract_meta_item} contract_meta_item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                contract_meta_item.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a contract_meta_item message.
                 * @function verify
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                contract_meta_item.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.abi != null && message.hasOwnProperty("abi"))
                        if (!$util.isString(message.abi))
                            return "abi: string expected";
                    return null;
                };
    
                /**
                 * Creates a contract_meta_item message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.contract_meta_store.contract_meta_item} contract_meta_item
                 */
                contract_meta_item.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.contract_meta_store.contract_meta_item)
                        return object;
                    var message = new $root.koinos.contract_meta_store.contract_meta_item();
                    if (object.abi != null)
                        message.abi = String(object.abi);
                    return message;
                };
    
                /**
                 * Creates a plain object from a contract_meta_item message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @static
                 * @param {koinos.contract_meta_store.contract_meta_item} message contract_meta_item
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                contract_meta_item.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.abi = "";
                    if (message.abi != null && message.hasOwnProperty("abi"))
                        object.abi = message.abi;
                    return object;
                };
    
                /**
                 * Converts this contract_meta_item to JSON.
                 * @function toJSON
                 * @memberof koinos.contract_meta_store.contract_meta_item
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                contract_meta_item.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return contract_meta_item;
            })();
    
            return contract_meta_store;
        })();
    
        koinos.block_store = (function() {
    
            /**
             * Namespace block_store.
             * @memberof koinos
             * @namespace
             */
            var block_store = {};
    
            block_store.block_item = (function() {
    
                /**
                 * Properties of a block_item.
                 * @memberof koinos.block_store
                 * @interface Iblock_item
                 * @property {Uint8Array|null} [block_id] block_item block_id
                 * @property {number|Long|null} [block_height] block_item block_height
                 * @property {koinos.protocol.Iblock|null} [block] block_item block
                 * @property {koinos.protocol.Iblock_receipt|null} [receipt] block_item receipt
                 */
    
                /**
                 * Constructs a new block_item.
                 * @memberof koinos.block_store
                 * @classdesc Represents a block_item.
                 * @implements Iblock_item
                 * @constructor
                 * @param {koinos.block_store.Iblock_item=} [properties] Properties to set
                 */
                function block_item(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block_item block_id.
                 * @member {Uint8Array} block_id
                 * @memberof koinos.block_store.block_item
                 * @instance
                 */
                block_item.prototype.block_id = $util.newBuffer([]);
    
                /**
                 * block_item block_height.
                 * @member {number|Long} block_height
                 * @memberof koinos.block_store.block_item
                 * @instance
                 */
                block_item.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_item block.
                 * @member {koinos.protocol.Iblock|null|undefined} block
                 * @memberof koinos.block_store.block_item
                 * @instance
                 */
                block_item.prototype.block = null;
    
                /**
                 * block_item receipt.
                 * @member {koinos.protocol.Iblock_receipt|null|undefined} receipt
                 * @memberof koinos.block_store.block_item
                 * @instance
                 */
                block_item.prototype.receipt = null;
    
                /**
                 * Creates a new block_item instance using the specified properties.
                 * @function create
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {koinos.block_store.Iblock_item=} [properties] Properties to set
                 * @returns {koinos.block_store.block_item} block_item instance
                 */
                block_item.create = function create(properties) {
                    return new block_item(properties);
                };
    
                /**
                 * Encodes the specified block_item message. Does not implicitly {@link koinos.block_store.block_item.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {koinos.block_store.Iblock_item} message block_item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_item.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block_id != null && Object.hasOwnProperty.call(message, "block_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.block_id);
                    if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_height);
                    if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                        $root.koinos.protocol.block.encode(message.block, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                        $root.koinos.protocol.block_receipt.encode(message.receipt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified block_item message, length delimited. Does not implicitly {@link koinos.block_store.block_item.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {koinos.block_store.Iblock_item} message block_item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_item.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block_item message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.block_store.block_item} block_item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_item.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.block_store.block_item();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block_id = reader.bytes();
                            break;
                        case 2:
                            message.block_height = reader.uint64();
                            break;
                        case 3:
                            message.block = $root.koinos.protocol.block.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.receipt = $root.koinos.protocol.block_receipt.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block_item message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.block_store.block_item} block_item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_item.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block_item message.
                 * @function verify
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block_item.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.block_id != null && message.hasOwnProperty("block_id"))
                        if (!(message.block_id && typeof message.block_id.length === "number" || $util.isString(message.block_id)))
                            return "block_id: buffer expected";
                    if (message.block_height != null && message.hasOwnProperty("block_height"))
                        if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                            return "block_height: integer|Long expected";
                    if (message.block != null && message.hasOwnProperty("block")) {
                        var error = $root.koinos.protocol.block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                    if (message.receipt != null && message.hasOwnProperty("receipt")) {
                        var error = $root.koinos.protocol.block_receipt.verify(message.receipt);
                        if (error)
                            return "receipt." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a block_item message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.block_store.block_item} block_item
                 */
                block_item.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.block_store.block_item)
                        return object;
                    var message = new $root.koinos.block_store.block_item();
                    if (object.block_id != null)
                        if (typeof object.block_id === "string")
                            $util.base64.decode(object.block_id, message.block_id = $util.newBuffer($util.base64.length(object.block_id)), 0);
                        else if (object.block_id.length)
                            message.block_id = object.block_id;
                    if (object.block_height != null)
                        if ($util.Long)
                            (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                        else if (typeof object.block_height === "string")
                            message.block_height = parseInt(object.block_height, 10);
                        else if (typeof object.block_height === "number")
                            message.block_height = object.block_height;
                        else if (typeof object.block_height === "object")
                            message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                    if (object.block != null) {
                        if (typeof object.block !== "object")
                            throw TypeError(".koinos.block_store.block_item.block: object expected");
                        message.block = $root.koinos.protocol.block.fromObject(object.block);
                    }
                    if (object.receipt != null) {
                        if (typeof object.receipt !== "object")
                            throw TypeError(".koinos.block_store.block_item.receipt: object expected");
                        message.receipt = $root.koinos.protocol.block_receipt.fromObject(object.receipt);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a block_item message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.block_store.block_item
                 * @static
                 * @param {koinos.block_store.block_item} message block_item
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block_item.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.block_id = "";
                        else {
                            object.block_id = [];
                            if (options.bytes !== Array)
                                object.block_id = $util.newBuffer(object.block_id);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.block_height = options.longs === String ? "0" : 0;
                        object.block = null;
                        object.receipt = null;
                    }
                    if (message.block_id != null && message.hasOwnProperty("block_id"))
                        object.block_id = options.bytes === String ? $util.base64.encode(message.block_id, 0, message.block_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.block_id) : message.block_id;
                    if (message.block_height != null && message.hasOwnProperty("block_height"))
                        if (typeof message.block_height === "number")
                            object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                        else
                            object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                    if (message.block != null && message.hasOwnProperty("block"))
                        object.block = $root.koinos.protocol.block.toObject(message.block, options);
                    if (message.receipt != null && message.hasOwnProperty("receipt"))
                        object.receipt = $root.koinos.protocol.block_receipt.toObject(message.receipt, options);
                    return object;
                };
    
                /**
                 * Converts this block_item to JSON.
                 * @function toJSON
                 * @memberof koinos.block_store.block_item
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block_item.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block_item;
            })();
    
            block_store.block_record = (function() {
    
                /**
                 * Properties of a block_record.
                 * @memberof koinos.block_store
                 * @interface Iblock_record
                 * @property {Uint8Array|null} [block_id] block_record block_id
                 * @property {number|Long|null} [block_height] block_record block_height
                 * @property {koinos.protocol.Iblock|null} [block] block_record block
                 * @property {koinos.protocol.Iblock_receipt|null} [receipt] block_record receipt
                 * @property {Array.<Uint8Array>|null} [previous_block_ids] block_record previous_block_ids
                 */
    
                /**
                 * Constructs a new block_record.
                 * @memberof koinos.block_store
                 * @classdesc Represents a block_record.
                 * @implements Iblock_record
                 * @constructor
                 * @param {koinos.block_store.Iblock_record=} [properties] Properties to set
                 */
                function block_record(properties) {
                    this.previous_block_ids = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block_record block_id.
                 * @member {Uint8Array} block_id
                 * @memberof koinos.block_store.block_record
                 * @instance
                 */
                block_record.prototype.block_id = $util.newBuffer([]);
    
                /**
                 * block_record block_height.
                 * @member {number|Long} block_height
                 * @memberof koinos.block_store.block_record
                 * @instance
                 */
                block_record.prototype.block_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_record block.
                 * @member {koinos.protocol.Iblock|null|undefined} block
                 * @memberof koinos.block_store.block_record
                 * @instance
                 */
                block_record.prototype.block = null;
    
                /**
                 * block_record receipt.
                 * @member {koinos.protocol.Iblock_receipt|null|undefined} receipt
                 * @memberof koinos.block_store.block_record
                 * @instance
                 */
                block_record.prototype.receipt = null;
    
                /**
                 * block_record previous_block_ids.
                 * @member {Array.<Uint8Array>} previous_block_ids
                 * @memberof koinos.block_store.block_record
                 * @instance
                 */
                block_record.prototype.previous_block_ids = $util.emptyArray;
    
                /**
                 * Creates a new block_record instance using the specified properties.
                 * @function create
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {koinos.block_store.Iblock_record=} [properties] Properties to set
                 * @returns {koinos.block_store.block_record} block_record instance
                 */
                block_record.create = function create(properties) {
                    return new block_record(properties);
                };
    
                /**
                 * Encodes the specified block_record message. Does not implicitly {@link koinos.block_store.block_record.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {koinos.block_store.Iblock_record} message block_record message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_record.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block_id != null && Object.hasOwnProperty.call(message, "block_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.block_id);
                    if (message.block_height != null && Object.hasOwnProperty.call(message, "block_height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.block_height);
                    if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                        $root.koinos.protocol.block.encode(message.block, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                        $root.koinos.protocol.block_receipt.encode(message.receipt, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.previous_block_ids != null && message.previous_block_ids.length)
                        for (var i = 0; i < message.previous_block_ids.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.previous_block_ids[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified block_record message, length delimited. Does not implicitly {@link koinos.block_store.block_record.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {koinos.block_store.Iblock_record} message block_record message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_record.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block_record message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.block_store.block_record} block_record
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_record.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.block_store.block_record();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block_id = reader.bytes();
                            break;
                        case 2:
                            message.block_height = reader.uint64();
                            break;
                        case 3:
                            message.block = $root.koinos.protocol.block.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.receipt = $root.koinos.protocol.block_receipt.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.previous_block_ids && message.previous_block_ids.length))
                                message.previous_block_ids = [];
                            message.previous_block_ids.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block_record message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.block_store.block_record} block_record
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_record.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block_record message.
                 * @function verify
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block_record.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.block_id != null && message.hasOwnProperty("block_id"))
                        if (!(message.block_id && typeof message.block_id.length === "number" || $util.isString(message.block_id)))
                            return "block_id: buffer expected";
                    if (message.block_height != null && message.hasOwnProperty("block_height"))
                        if (!$util.isInteger(message.block_height) && !(message.block_height && $util.isInteger(message.block_height.low) && $util.isInteger(message.block_height.high)))
                            return "block_height: integer|Long expected";
                    if (message.block != null && message.hasOwnProperty("block")) {
                        var error = $root.koinos.protocol.block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                    if (message.receipt != null && message.hasOwnProperty("receipt")) {
                        var error = $root.koinos.protocol.block_receipt.verify(message.receipt);
                        if (error)
                            return "receipt." + error;
                    }
                    if (message.previous_block_ids != null && message.hasOwnProperty("previous_block_ids")) {
                        if (!Array.isArray(message.previous_block_ids))
                            return "previous_block_ids: array expected";
                        for (var i = 0; i < message.previous_block_ids.length; ++i)
                            if (!(message.previous_block_ids[i] && typeof message.previous_block_ids[i].length === "number" || $util.isString(message.previous_block_ids[i])))
                                return "previous_block_ids: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a block_record message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.block_store.block_record} block_record
                 */
                block_record.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.block_store.block_record)
                        return object;
                    var message = new $root.koinos.block_store.block_record();
                    if (object.block_id != null)
                        if (typeof object.block_id === "string")
                            $util.base64.decode(object.block_id, message.block_id = $util.newBuffer($util.base64.length(object.block_id)), 0);
                        else if (object.block_id.length)
                            message.block_id = object.block_id;
                    if (object.block_height != null)
                        if ($util.Long)
                            (message.block_height = $util.Long.fromValue(object.block_height)).unsigned = true;
                        else if (typeof object.block_height === "string")
                            message.block_height = parseInt(object.block_height, 10);
                        else if (typeof object.block_height === "number")
                            message.block_height = object.block_height;
                        else if (typeof object.block_height === "object")
                            message.block_height = new $util.LongBits(object.block_height.low >>> 0, object.block_height.high >>> 0).toNumber(true);
                    if (object.block != null) {
                        if (typeof object.block !== "object")
                            throw TypeError(".koinos.block_store.block_record.block: object expected");
                        message.block = $root.koinos.protocol.block.fromObject(object.block);
                    }
                    if (object.receipt != null) {
                        if (typeof object.receipt !== "object")
                            throw TypeError(".koinos.block_store.block_record.receipt: object expected");
                        message.receipt = $root.koinos.protocol.block_receipt.fromObject(object.receipt);
                    }
                    if (object.previous_block_ids) {
                        if (!Array.isArray(object.previous_block_ids))
                            throw TypeError(".koinos.block_store.block_record.previous_block_ids: array expected");
                        message.previous_block_ids = [];
                        for (var i = 0; i < object.previous_block_ids.length; ++i)
                            if (typeof object.previous_block_ids[i] === "string")
                                $util.base64.decode(object.previous_block_ids[i], message.previous_block_ids[i] = $util.newBuffer($util.base64.length(object.previous_block_ids[i])), 0);
                            else if (object.previous_block_ids[i].length)
                                message.previous_block_ids[i] = object.previous_block_ids[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a block_record message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.block_store.block_record
                 * @static
                 * @param {koinos.block_store.block_record} message block_record
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block_record.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.previous_block_ids = [];
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.block_id = "";
                        else {
                            object.block_id = [];
                            if (options.bytes !== Array)
                                object.block_id = $util.newBuffer(object.block_id);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.block_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.block_height = options.longs === String ? "0" : 0;
                        object.block = null;
                        object.receipt = null;
                    }
                    if (message.block_id != null && message.hasOwnProperty("block_id"))
                        object.block_id = options.bytes === String ? $util.base64.encode(message.block_id, 0, message.block_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.block_id) : message.block_id;
                    if (message.block_height != null && message.hasOwnProperty("block_height"))
                        if (typeof message.block_height === "number")
                            object.block_height = options.longs === String ? String(message.block_height) : message.block_height;
                        else
                            object.block_height = options.longs === String ? $util.Long.prototype.toString.call(message.block_height) : options.longs === Number ? new $util.LongBits(message.block_height.low >>> 0, message.block_height.high >>> 0).toNumber(true) : message.block_height;
                    if (message.block != null && message.hasOwnProperty("block"))
                        object.block = $root.koinos.protocol.block.toObject(message.block, options);
                    if (message.receipt != null && message.hasOwnProperty("receipt"))
                        object.receipt = $root.koinos.protocol.block_receipt.toObject(message.receipt, options);
                    if (message.previous_block_ids && message.previous_block_ids.length) {
                        object.previous_block_ids = [];
                        for (var j = 0; j < message.previous_block_ids.length; ++j)
                            object.previous_block_ids[j] = options.bytes === String ? $util.base64.encode(message.previous_block_ids[j], 0, message.previous_block_ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.previous_block_ids[j]) : message.previous_block_ids[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this block_record to JSON.
                 * @function toJSON
                 * @memberof koinos.block_store.block_record
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block_record.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block_record;
            })();
    
            return block_store;
        })();
    
        koinos.rpc = (function() {
    
            /**
             * Namespace rpc.
             * @memberof koinos
             * @namespace
             */
            var rpc = {};
    
            rpc.contract_meta_store = (function() {
    
                /**
                 * Namespace contract_meta_store.
                 * @memberof koinos.rpc
                 * @namespace
                 */
                var contract_meta_store = {};
    
                contract_meta_store.get_contract_meta_request = (function() {
    
                    /**
                     * Properties of a get_contract_meta_request.
                     * @memberof koinos.rpc.contract_meta_store
                     * @interface Iget_contract_meta_request
                     * @property {Uint8Array|null} [contract_id] get_contract_meta_request contract_id
                     */
    
                    /**
                     * Constructs a new get_contract_meta_request.
                     * @memberof koinos.rpc.contract_meta_store
                     * @classdesc Represents a get_contract_meta_request.
                     * @implements Iget_contract_meta_request
                     * @constructor
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_request=} [properties] Properties to set
                     */
                    function get_contract_meta_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_contract_meta_request contract_id.
                     * @member {Uint8Array} contract_id
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @instance
                     */
                    get_contract_meta_request.prototype.contract_id = $util.newBuffer([]);
    
                    /**
                     * Creates a new get_contract_meta_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_request=} [properties] Properties to set
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_request} get_contract_meta_request instance
                     */
                    get_contract_meta_request.create = function create(properties) {
                        return new get_contract_meta_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_contract_meta_request message. Does not implicitly {@link koinos.rpc.contract_meta_store.get_contract_meta_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_request} message get_contract_meta_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_contract_meta_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_contract_meta_request message, length delimited. Does not implicitly {@link koinos.rpc.contract_meta_store.get_contract_meta_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_request} message get_contract_meta_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_contract_meta_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_contract_meta_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_request} get_contract_meta_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_contract_meta_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.contract_meta_store.get_contract_meta_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contract_id = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_contract_meta_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_request} get_contract_meta_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_contract_meta_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_contract_meta_request message.
                     * @function verify
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_contract_meta_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                            if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                                return "contract_id: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_contract_meta_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_request} get_contract_meta_request
                     */
                    get_contract_meta_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.contract_meta_store.get_contract_meta_request)
                            return object;
                        var message = new $root.koinos.rpc.contract_meta_store.get_contract_meta_request();
                        if (object.contract_id != null)
                            if (typeof object.contract_id === "string")
                                $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                            else if (object.contract_id.length)
                                message.contract_id = object.contract_id;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_contract_meta_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.get_contract_meta_request} message get_contract_meta_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_contract_meta_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.contract_id = "";
                            else {
                                object.contract_id = [];
                                if (options.bytes !== Array)
                                    object.contract_id = $util.newBuffer(object.contract_id);
                            }
                        if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                            object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                        return object;
                    };
    
                    /**
                     * Converts this get_contract_meta_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_contract_meta_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_contract_meta_request;
                })();
    
                contract_meta_store.get_contract_meta_response = (function() {
    
                    /**
                     * Properties of a get_contract_meta_response.
                     * @memberof koinos.rpc.contract_meta_store
                     * @interface Iget_contract_meta_response
                     * @property {koinos.contract_meta_store.Icontract_meta_item|null} [meta] get_contract_meta_response meta
                     */
    
                    /**
                     * Constructs a new get_contract_meta_response.
                     * @memberof koinos.rpc.contract_meta_store
                     * @classdesc Represents a get_contract_meta_response.
                     * @implements Iget_contract_meta_response
                     * @constructor
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_response=} [properties] Properties to set
                     */
                    function get_contract_meta_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_contract_meta_response meta.
                     * @member {koinos.contract_meta_store.Icontract_meta_item|null|undefined} meta
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @instance
                     */
                    get_contract_meta_response.prototype.meta = null;
    
                    /**
                     * Creates a new get_contract_meta_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_response=} [properties] Properties to set
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_response} get_contract_meta_response instance
                     */
                    get_contract_meta_response.create = function create(properties) {
                        return new get_contract_meta_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_contract_meta_response message. Does not implicitly {@link koinos.rpc.contract_meta_store.get_contract_meta_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_response} message get_contract_meta_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_contract_meta_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.meta != null && Object.hasOwnProperty.call(message, "meta"))
                            $root.koinos.contract_meta_store.contract_meta_item.encode(message.meta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_contract_meta_response message, length delimited. Does not implicitly {@link koinos.rpc.contract_meta_store.get_contract_meta_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Iget_contract_meta_response} message get_contract_meta_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_contract_meta_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_contract_meta_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_response} get_contract_meta_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_contract_meta_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.contract_meta_store.get_contract_meta_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.meta = $root.koinos.contract_meta_store.contract_meta_item.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_contract_meta_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_response} get_contract_meta_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_contract_meta_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_contract_meta_response message.
                     * @function verify
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_contract_meta_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.meta != null && message.hasOwnProperty("meta")) {
                            var error = $root.koinos.contract_meta_store.contract_meta_item.verify(message.meta);
                            if (error)
                                return "meta." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_contract_meta_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.contract_meta_store.get_contract_meta_response} get_contract_meta_response
                     */
                    get_contract_meta_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.contract_meta_store.get_contract_meta_response)
                            return object;
                        var message = new $root.koinos.rpc.contract_meta_store.get_contract_meta_response();
                        if (object.meta != null) {
                            if (typeof object.meta !== "object")
                                throw TypeError(".koinos.rpc.contract_meta_store.get_contract_meta_response.meta: object expected");
                            message.meta = $root.koinos.contract_meta_store.contract_meta_item.fromObject(object.meta);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_contract_meta_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.get_contract_meta_response} message get_contract_meta_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_contract_meta_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.meta = null;
                        if (message.meta != null && message.hasOwnProperty("meta"))
                            object.meta = $root.koinos.contract_meta_store.contract_meta_item.toObject(message.meta, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_contract_meta_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.contract_meta_store.get_contract_meta_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_contract_meta_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_contract_meta_response;
                })();
    
                contract_meta_store.contract_meta_store_request = (function() {
    
                    /**
                     * Properties of a contract_meta_store_request.
                     * @memberof koinos.rpc.contract_meta_store
                     * @interface Icontract_meta_store_request
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] contract_meta_store_request reserved
                     * @property {koinos.rpc.contract_meta_store.Iget_contract_meta_request|null} [get_contract_meta] contract_meta_store_request get_contract_meta
                     */
    
                    /**
                     * Constructs a new contract_meta_store_request.
                     * @memberof koinos.rpc.contract_meta_store
                     * @classdesc Represents a contract_meta_store_request.
                     * @implements Icontract_meta_store_request
                     * @constructor
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_request=} [properties] Properties to set
                     */
                    function contract_meta_store_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * contract_meta_store_request reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @instance
                     */
                    contract_meta_store_request.prototype.reserved = null;
    
                    /**
                     * contract_meta_store_request get_contract_meta.
                     * @member {koinos.rpc.contract_meta_store.Iget_contract_meta_request|null|undefined} get_contract_meta
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @instance
                     */
                    contract_meta_store_request.prototype.get_contract_meta = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * contract_meta_store_request request.
                     * @member {"reserved"|"get_contract_meta"|undefined} request
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @instance
                     */
                    Object.defineProperty(contract_meta_store_request.prototype, "request", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "get_contract_meta"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new contract_meta_store_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_request=} [properties] Properties to set
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_request} contract_meta_store_request instance
                     */
                    contract_meta_store_request.create = function create(properties) {
                        return new contract_meta_store_request(properties);
                    };
    
                    /**
                     * Encodes the specified contract_meta_store_request message. Does not implicitly {@link koinos.rpc.contract_meta_store.contract_meta_store_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_request} message contract_meta_store_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    contract_meta_store_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.get_contract_meta != null && Object.hasOwnProperty.call(message, "get_contract_meta"))
                            $root.koinos.rpc.contract_meta_store.get_contract_meta_request.encode(message.get_contract_meta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified contract_meta_store_request message, length delimited. Does not implicitly {@link koinos.rpc.contract_meta_store.contract_meta_store_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_request} message contract_meta_store_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    contract_meta_store_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a contract_meta_store_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_request} contract_meta_store_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    contract_meta_store_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.contract_meta_store.contract_meta_store_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.get_contract_meta = $root.koinos.rpc.contract_meta_store.get_contract_meta_request.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a contract_meta_store_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_request} contract_meta_store_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    contract_meta_store_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a contract_meta_store_request message.
                     * @function verify
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    contract_meta_store_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.get_contract_meta != null && message.hasOwnProperty("get_contract_meta")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.contract_meta_store.get_contract_meta_request.verify(message.get_contract_meta);
                                if (error)
                                    return "get_contract_meta." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a contract_meta_store_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_request} contract_meta_store_request
                     */
                    contract_meta_store_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.contract_meta_store.contract_meta_store_request)
                            return object;
                        var message = new $root.koinos.rpc.contract_meta_store.contract_meta_store_request();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.contract_meta_store.contract_meta_store_request.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.get_contract_meta != null) {
                            if (typeof object.get_contract_meta !== "object")
                                throw TypeError(".koinos.rpc.contract_meta_store.contract_meta_store_request.get_contract_meta: object expected");
                            message.get_contract_meta = $root.koinos.rpc.contract_meta_store.get_contract_meta_request.fromObject(object.get_contract_meta);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a contract_meta_store_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @static
                     * @param {koinos.rpc.contract_meta_store.contract_meta_store_request} message contract_meta_store_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    contract_meta_store_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.request = "reserved";
                        }
                        if (message.get_contract_meta != null && message.hasOwnProperty("get_contract_meta")) {
                            object.get_contract_meta = $root.koinos.rpc.contract_meta_store.get_contract_meta_request.toObject(message.get_contract_meta, options);
                            if (options.oneofs)
                                object.request = "get_contract_meta";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this contract_meta_store_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    contract_meta_store_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return contract_meta_store_request;
                })();
    
                contract_meta_store.contract_meta_store_response = (function() {
    
                    /**
                     * Properties of a contract_meta_store_response.
                     * @memberof koinos.rpc.contract_meta_store
                     * @interface Icontract_meta_store_response
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] contract_meta_store_response reserved
                     * @property {koinos.rpc.Ierror_response|null} [error] contract_meta_store_response error
                     * @property {koinos.rpc.contract_meta_store.Iget_contract_meta_response|null} [get_contract_meta] contract_meta_store_response get_contract_meta
                     */
    
                    /**
                     * Constructs a new contract_meta_store_response.
                     * @memberof koinos.rpc.contract_meta_store
                     * @classdesc Represents a contract_meta_store_response.
                     * @implements Icontract_meta_store_response
                     * @constructor
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_response=} [properties] Properties to set
                     */
                    function contract_meta_store_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * contract_meta_store_response reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @instance
                     */
                    contract_meta_store_response.prototype.reserved = null;
    
                    /**
                     * contract_meta_store_response error.
                     * @member {koinos.rpc.Ierror_response|null|undefined} error
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @instance
                     */
                    contract_meta_store_response.prototype.error = null;
    
                    /**
                     * contract_meta_store_response get_contract_meta.
                     * @member {koinos.rpc.contract_meta_store.Iget_contract_meta_response|null|undefined} get_contract_meta
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @instance
                     */
                    contract_meta_store_response.prototype.get_contract_meta = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * contract_meta_store_response response.
                     * @member {"reserved"|"error"|"get_contract_meta"|undefined} response
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @instance
                     */
                    Object.defineProperty(contract_meta_store_response.prototype, "response", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "error", "get_contract_meta"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new contract_meta_store_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_response=} [properties] Properties to set
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_response} contract_meta_store_response instance
                     */
                    contract_meta_store_response.create = function create(properties) {
                        return new contract_meta_store_response(properties);
                    };
    
                    /**
                     * Encodes the specified contract_meta_store_response message. Does not implicitly {@link koinos.rpc.contract_meta_store.contract_meta_store_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_response} message contract_meta_store_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    contract_meta_store_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.koinos.rpc.error_response.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.get_contract_meta != null && Object.hasOwnProperty.call(message, "get_contract_meta"))
                            $root.koinos.rpc.contract_meta_store.get_contract_meta_response.encode(message.get_contract_meta, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified contract_meta_store_response message, length delimited. Does not implicitly {@link koinos.rpc.contract_meta_store.contract_meta_store_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.Icontract_meta_store_response} message contract_meta_store_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    contract_meta_store_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a contract_meta_store_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_response} contract_meta_store_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    contract_meta_store_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.contract_meta_store.contract_meta_store_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.error = $root.koinos.rpc.error_response.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.get_contract_meta = $root.koinos.rpc.contract_meta_store.get_contract_meta_response.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a contract_meta_store_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_response} contract_meta_store_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    contract_meta_store_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a contract_meta_store_response message.
                     * @function verify
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    contract_meta_store_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.error_response.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.get_contract_meta != null && message.hasOwnProperty("get_contract_meta")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.contract_meta_store.get_contract_meta_response.verify(message.get_contract_meta);
                                if (error)
                                    return "get_contract_meta." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a contract_meta_store_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.contract_meta_store.contract_meta_store_response} contract_meta_store_response
                     */
                    contract_meta_store_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.contract_meta_store.contract_meta_store_response)
                            return object;
                        var message = new $root.koinos.rpc.contract_meta_store.contract_meta_store_response();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.contract_meta_store.contract_meta_store_response.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".koinos.rpc.contract_meta_store.contract_meta_store_response.error: object expected");
                            message.error = $root.koinos.rpc.error_response.fromObject(object.error);
                        }
                        if (object.get_contract_meta != null) {
                            if (typeof object.get_contract_meta !== "object")
                                throw TypeError(".koinos.rpc.contract_meta_store.contract_meta_store_response.get_contract_meta: object expected");
                            message.get_contract_meta = $root.koinos.rpc.contract_meta_store.get_contract_meta_response.fromObject(object.get_contract_meta);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a contract_meta_store_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @static
                     * @param {koinos.rpc.contract_meta_store.contract_meta_store_response} message contract_meta_store_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    contract_meta_store_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.response = "reserved";
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.koinos.rpc.error_response.toObject(message.error, options);
                            if (options.oneofs)
                                object.response = "error";
                        }
                        if (message.get_contract_meta != null && message.hasOwnProperty("get_contract_meta")) {
                            object.get_contract_meta = $root.koinos.rpc.contract_meta_store.get_contract_meta_response.toObject(message.get_contract_meta, options);
                            if (options.oneofs)
                                object.response = "get_contract_meta";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this contract_meta_store_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.contract_meta_store.contract_meta_store_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    contract_meta_store_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return contract_meta_store_response;
                })();
    
                return contract_meta_store;
            })();
    
            rpc.mempool = (function() {
    
                /**
                 * Namespace mempool.
                 * @memberof koinos.rpc
                 * @namespace
                 */
                var mempool = {};
    
                mempool.pending_transaction = (function() {
    
                    /**
                     * Properties of a pending_transaction.
                     * @memberof koinos.rpc.mempool
                     * @interface Ipending_transaction
                     * @property {koinos.protocol.Itransaction|null} [transaction] pending_transaction transaction
                     * @property {number|Long|null} [disk_storage_used] pending_transaction disk_storage_used
                     * @property {number|Long|null} [network_bandwidth_used] pending_transaction network_bandwidth_used
                     * @property {number|Long|null} [compute_bandwidth_used] pending_transaction compute_bandwidth_used
                     */
    
                    /**
                     * Constructs a new pending_transaction.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a pending_transaction.
                     * @implements Ipending_transaction
                     * @constructor
                     * @param {koinos.rpc.mempool.Ipending_transaction=} [properties] Properties to set
                     */
                    function pending_transaction(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * pending_transaction transaction.
                     * @member {koinos.protocol.Itransaction|null|undefined} transaction
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @instance
                     */
                    pending_transaction.prototype.transaction = null;
    
                    /**
                     * pending_transaction disk_storage_used.
                     * @member {number|Long} disk_storage_used
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @instance
                     */
                    pending_transaction.prototype.disk_storage_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * pending_transaction network_bandwidth_used.
                     * @member {number|Long} network_bandwidth_used
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @instance
                     */
                    pending_transaction.prototype.network_bandwidth_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * pending_transaction compute_bandwidth_used.
                     * @member {number|Long} compute_bandwidth_used
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @instance
                     */
                    pending_transaction.prototype.compute_bandwidth_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new pending_transaction instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {koinos.rpc.mempool.Ipending_transaction=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.pending_transaction} pending_transaction instance
                     */
                    pending_transaction.create = function create(properties) {
                        return new pending_transaction(properties);
                    };
    
                    /**
                     * Encodes the specified pending_transaction message. Does not implicitly {@link koinos.rpc.mempool.pending_transaction.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {koinos.rpc.mempool.Ipending_transaction} message pending_transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    pending_transaction.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.koinos.protocol.transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.disk_storage_used != null && Object.hasOwnProperty.call(message, "disk_storage_used"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.disk_storage_used);
                        if (message.network_bandwidth_used != null && Object.hasOwnProperty.call(message, "network_bandwidth_used"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.network_bandwidth_used);
                        if (message.compute_bandwidth_used != null && Object.hasOwnProperty.call(message, "compute_bandwidth_used"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.compute_bandwidth_used);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified pending_transaction message, length delimited. Does not implicitly {@link koinos.rpc.mempool.pending_transaction.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {koinos.rpc.mempool.Ipending_transaction} message pending_transaction message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    pending_transaction.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a pending_transaction message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.pending_transaction} pending_transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    pending_transaction.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.pending_transaction();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.disk_storage_used = reader.uint64();
                                break;
                            case 3:
                                message.network_bandwidth_used = reader.uint64();
                                break;
                            case 4:
                                message.compute_bandwidth_used = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a pending_transaction message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.pending_transaction} pending_transaction
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    pending_transaction.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a pending_transaction message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    pending_transaction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.koinos.protocol.transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.disk_storage_used != null && message.hasOwnProperty("disk_storage_used"))
                            if (!$util.isInteger(message.disk_storage_used) && !(message.disk_storage_used && $util.isInteger(message.disk_storage_used.low) && $util.isInteger(message.disk_storage_used.high)))
                                return "disk_storage_used: integer|Long expected";
                        if (message.network_bandwidth_used != null && message.hasOwnProperty("network_bandwidth_used"))
                            if (!$util.isInteger(message.network_bandwidth_used) && !(message.network_bandwidth_used && $util.isInteger(message.network_bandwidth_used.low) && $util.isInteger(message.network_bandwidth_used.high)))
                                return "network_bandwidth_used: integer|Long expected";
                        if (message.compute_bandwidth_used != null && message.hasOwnProperty("compute_bandwidth_used"))
                            if (!$util.isInteger(message.compute_bandwidth_used) && !(message.compute_bandwidth_used && $util.isInteger(message.compute_bandwidth_used.low) && $util.isInteger(message.compute_bandwidth_used.high)))
                                return "compute_bandwidth_used: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a pending_transaction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.pending_transaction} pending_transaction
                     */
                    pending_transaction.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.pending_transaction)
                            return object;
                        var message = new $root.koinos.rpc.mempool.pending_transaction();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".koinos.rpc.mempool.pending_transaction.transaction: object expected");
                            message.transaction = $root.koinos.protocol.transaction.fromObject(object.transaction);
                        }
                        if (object.disk_storage_used != null)
                            if ($util.Long)
                                (message.disk_storage_used = $util.Long.fromValue(object.disk_storage_used)).unsigned = true;
                            else if (typeof object.disk_storage_used === "string")
                                message.disk_storage_used = parseInt(object.disk_storage_used, 10);
                            else if (typeof object.disk_storage_used === "number")
                                message.disk_storage_used = object.disk_storage_used;
                            else if (typeof object.disk_storage_used === "object")
                                message.disk_storage_used = new $util.LongBits(object.disk_storage_used.low >>> 0, object.disk_storage_used.high >>> 0).toNumber(true);
                        if (object.network_bandwidth_used != null)
                            if ($util.Long)
                                (message.network_bandwidth_used = $util.Long.fromValue(object.network_bandwidth_used)).unsigned = true;
                            else if (typeof object.network_bandwidth_used === "string")
                                message.network_bandwidth_used = parseInt(object.network_bandwidth_used, 10);
                            else if (typeof object.network_bandwidth_used === "number")
                                message.network_bandwidth_used = object.network_bandwidth_used;
                            else if (typeof object.network_bandwidth_used === "object")
                                message.network_bandwidth_used = new $util.LongBits(object.network_bandwidth_used.low >>> 0, object.network_bandwidth_used.high >>> 0).toNumber(true);
                        if (object.compute_bandwidth_used != null)
                            if ($util.Long)
                                (message.compute_bandwidth_used = $util.Long.fromValue(object.compute_bandwidth_used)).unsigned = true;
                            else if (typeof object.compute_bandwidth_used === "string")
                                message.compute_bandwidth_used = parseInt(object.compute_bandwidth_used, 10);
                            else if (typeof object.compute_bandwidth_used === "number")
                                message.compute_bandwidth_used = object.compute_bandwidth_used;
                            else if (typeof object.compute_bandwidth_used === "object")
                                message.compute_bandwidth_used = new $util.LongBits(object.compute_bandwidth_used.low >>> 0, object.compute_bandwidth_used.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a pending_transaction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @static
                     * @param {koinos.rpc.mempool.pending_transaction} message pending_transaction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    pending_transaction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.disk_storage_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.disk_storage_used = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.network_bandwidth_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.network_bandwidth_used = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.compute_bandwidth_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.compute_bandwidth_used = options.longs === String ? "0" : 0;
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.koinos.protocol.transaction.toObject(message.transaction, options);
                        if (message.disk_storage_used != null && message.hasOwnProperty("disk_storage_used"))
                            if (typeof message.disk_storage_used === "number")
                                object.disk_storage_used = options.longs === String ? String(message.disk_storage_used) : message.disk_storage_used;
                            else
                                object.disk_storage_used = options.longs === String ? $util.Long.prototype.toString.call(message.disk_storage_used) : options.longs === Number ? new $util.LongBits(message.disk_storage_used.low >>> 0, message.disk_storage_used.high >>> 0).toNumber(true) : message.disk_storage_used;
                        if (message.network_bandwidth_used != null && message.hasOwnProperty("network_bandwidth_used"))
                            if (typeof message.network_bandwidth_used === "number")
                                object.network_bandwidth_used = options.longs === String ? String(message.network_bandwidth_used) : message.network_bandwidth_used;
                            else
                                object.network_bandwidth_used = options.longs === String ? $util.Long.prototype.toString.call(message.network_bandwidth_used) : options.longs === Number ? new $util.LongBits(message.network_bandwidth_used.low >>> 0, message.network_bandwidth_used.high >>> 0).toNumber(true) : message.network_bandwidth_used;
                        if (message.compute_bandwidth_used != null && message.hasOwnProperty("compute_bandwidth_used"))
                            if (typeof message.compute_bandwidth_used === "number")
                                object.compute_bandwidth_used = options.longs === String ? String(message.compute_bandwidth_used) : message.compute_bandwidth_used;
                            else
                                object.compute_bandwidth_used = options.longs === String ? $util.Long.prototype.toString.call(message.compute_bandwidth_used) : options.longs === Number ? new $util.LongBits(message.compute_bandwidth_used.low >>> 0, message.compute_bandwidth_used.high >>> 0).toNumber(true) : message.compute_bandwidth_used;
                        return object;
                    };
    
                    /**
                     * Converts this pending_transaction to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.pending_transaction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    pending_transaction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return pending_transaction;
                })();
    
                mempool.check_pending_account_resources_request = (function() {
    
                    /**
                     * Properties of a check_pending_account_resources_request.
                     * @memberof koinos.rpc.mempool
                     * @interface Icheck_pending_account_resources_request
                     * @property {Uint8Array|null} [payer] check_pending_account_resources_request payer
                     * @property {number|Long|null} [max_payer_rc] check_pending_account_resources_request max_payer_rc
                     * @property {number|Long|null} [rc_limit] check_pending_account_resources_request rc_limit
                     */
    
                    /**
                     * Constructs a new check_pending_account_resources_request.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a check_pending_account_resources_request.
                     * @implements Icheck_pending_account_resources_request
                     * @constructor
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_request=} [properties] Properties to set
                     */
                    function check_pending_account_resources_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * check_pending_account_resources_request payer.
                     * @member {Uint8Array} payer
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @instance
                     */
                    check_pending_account_resources_request.prototype.payer = $util.newBuffer([]);
    
                    /**
                     * check_pending_account_resources_request max_payer_rc.
                     * @member {number|Long} max_payer_rc
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @instance
                     */
                    check_pending_account_resources_request.prototype.max_payer_rc = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * check_pending_account_resources_request rc_limit.
                     * @member {number|Long} rc_limit
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @instance
                     */
                    check_pending_account_resources_request.prototype.rc_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new check_pending_account_resources_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_request=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_request} check_pending_account_resources_request instance
                     */
                    check_pending_account_resources_request.create = function create(properties) {
                        return new check_pending_account_resources_request(properties);
                    };
    
                    /**
                     * Encodes the specified check_pending_account_resources_request message. Does not implicitly {@link koinos.rpc.mempool.check_pending_account_resources_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_request} message check_pending_account_resources_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    check_pending_account_resources_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.payer != null && Object.hasOwnProperty.call(message, "payer"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.payer);
                        if (message.max_payer_rc != null && Object.hasOwnProperty.call(message, "max_payer_rc"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.max_payer_rc);
                        if (message.rc_limit != null && Object.hasOwnProperty.call(message, "rc_limit"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.rc_limit);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified check_pending_account_resources_request message, length delimited. Does not implicitly {@link koinos.rpc.mempool.check_pending_account_resources_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_request} message check_pending_account_resources_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    check_pending_account_resources_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a check_pending_account_resources_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_request} check_pending_account_resources_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    check_pending_account_resources_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.check_pending_account_resources_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.payer = reader.bytes();
                                break;
                            case 2:
                                message.max_payer_rc = reader.uint64();
                                break;
                            case 3:
                                message.rc_limit = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a check_pending_account_resources_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_request} check_pending_account_resources_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    check_pending_account_resources_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a check_pending_account_resources_request message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    check_pending_account_resources_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.payer != null && message.hasOwnProperty("payer"))
                            if (!(message.payer && typeof message.payer.length === "number" || $util.isString(message.payer)))
                                return "payer: buffer expected";
                        if (message.max_payer_rc != null && message.hasOwnProperty("max_payer_rc"))
                            if (!$util.isInteger(message.max_payer_rc) && !(message.max_payer_rc && $util.isInteger(message.max_payer_rc.low) && $util.isInteger(message.max_payer_rc.high)))
                                return "max_payer_rc: integer|Long expected";
                        if (message.rc_limit != null && message.hasOwnProperty("rc_limit"))
                            if (!$util.isInteger(message.rc_limit) && !(message.rc_limit && $util.isInteger(message.rc_limit.low) && $util.isInteger(message.rc_limit.high)))
                                return "rc_limit: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a check_pending_account_resources_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_request} check_pending_account_resources_request
                     */
                    check_pending_account_resources_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.check_pending_account_resources_request)
                            return object;
                        var message = new $root.koinos.rpc.mempool.check_pending_account_resources_request();
                        if (object.payer != null)
                            if (typeof object.payer === "string")
                                $util.base64.decode(object.payer, message.payer = $util.newBuffer($util.base64.length(object.payer)), 0);
                            else if (object.payer.length)
                                message.payer = object.payer;
                        if (object.max_payer_rc != null)
                            if ($util.Long)
                                (message.max_payer_rc = $util.Long.fromValue(object.max_payer_rc)).unsigned = true;
                            else if (typeof object.max_payer_rc === "string")
                                message.max_payer_rc = parseInt(object.max_payer_rc, 10);
                            else if (typeof object.max_payer_rc === "number")
                                message.max_payer_rc = object.max_payer_rc;
                            else if (typeof object.max_payer_rc === "object")
                                message.max_payer_rc = new $util.LongBits(object.max_payer_rc.low >>> 0, object.max_payer_rc.high >>> 0).toNumber(true);
                        if (object.rc_limit != null)
                            if ($util.Long)
                                (message.rc_limit = $util.Long.fromValue(object.rc_limit)).unsigned = true;
                            else if (typeof object.rc_limit === "string")
                                message.rc_limit = parseInt(object.rc_limit, 10);
                            else if (typeof object.rc_limit === "number")
                                message.rc_limit = object.rc_limit;
                            else if (typeof object.rc_limit === "object")
                                message.rc_limit = new $util.LongBits(object.rc_limit.low >>> 0, object.rc_limit.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a check_pending_account_resources_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @static
                     * @param {koinos.rpc.mempool.check_pending_account_resources_request} message check_pending_account_resources_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    check_pending_account_resources_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.payer = "";
                            else {
                                object.payer = [];
                                if (options.bytes !== Array)
                                    object.payer = $util.newBuffer(object.payer);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.max_payer_rc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.max_payer_rc = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.rc_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.rc_limit = options.longs === String ? "0" : 0;
                        }
                        if (message.payer != null && message.hasOwnProperty("payer"))
                            object.payer = options.bytes === String ? $util.base64.encode(message.payer, 0, message.payer.length) : options.bytes === Array ? Array.prototype.slice.call(message.payer) : message.payer;
                        if (message.max_payer_rc != null && message.hasOwnProperty("max_payer_rc"))
                            if (typeof message.max_payer_rc === "number")
                                object.max_payer_rc = options.longs === String ? String(message.max_payer_rc) : message.max_payer_rc;
                            else
                                object.max_payer_rc = options.longs === String ? $util.Long.prototype.toString.call(message.max_payer_rc) : options.longs === Number ? new $util.LongBits(message.max_payer_rc.low >>> 0, message.max_payer_rc.high >>> 0).toNumber(true) : message.max_payer_rc;
                        if (message.rc_limit != null && message.hasOwnProperty("rc_limit"))
                            if (typeof message.rc_limit === "number")
                                object.rc_limit = options.longs === String ? String(message.rc_limit) : message.rc_limit;
                            else
                                object.rc_limit = options.longs === String ? $util.Long.prototype.toString.call(message.rc_limit) : options.longs === Number ? new $util.LongBits(message.rc_limit.low >>> 0, message.rc_limit.high >>> 0).toNumber(true) : message.rc_limit;
                        return object;
                    };
    
                    /**
                     * Converts this check_pending_account_resources_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    check_pending_account_resources_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return check_pending_account_resources_request;
                })();
    
                mempool.check_pending_account_resources_response = (function() {
    
                    /**
                     * Properties of a check_pending_account_resources_response.
                     * @memberof koinos.rpc.mempool
                     * @interface Icheck_pending_account_resources_response
                     * @property {boolean|null} [success] check_pending_account_resources_response success
                     */
    
                    /**
                     * Constructs a new check_pending_account_resources_response.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a check_pending_account_resources_response.
                     * @implements Icheck_pending_account_resources_response
                     * @constructor
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_response=} [properties] Properties to set
                     */
                    function check_pending_account_resources_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * check_pending_account_resources_response success.
                     * @member {boolean} success
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @instance
                     */
                    check_pending_account_resources_response.prototype.success = false;
    
                    /**
                     * Creates a new check_pending_account_resources_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_response=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_response} check_pending_account_resources_response instance
                     */
                    check_pending_account_resources_response.create = function create(properties) {
                        return new check_pending_account_resources_response(properties);
                    };
    
                    /**
                     * Encodes the specified check_pending_account_resources_response message. Does not implicitly {@link koinos.rpc.mempool.check_pending_account_resources_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_response} message check_pending_account_resources_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    check_pending_account_resources_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.success);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified check_pending_account_resources_response message, length delimited. Does not implicitly {@link koinos.rpc.mempool.check_pending_account_resources_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {koinos.rpc.mempool.Icheck_pending_account_resources_response} message check_pending_account_resources_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    check_pending_account_resources_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a check_pending_account_resources_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_response} check_pending_account_resources_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    check_pending_account_resources_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.check_pending_account_resources_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.success = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a check_pending_account_resources_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_response} check_pending_account_resources_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    check_pending_account_resources_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a check_pending_account_resources_response message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    check_pending_account_resources_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.success != null && message.hasOwnProperty("success"))
                            if (typeof message.success !== "boolean")
                                return "success: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a check_pending_account_resources_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.check_pending_account_resources_response} check_pending_account_resources_response
                     */
                    check_pending_account_resources_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.check_pending_account_resources_response)
                            return object;
                        var message = new $root.koinos.rpc.mempool.check_pending_account_resources_response();
                        if (object.success != null)
                            message.success = Boolean(object.success);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a check_pending_account_resources_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @static
                     * @param {koinos.rpc.mempool.check_pending_account_resources_response} message check_pending_account_resources_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    check_pending_account_resources_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.success = false;
                        if (message.success != null && message.hasOwnProperty("success"))
                            object.success = message.success;
                        return object;
                    };
    
                    /**
                     * Converts this check_pending_account_resources_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.check_pending_account_resources_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    check_pending_account_resources_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return check_pending_account_resources_response;
                })();
    
                mempool.get_pending_transactions_request = (function() {
    
                    /**
                     * Properties of a get_pending_transactions_request.
                     * @memberof koinos.rpc.mempool
                     * @interface Iget_pending_transactions_request
                     * @property {number|Long|null} [limit] get_pending_transactions_request limit
                     */
    
                    /**
                     * Constructs a new get_pending_transactions_request.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a get_pending_transactions_request.
                     * @implements Iget_pending_transactions_request
                     * @constructor
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_request=} [properties] Properties to set
                     */
                    function get_pending_transactions_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_pending_transactions_request limit.
                     * @member {number|Long} limit
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @instance
                     */
                    get_pending_transactions_request.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new get_pending_transactions_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_request=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.get_pending_transactions_request} get_pending_transactions_request instance
                     */
                    get_pending_transactions_request.create = function create(properties) {
                        return new get_pending_transactions_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_pending_transactions_request message. Does not implicitly {@link koinos.rpc.mempool.get_pending_transactions_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_request} message get_pending_transactions_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_pending_transactions_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.limit);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_pending_transactions_request message, length delimited. Does not implicitly {@link koinos.rpc.mempool.get_pending_transactions_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_request} message get_pending_transactions_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_pending_transactions_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_pending_transactions_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.get_pending_transactions_request} get_pending_transactions_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_pending_transactions_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.get_pending_transactions_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.limit = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_pending_transactions_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.get_pending_transactions_request} get_pending_transactions_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_pending_transactions_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_pending_transactions_request message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_pending_transactions_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.limit != null && message.hasOwnProperty("limit"))
                            if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                                return "limit: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_pending_transactions_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.get_pending_transactions_request} get_pending_transactions_request
                     */
                    get_pending_transactions_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.get_pending_transactions_request)
                            return object;
                        var message = new $root.koinos.rpc.mempool.get_pending_transactions_request();
                        if (object.limit != null)
                            if ($util.Long)
                                (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                            else if (typeof object.limit === "string")
                                message.limit = parseInt(object.limit, 10);
                            else if (typeof object.limit === "number")
                                message.limit = object.limit;
                            else if (typeof object.limit === "object")
                                message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_pending_transactions_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @static
                     * @param {koinos.rpc.mempool.get_pending_transactions_request} message get_pending_transactions_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_pending_transactions_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.limit = options.longs === String ? "0" : 0;
                        if (message.limit != null && message.hasOwnProperty("limit"))
                            if (typeof message.limit === "number")
                                object.limit = options.longs === String ? String(message.limit) : message.limit;
                            else
                                object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                        return object;
                    };
    
                    /**
                     * Converts this get_pending_transactions_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.get_pending_transactions_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_pending_transactions_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_pending_transactions_request;
                })();
    
                mempool.get_pending_transactions_response = (function() {
    
                    /**
                     * Properties of a get_pending_transactions_response.
                     * @memberof koinos.rpc.mempool
                     * @interface Iget_pending_transactions_response
                     * @property {Array.<koinos.rpc.mempool.Ipending_transaction>|null} [pending_transactions] get_pending_transactions_response pending_transactions
                     */
    
                    /**
                     * Constructs a new get_pending_transactions_response.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a get_pending_transactions_response.
                     * @implements Iget_pending_transactions_response
                     * @constructor
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_response=} [properties] Properties to set
                     */
                    function get_pending_transactions_response(properties) {
                        this.pending_transactions = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_pending_transactions_response pending_transactions.
                     * @member {Array.<koinos.rpc.mempool.Ipending_transaction>} pending_transactions
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @instance
                     */
                    get_pending_transactions_response.prototype.pending_transactions = $util.emptyArray;
    
                    /**
                     * Creates a new get_pending_transactions_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_response=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.get_pending_transactions_response} get_pending_transactions_response instance
                     */
                    get_pending_transactions_response.create = function create(properties) {
                        return new get_pending_transactions_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_pending_transactions_response message. Does not implicitly {@link koinos.rpc.mempool.get_pending_transactions_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_response} message get_pending_transactions_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_pending_transactions_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.pending_transactions != null && message.pending_transactions.length)
                            for (var i = 0; i < message.pending_transactions.length; ++i)
                                $root.koinos.rpc.mempool.pending_transaction.encode(message.pending_transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_pending_transactions_response message, length delimited. Does not implicitly {@link koinos.rpc.mempool.get_pending_transactions_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {koinos.rpc.mempool.Iget_pending_transactions_response} message get_pending_transactions_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_pending_transactions_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_pending_transactions_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.get_pending_transactions_response} get_pending_transactions_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_pending_transactions_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.get_pending_transactions_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.pending_transactions && message.pending_transactions.length))
                                    message.pending_transactions = [];
                                message.pending_transactions.push($root.koinos.rpc.mempool.pending_transaction.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_pending_transactions_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.get_pending_transactions_response} get_pending_transactions_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_pending_transactions_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_pending_transactions_response message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_pending_transactions_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pending_transactions != null && message.hasOwnProperty("pending_transactions")) {
                            if (!Array.isArray(message.pending_transactions))
                                return "pending_transactions: array expected";
                            for (var i = 0; i < message.pending_transactions.length; ++i) {
                                var error = $root.koinos.rpc.mempool.pending_transaction.verify(message.pending_transactions[i]);
                                if (error)
                                    return "pending_transactions." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_pending_transactions_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.get_pending_transactions_response} get_pending_transactions_response
                     */
                    get_pending_transactions_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.get_pending_transactions_response)
                            return object;
                        var message = new $root.koinos.rpc.mempool.get_pending_transactions_response();
                        if (object.pending_transactions) {
                            if (!Array.isArray(object.pending_transactions))
                                throw TypeError(".koinos.rpc.mempool.get_pending_transactions_response.pending_transactions: array expected");
                            message.pending_transactions = [];
                            for (var i = 0; i < object.pending_transactions.length; ++i) {
                                if (typeof object.pending_transactions[i] !== "object")
                                    throw TypeError(".koinos.rpc.mempool.get_pending_transactions_response.pending_transactions: object expected");
                                message.pending_transactions[i] = $root.koinos.rpc.mempool.pending_transaction.fromObject(object.pending_transactions[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_pending_transactions_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @static
                     * @param {koinos.rpc.mempool.get_pending_transactions_response} message get_pending_transactions_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_pending_transactions_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.pending_transactions = [];
                        if (message.pending_transactions && message.pending_transactions.length) {
                            object.pending_transactions = [];
                            for (var j = 0; j < message.pending_transactions.length; ++j)
                                object.pending_transactions[j] = $root.koinos.rpc.mempool.pending_transaction.toObject(message.pending_transactions[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_pending_transactions_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.get_pending_transactions_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_pending_transactions_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_pending_transactions_response;
                })();
    
                mempool.mempool_request = (function() {
    
                    /**
                     * Properties of a mempool_request.
                     * @memberof koinos.rpc.mempool
                     * @interface Imempool_request
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] mempool_request reserved
                     * @property {koinos.rpc.mempool.Icheck_pending_account_resources_request|null} [check_pending_account_resources] mempool_request check_pending_account_resources
                     * @property {koinos.rpc.mempool.Iget_pending_transactions_request|null} [get_pending_transactions] mempool_request get_pending_transactions
                     */
    
                    /**
                     * Constructs a new mempool_request.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a mempool_request.
                     * @implements Imempool_request
                     * @constructor
                     * @param {koinos.rpc.mempool.Imempool_request=} [properties] Properties to set
                     */
                    function mempool_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * mempool_request reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @instance
                     */
                    mempool_request.prototype.reserved = null;
    
                    /**
                     * mempool_request check_pending_account_resources.
                     * @member {koinos.rpc.mempool.Icheck_pending_account_resources_request|null|undefined} check_pending_account_resources
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @instance
                     */
                    mempool_request.prototype.check_pending_account_resources = null;
    
                    /**
                     * mempool_request get_pending_transactions.
                     * @member {koinos.rpc.mempool.Iget_pending_transactions_request|null|undefined} get_pending_transactions
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @instance
                     */
                    mempool_request.prototype.get_pending_transactions = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * mempool_request request.
                     * @member {"reserved"|"check_pending_account_resources"|"get_pending_transactions"|undefined} request
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @instance
                     */
                    Object.defineProperty(mempool_request.prototype, "request", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "check_pending_account_resources", "get_pending_transactions"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new mempool_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {koinos.rpc.mempool.Imempool_request=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.mempool_request} mempool_request instance
                     */
                    mempool_request.create = function create(properties) {
                        return new mempool_request(properties);
                    };
    
                    /**
                     * Encodes the specified mempool_request message. Does not implicitly {@link koinos.rpc.mempool.mempool_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {koinos.rpc.mempool.Imempool_request} message mempool_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mempool_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.check_pending_account_resources != null && Object.hasOwnProperty.call(message, "check_pending_account_resources"))
                            $root.koinos.rpc.mempool.check_pending_account_resources_request.encode(message.check_pending_account_resources, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.get_pending_transactions != null && Object.hasOwnProperty.call(message, "get_pending_transactions"))
                            $root.koinos.rpc.mempool.get_pending_transactions_request.encode(message.get_pending_transactions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified mempool_request message, length delimited. Does not implicitly {@link koinos.rpc.mempool.mempool_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {koinos.rpc.mempool.Imempool_request} message mempool_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mempool_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a mempool_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.mempool_request} mempool_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mempool_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.mempool_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.check_pending_account_resources = $root.koinos.rpc.mempool.check_pending_account_resources_request.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.get_pending_transactions = $root.koinos.rpc.mempool.get_pending_transactions_request.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a mempool_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.mempool_request} mempool_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mempool_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a mempool_request message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    mempool_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.check_pending_account_resources != null && message.hasOwnProperty("check_pending_account_resources")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.mempool.check_pending_account_resources_request.verify(message.check_pending_account_resources);
                                if (error)
                                    return "check_pending_account_resources." + error;
                            }
                        }
                        if (message.get_pending_transactions != null && message.hasOwnProperty("get_pending_transactions")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.mempool.get_pending_transactions_request.verify(message.get_pending_transactions);
                                if (error)
                                    return "get_pending_transactions." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a mempool_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.mempool_request} mempool_request
                     */
                    mempool_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.mempool_request)
                            return object;
                        var message = new $root.koinos.rpc.mempool.mempool_request();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_request.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.check_pending_account_resources != null) {
                            if (typeof object.check_pending_account_resources !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_request.check_pending_account_resources: object expected");
                            message.check_pending_account_resources = $root.koinos.rpc.mempool.check_pending_account_resources_request.fromObject(object.check_pending_account_resources);
                        }
                        if (object.get_pending_transactions != null) {
                            if (typeof object.get_pending_transactions !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_request.get_pending_transactions: object expected");
                            message.get_pending_transactions = $root.koinos.rpc.mempool.get_pending_transactions_request.fromObject(object.get_pending_transactions);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a mempool_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @static
                     * @param {koinos.rpc.mempool.mempool_request} message mempool_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    mempool_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.request = "reserved";
                        }
                        if (message.check_pending_account_resources != null && message.hasOwnProperty("check_pending_account_resources")) {
                            object.check_pending_account_resources = $root.koinos.rpc.mempool.check_pending_account_resources_request.toObject(message.check_pending_account_resources, options);
                            if (options.oneofs)
                                object.request = "check_pending_account_resources";
                        }
                        if (message.get_pending_transactions != null && message.hasOwnProperty("get_pending_transactions")) {
                            object.get_pending_transactions = $root.koinos.rpc.mempool.get_pending_transactions_request.toObject(message.get_pending_transactions, options);
                            if (options.oneofs)
                                object.request = "get_pending_transactions";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this mempool_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.mempool_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    mempool_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return mempool_request;
                })();
    
                mempool.mempool_response = (function() {
    
                    /**
                     * Properties of a mempool_response.
                     * @memberof koinos.rpc.mempool
                     * @interface Imempool_response
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] mempool_response reserved
                     * @property {koinos.rpc.Ierror_response|null} [error] mempool_response error
                     * @property {koinos.rpc.mempool.Icheck_pending_account_resources_response|null} [check_pending_account_resources] mempool_response check_pending_account_resources
                     * @property {koinos.rpc.mempool.Iget_pending_transactions_response|null} [get_pending_transactions] mempool_response get_pending_transactions
                     */
    
                    /**
                     * Constructs a new mempool_response.
                     * @memberof koinos.rpc.mempool
                     * @classdesc Represents a mempool_response.
                     * @implements Imempool_response
                     * @constructor
                     * @param {koinos.rpc.mempool.Imempool_response=} [properties] Properties to set
                     */
                    function mempool_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * mempool_response reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @instance
                     */
                    mempool_response.prototype.reserved = null;
    
                    /**
                     * mempool_response error.
                     * @member {koinos.rpc.Ierror_response|null|undefined} error
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @instance
                     */
                    mempool_response.prototype.error = null;
    
                    /**
                     * mempool_response check_pending_account_resources.
                     * @member {koinos.rpc.mempool.Icheck_pending_account_resources_response|null|undefined} check_pending_account_resources
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @instance
                     */
                    mempool_response.prototype.check_pending_account_resources = null;
    
                    /**
                     * mempool_response get_pending_transactions.
                     * @member {koinos.rpc.mempool.Iget_pending_transactions_response|null|undefined} get_pending_transactions
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @instance
                     */
                    mempool_response.prototype.get_pending_transactions = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * mempool_response response.
                     * @member {"reserved"|"error"|"check_pending_account_resources"|"get_pending_transactions"|undefined} response
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @instance
                     */
                    Object.defineProperty(mempool_response.prototype, "response", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "error", "check_pending_account_resources", "get_pending_transactions"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new mempool_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {koinos.rpc.mempool.Imempool_response=} [properties] Properties to set
                     * @returns {koinos.rpc.mempool.mempool_response} mempool_response instance
                     */
                    mempool_response.create = function create(properties) {
                        return new mempool_response(properties);
                    };
    
                    /**
                     * Encodes the specified mempool_response message. Does not implicitly {@link koinos.rpc.mempool.mempool_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {koinos.rpc.mempool.Imempool_response} message mempool_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mempool_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.koinos.rpc.error_response.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.check_pending_account_resources != null && Object.hasOwnProperty.call(message, "check_pending_account_resources"))
                            $root.koinos.rpc.mempool.check_pending_account_resources_response.encode(message.check_pending_account_resources, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.get_pending_transactions != null && Object.hasOwnProperty.call(message, "get_pending_transactions"))
                            $root.koinos.rpc.mempool.get_pending_transactions_response.encode(message.get_pending_transactions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified mempool_response message, length delimited. Does not implicitly {@link koinos.rpc.mempool.mempool_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {koinos.rpc.mempool.Imempool_response} message mempool_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    mempool_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a mempool_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.mempool.mempool_response} mempool_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mempool_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.mempool.mempool_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.error = $root.koinos.rpc.error_response.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.check_pending_account_resources = $root.koinos.rpc.mempool.check_pending_account_resources_response.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.get_pending_transactions = $root.koinos.rpc.mempool.get_pending_transactions_response.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a mempool_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.mempool.mempool_response} mempool_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    mempool_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a mempool_response message.
                     * @function verify
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    mempool_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.error_response.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.check_pending_account_resources != null && message.hasOwnProperty("check_pending_account_resources")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.mempool.check_pending_account_resources_response.verify(message.check_pending_account_resources);
                                if (error)
                                    return "check_pending_account_resources." + error;
                            }
                        }
                        if (message.get_pending_transactions != null && message.hasOwnProperty("get_pending_transactions")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.mempool.get_pending_transactions_response.verify(message.get_pending_transactions);
                                if (error)
                                    return "get_pending_transactions." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a mempool_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.mempool.mempool_response} mempool_response
                     */
                    mempool_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.mempool.mempool_response)
                            return object;
                        var message = new $root.koinos.rpc.mempool.mempool_response();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_response.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_response.error: object expected");
                            message.error = $root.koinos.rpc.error_response.fromObject(object.error);
                        }
                        if (object.check_pending_account_resources != null) {
                            if (typeof object.check_pending_account_resources !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_response.check_pending_account_resources: object expected");
                            message.check_pending_account_resources = $root.koinos.rpc.mempool.check_pending_account_resources_response.fromObject(object.check_pending_account_resources);
                        }
                        if (object.get_pending_transactions != null) {
                            if (typeof object.get_pending_transactions !== "object")
                                throw TypeError(".koinos.rpc.mempool.mempool_response.get_pending_transactions: object expected");
                            message.get_pending_transactions = $root.koinos.rpc.mempool.get_pending_transactions_response.fromObject(object.get_pending_transactions);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a mempool_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @static
                     * @param {koinos.rpc.mempool.mempool_response} message mempool_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    mempool_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.response = "reserved";
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.koinos.rpc.error_response.toObject(message.error, options);
                            if (options.oneofs)
                                object.response = "error";
                        }
                        if (message.check_pending_account_resources != null && message.hasOwnProperty("check_pending_account_resources")) {
                            object.check_pending_account_resources = $root.koinos.rpc.mempool.check_pending_account_resources_response.toObject(message.check_pending_account_resources, options);
                            if (options.oneofs)
                                object.response = "check_pending_account_resources";
                        }
                        if (message.get_pending_transactions != null && message.hasOwnProperty("get_pending_transactions")) {
                            object.get_pending_transactions = $root.koinos.rpc.mempool.get_pending_transactions_response.toObject(message.get_pending_transactions, options);
                            if (options.oneofs)
                                object.response = "get_pending_transactions";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this mempool_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.mempool.mempool_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    mempool_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return mempool_response;
                })();
    
                return mempool;
            })();
    
            rpc.block_store = (function() {
    
                /**
                 * Namespace block_store.
                 * @memberof koinos.rpc
                 * @namespace
                 */
                var block_store = {};
    
                block_store.get_blocks_by_id_request = (function() {
    
                    /**
                     * Properties of a get_blocks_by_id_request.
                     * @memberof koinos.rpc.block_store
                     * @interface Iget_blocks_by_id_request
                     * @property {Array.<Uint8Array>|null} [block_ids] get_blocks_by_id_request block_ids
                     * @property {boolean|null} [return_block] get_blocks_by_id_request return_block
                     * @property {boolean|null} [return_receipt] get_blocks_by_id_request return_receipt
                     */
    
                    /**
                     * Constructs a new get_blocks_by_id_request.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a get_blocks_by_id_request.
                     * @implements Iget_blocks_by_id_request
                     * @constructor
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_request=} [properties] Properties to set
                     */
                    function get_blocks_by_id_request(properties) {
                        this.block_ids = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_blocks_by_id_request block_ids.
                     * @member {Array.<Uint8Array>} block_ids
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @instance
                     */
                    get_blocks_by_id_request.prototype.block_ids = $util.emptyArray;
    
                    /**
                     * get_blocks_by_id_request return_block.
                     * @member {boolean} return_block
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @instance
                     */
                    get_blocks_by_id_request.prototype.return_block = false;
    
                    /**
                     * get_blocks_by_id_request return_receipt.
                     * @member {boolean} return_receipt
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @instance
                     */
                    get_blocks_by_id_request.prototype.return_receipt = false;
    
                    /**
                     * Creates a new get_blocks_by_id_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_request=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_request} get_blocks_by_id_request instance
                     */
                    get_blocks_by_id_request.create = function create(properties) {
                        return new get_blocks_by_id_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_id_request message. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_id_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_request} message get_blocks_by_id_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_id_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.block_ids != null && message.block_ids.length)
                            for (var i = 0; i < message.block_ids.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.block_ids[i]);
                        if (message.return_block != null && Object.hasOwnProperty.call(message, "return_block"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.return_block);
                        if (message.return_receipt != null && Object.hasOwnProperty.call(message, "return_receipt"))
                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.return_receipt);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_id_request message, length delimited. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_id_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_request} message get_blocks_by_id_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_id_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_blocks_by_id_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_request} get_blocks_by_id_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_id_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.get_blocks_by_id_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.block_ids && message.block_ids.length))
                                    message.block_ids = [];
                                message.block_ids.push(reader.bytes());
                                break;
                            case 2:
                                message.return_block = reader.bool();
                                break;
                            case 3:
                                message.return_receipt = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_blocks_by_id_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_request} get_blocks_by_id_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_id_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_blocks_by_id_request message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_blocks_by_id_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.block_ids != null && message.hasOwnProperty("block_ids")) {
                            if (!Array.isArray(message.block_ids))
                                return "block_ids: array expected";
                            for (var i = 0; i < message.block_ids.length; ++i)
                                if (!(message.block_ids[i] && typeof message.block_ids[i].length === "number" || $util.isString(message.block_ids[i])))
                                    return "block_ids: buffer[] expected";
                        }
                        if (message.return_block != null && message.hasOwnProperty("return_block"))
                            if (typeof message.return_block !== "boolean")
                                return "return_block: boolean expected";
                        if (message.return_receipt != null && message.hasOwnProperty("return_receipt"))
                            if (typeof message.return_receipt !== "boolean")
                                return "return_receipt: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_blocks_by_id_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_request} get_blocks_by_id_request
                     */
                    get_blocks_by_id_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.get_blocks_by_id_request)
                            return object;
                        var message = new $root.koinos.rpc.block_store.get_blocks_by_id_request();
                        if (object.block_ids) {
                            if (!Array.isArray(object.block_ids))
                                throw TypeError(".koinos.rpc.block_store.get_blocks_by_id_request.block_ids: array expected");
                            message.block_ids = [];
                            for (var i = 0; i < object.block_ids.length; ++i)
                                if (typeof object.block_ids[i] === "string")
                                    $util.base64.decode(object.block_ids[i], message.block_ids[i] = $util.newBuffer($util.base64.length(object.block_ids[i])), 0);
                                else if (object.block_ids[i].length)
                                    message.block_ids[i] = object.block_ids[i];
                        }
                        if (object.return_block != null)
                            message.return_block = Boolean(object.return_block);
                        if (object.return_receipt != null)
                            message.return_receipt = Boolean(object.return_receipt);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_blocks_by_id_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @static
                     * @param {koinos.rpc.block_store.get_blocks_by_id_request} message get_blocks_by_id_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_blocks_by_id_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.block_ids = [];
                        if (options.defaults) {
                            object.return_block = false;
                            object.return_receipt = false;
                        }
                        if (message.block_ids && message.block_ids.length) {
                            object.block_ids = [];
                            for (var j = 0; j < message.block_ids.length; ++j)
                                object.block_ids[j] = options.bytes === String ? $util.base64.encode(message.block_ids[j], 0, message.block_ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.block_ids[j]) : message.block_ids[j];
                        }
                        if (message.return_block != null && message.hasOwnProperty("return_block"))
                            object.return_block = message.return_block;
                        if (message.return_receipt != null && message.hasOwnProperty("return_receipt"))
                            object.return_receipt = message.return_receipt;
                        return object;
                    };
    
                    /**
                     * Converts this get_blocks_by_id_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_blocks_by_id_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_blocks_by_id_request;
                })();
    
                block_store.get_blocks_by_id_response = (function() {
    
                    /**
                     * Properties of a get_blocks_by_id_response.
                     * @memberof koinos.rpc.block_store
                     * @interface Iget_blocks_by_id_response
                     * @property {Array.<koinos.block_store.Iblock_item>|null} [block_items] get_blocks_by_id_response block_items
                     */
    
                    /**
                     * Constructs a new get_blocks_by_id_response.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a get_blocks_by_id_response.
                     * @implements Iget_blocks_by_id_response
                     * @constructor
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_response=} [properties] Properties to set
                     */
                    function get_blocks_by_id_response(properties) {
                        this.block_items = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_blocks_by_id_response block_items.
                     * @member {Array.<koinos.block_store.Iblock_item>} block_items
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @instance
                     */
                    get_blocks_by_id_response.prototype.block_items = $util.emptyArray;
    
                    /**
                     * Creates a new get_blocks_by_id_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_response=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_response} get_blocks_by_id_response instance
                     */
                    get_blocks_by_id_response.create = function create(properties) {
                        return new get_blocks_by_id_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_id_response message. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_id_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_response} message get_blocks_by_id_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_id_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.block_items != null && message.block_items.length)
                            for (var i = 0; i < message.block_items.length; ++i)
                                $root.koinos.block_store.block_item.encode(message.block_items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_id_response message, length delimited. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_id_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_id_response} message get_blocks_by_id_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_id_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_blocks_by_id_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_response} get_blocks_by_id_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_id_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.get_blocks_by_id_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.block_items && message.block_items.length))
                                    message.block_items = [];
                                message.block_items.push($root.koinos.block_store.block_item.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_blocks_by_id_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_response} get_blocks_by_id_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_id_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_blocks_by_id_response message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_blocks_by_id_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.block_items != null && message.hasOwnProperty("block_items")) {
                            if (!Array.isArray(message.block_items))
                                return "block_items: array expected";
                            for (var i = 0; i < message.block_items.length; ++i) {
                                var error = $root.koinos.block_store.block_item.verify(message.block_items[i]);
                                if (error)
                                    return "block_items." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_blocks_by_id_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.get_blocks_by_id_response} get_blocks_by_id_response
                     */
                    get_blocks_by_id_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.get_blocks_by_id_response)
                            return object;
                        var message = new $root.koinos.rpc.block_store.get_blocks_by_id_response();
                        if (object.block_items) {
                            if (!Array.isArray(object.block_items))
                                throw TypeError(".koinos.rpc.block_store.get_blocks_by_id_response.block_items: array expected");
                            message.block_items = [];
                            for (var i = 0; i < object.block_items.length; ++i) {
                                if (typeof object.block_items[i] !== "object")
                                    throw TypeError(".koinos.rpc.block_store.get_blocks_by_id_response.block_items: object expected");
                                message.block_items[i] = $root.koinos.block_store.block_item.fromObject(object.block_items[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_blocks_by_id_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @static
                     * @param {koinos.rpc.block_store.get_blocks_by_id_response} message get_blocks_by_id_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_blocks_by_id_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.block_items = [];
                        if (message.block_items && message.block_items.length) {
                            object.block_items = [];
                            for (var j = 0; j < message.block_items.length; ++j)
                                object.block_items[j] = $root.koinos.block_store.block_item.toObject(message.block_items[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_blocks_by_id_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.get_blocks_by_id_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_blocks_by_id_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_blocks_by_id_response;
                })();
    
                block_store.get_blocks_by_height_request = (function() {
    
                    /**
                     * Properties of a get_blocks_by_height_request.
                     * @memberof koinos.rpc.block_store
                     * @interface Iget_blocks_by_height_request
                     * @property {Uint8Array|null} [head_block_id] get_blocks_by_height_request head_block_id
                     * @property {number|Long|null} [ancestor_start_height] get_blocks_by_height_request ancestor_start_height
                     * @property {number|null} [num_blocks] get_blocks_by_height_request num_blocks
                     * @property {boolean|null} [return_block] get_blocks_by_height_request return_block
                     * @property {boolean|null} [return_receipt] get_blocks_by_height_request return_receipt
                     */
    
                    /**
                     * Constructs a new get_blocks_by_height_request.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a get_blocks_by_height_request.
                     * @implements Iget_blocks_by_height_request
                     * @constructor
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_request=} [properties] Properties to set
                     */
                    function get_blocks_by_height_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_blocks_by_height_request head_block_id.
                     * @member {Uint8Array} head_block_id
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @instance
                     */
                    get_blocks_by_height_request.prototype.head_block_id = $util.newBuffer([]);
    
                    /**
                     * get_blocks_by_height_request ancestor_start_height.
                     * @member {number|Long} ancestor_start_height
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @instance
                     */
                    get_blocks_by_height_request.prototype.ancestor_start_height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * get_blocks_by_height_request num_blocks.
                     * @member {number} num_blocks
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @instance
                     */
                    get_blocks_by_height_request.prototype.num_blocks = 0;
    
                    /**
                     * get_blocks_by_height_request return_block.
                     * @member {boolean} return_block
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @instance
                     */
                    get_blocks_by_height_request.prototype.return_block = false;
    
                    /**
                     * get_blocks_by_height_request return_receipt.
                     * @member {boolean} return_receipt
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @instance
                     */
                    get_blocks_by_height_request.prototype.return_receipt = false;
    
                    /**
                     * Creates a new get_blocks_by_height_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_request=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_request} get_blocks_by_height_request instance
                     */
                    get_blocks_by_height_request.create = function create(properties) {
                        return new get_blocks_by_height_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_height_request message. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_height_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_request} message get_blocks_by_height_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_height_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.head_block_id != null && Object.hasOwnProperty.call(message, "head_block_id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.head_block_id);
                        if (message.ancestor_start_height != null && Object.hasOwnProperty.call(message, "ancestor_start_height"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ancestor_start_height);
                        if (message.num_blocks != null && Object.hasOwnProperty.call(message, "num_blocks"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.num_blocks);
                        if (message.return_block != null && Object.hasOwnProperty.call(message, "return_block"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.return_block);
                        if (message.return_receipt != null && Object.hasOwnProperty.call(message, "return_receipt"))
                            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.return_receipt);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_height_request message, length delimited. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_height_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_request} message get_blocks_by_height_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_height_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_blocks_by_height_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_request} get_blocks_by_height_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_height_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.get_blocks_by_height_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.head_block_id = reader.bytes();
                                break;
                            case 2:
                                message.ancestor_start_height = reader.uint64();
                                break;
                            case 3:
                                message.num_blocks = reader.uint32();
                                break;
                            case 4:
                                message.return_block = reader.bool();
                                break;
                            case 5:
                                message.return_receipt = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_blocks_by_height_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_request} get_blocks_by_height_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_height_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_blocks_by_height_request message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_blocks_by_height_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.head_block_id != null && message.hasOwnProperty("head_block_id"))
                            if (!(message.head_block_id && typeof message.head_block_id.length === "number" || $util.isString(message.head_block_id)))
                                return "head_block_id: buffer expected";
                        if (message.ancestor_start_height != null && message.hasOwnProperty("ancestor_start_height"))
                            if (!$util.isInteger(message.ancestor_start_height) && !(message.ancestor_start_height && $util.isInteger(message.ancestor_start_height.low) && $util.isInteger(message.ancestor_start_height.high)))
                                return "ancestor_start_height: integer|Long expected";
                        if (message.num_blocks != null && message.hasOwnProperty("num_blocks"))
                            if (!$util.isInteger(message.num_blocks))
                                return "num_blocks: integer expected";
                        if (message.return_block != null && message.hasOwnProperty("return_block"))
                            if (typeof message.return_block !== "boolean")
                                return "return_block: boolean expected";
                        if (message.return_receipt != null && message.hasOwnProperty("return_receipt"))
                            if (typeof message.return_receipt !== "boolean")
                                return "return_receipt: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_blocks_by_height_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_request} get_blocks_by_height_request
                     */
                    get_blocks_by_height_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.get_blocks_by_height_request)
                            return object;
                        var message = new $root.koinos.rpc.block_store.get_blocks_by_height_request();
                        if (object.head_block_id != null)
                            if (typeof object.head_block_id === "string")
                                $util.base64.decode(object.head_block_id, message.head_block_id = $util.newBuffer($util.base64.length(object.head_block_id)), 0);
                            else if (object.head_block_id.length)
                                message.head_block_id = object.head_block_id;
                        if (object.ancestor_start_height != null)
                            if ($util.Long)
                                (message.ancestor_start_height = $util.Long.fromValue(object.ancestor_start_height)).unsigned = true;
                            else if (typeof object.ancestor_start_height === "string")
                                message.ancestor_start_height = parseInt(object.ancestor_start_height, 10);
                            else if (typeof object.ancestor_start_height === "number")
                                message.ancestor_start_height = object.ancestor_start_height;
                            else if (typeof object.ancestor_start_height === "object")
                                message.ancestor_start_height = new $util.LongBits(object.ancestor_start_height.low >>> 0, object.ancestor_start_height.high >>> 0).toNumber(true);
                        if (object.num_blocks != null)
                            message.num_blocks = object.num_blocks >>> 0;
                        if (object.return_block != null)
                            message.return_block = Boolean(object.return_block);
                        if (object.return_receipt != null)
                            message.return_receipt = Boolean(object.return_receipt);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_blocks_by_height_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @static
                     * @param {koinos.rpc.block_store.get_blocks_by_height_request} message get_blocks_by_height_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_blocks_by_height_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.head_block_id = "";
                            else {
                                object.head_block_id = [];
                                if (options.bytes !== Array)
                                    object.head_block_id = $util.newBuffer(object.head_block_id);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.ancestor_start_height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.ancestor_start_height = options.longs === String ? "0" : 0;
                            object.num_blocks = 0;
                            object.return_block = false;
                            object.return_receipt = false;
                        }
                        if (message.head_block_id != null && message.hasOwnProperty("head_block_id"))
                            object.head_block_id = options.bytes === String ? $util.base64.encode(message.head_block_id, 0, message.head_block_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.head_block_id) : message.head_block_id;
                        if (message.ancestor_start_height != null && message.hasOwnProperty("ancestor_start_height"))
                            if (typeof message.ancestor_start_height === "number")
                                object.ancestor_start_height = options.longs === String ? String(message.ancestor_start_height) : message.ancestor_start_height;
                            else
                                object.ancestor_start_height = options.longs === String ? $util.Long.prototype.toString.call(message.ancestor_start_height) : options.longs === Number ? new $util.LongBits(message.ancestor_start_height.low >>> 0, message.ancestor_start_height.high >>> 0).toNumber(true) : message.ancestor_start_height;
                        if (message.num_blocks != null && message.hasOwnProperty("num_blocks"))
                            object.num_blocks = message.num_blocks;
                        if (message.return_block != null && message.hasOwnProperty("return_block"))
                            object.return_block = message.return_block;
                        if (message.return_receipt != null && message.hasOwnProperty("return_receipt"))
                            object.return_receipt = message.return_receipt;
                        return object;
                    };
    
                    /**
                     * Converts this get_blocks_by_height_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_blocks_by_height_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_blocks_by_height_request;
                })();
    
                block_store.get_blocks_by_height_response = (function() {
    
                    /**
                     * Properties of a get_blocks_by_height_response.
                     * @memberof koinos.rpc.block_store
                     * @interface Iget_blocks_by_height_response
                     * @property {Array.<koinos.block_store.Iblock_item>|null} [block_items] get_blocks_by_height_response block_items
                     */
    
                    /**
                     * Constructs a new get_blocks_by_height_response.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a get_blocks_by_height_response.
                     * @implements Iget_blocks_by_height_response
                     * @constructor
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_response=} [properties] Properties to set
                     */
                    function get_blocks_by_height_response(properties) {
                        this.block_items = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_blocks_by_height_response block_items.
                     * @member {Array.<koinos.block_store.Iblock_item>} block_items
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @instance
                     */
                    get_blocks_by_height_response.prototype.block_items = $util.emptyArray;
    
                    /**
                     * Creates a new get_blocks_by_height_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_response=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_response} get_blocks_by_height_response instance
                     */
                    get_blocks_by_height_response.create = function create(properties) {
                        return new get_blocks_by_height_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_height_response message. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_height_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_response} message get_blocks_by_height_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_height_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.block_items != null && message.block_items.length)
                            for (var i = 0; i < message.block_items.length; ++i)
                                $root.koinos.block_store.block_item.encode(message.block_items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_blocks_by_height_response message, length delimited. Does not implicitly {@link koinos.rpc.block_store.get_blocks_by_height_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_blocks_by_height_response} message get_blocks_by_height_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_blocks_by_height_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_blocks_by_height_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_response} get_blocks_by_height_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_height_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.get_blocks_by_height_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.block_items && message.block_items.length))
                                    message.block_items = [];
                                message.block_items.push($root.koinos.block_store.block_item.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_blocks_by_height_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_response} get_blocks_by_height_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_blocks_by_height_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_blocks_by_height_response message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_blocks_by_height_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.block_items != null && message.hasOwnProperty("block_items")) {
                            if (!Array.isArray(message.block_items))
                                return "block_items: array expected";
                            for (var i = 0; i < message.block_items.length; ++i) {
                                var error = $root.koinos.block_store.block_item.verify(message.block_items[i]);
                                if (error)
                                    return "block_items." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_blocks_by_height_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.get_blocks_by_height_response} get_blocks_by_height_response
                     */
                    get_blocks_by_height_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.get_blocks_by_height_response)
                            return object;
                        var message = new $root.koinos.rpc.block_store.get_blocks_by_height_response();
                        if (object.block_items) {
                            if (!Array.isArray(object.block_items))
                                throw TypeError(".koinos.rpc.block_store.get_blocks_by_height_response.block_items: array expected");
                            message.block_items = [];
                            for (var i = 0; i < object.block_items.length; ++i) {
                                if (typeof object.block_items[i] !== "object")
                                    throw TypeError(".koinos.rpc.block_store.get_blocks_by_height_response.block_items: object expected");
                                message.block_items[i] = $root.koinos.block_store.block_item.fromObject(object.block_items[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_blocks_by_height_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @static
                     * @param {koinos.rpc.block_store.get_blocks_by_height_response} message get_blocks_by_height_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_blocks_by_height_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.block_items = [];
                        if (message.block_items && message.block_items.length) {
                            object.block_items = [];
                            for (var j = 0; j < message.block_items.length; ++j)
                                object.block_items[j] = $root.koinos.block_store.block_item.toObject(message.block_items[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_blocks_by_height_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.get_blocks_by_height_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_blocks_by_height_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_blocks_by_height_response;
                })();
    
                block_store.add_block_request = (function() {
    
                    /**
                     * Properties of an add_block_request.
                     * @memberof koinos.rpc.block_store
                     * @interface Iadd_block_request
                     * @property {koinos.protocol.Iblock|null} [block_to_add] add_block_request block_to_add
                     * @property {koinos.protocol.Iblock_receipt|null} [receipt_to_add] add_block_request receipt_to_add
                     */
    
                    /**
                     * Constructs a new add_block_request.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents an add_block_request.
                     * @implements Iadd_block_request
                     * @constructor
                     * @param {koinos.rpc.block_store.Iadd_block_request=} [properties] Properties to set
                     */
                    function add_block_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * add_block_request block_to_add.
                     * @member {koinos.protocol.Iblock|null|undefined} block_to_add
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @instance
                     */
                    add_block_request.prototype.block_to_add = null;
    
                    /**
                     * add_block_request receipt_to_add.
                     * @member {koinos.protocol.Iblock_receipt|null|undefined} receipt_to_add
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @instance
                     */
                    add_block_request.prototype.receipt_to_add = null;
    
                    /**
                     * Creates a new add_block_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {koinos.rpc.block_store.Iadd_block_request=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.add_block_request} add_block_request instance
                     */
                    add_block_request.create = function create(properties) {
                        return new add_block_request(properties);
                    };
    
                    /**
                     * Encodes the specified add_block_request message. Does not implicitly {@link koinos.rpc.block_store.add_block_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {koinos.rpc.block_store.Iadd_block_request} message add_block_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    add_block_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.block_to_add != null && Object.hasOwnProperty.call(message, "block_to_add"))
                            $root.koinos.protocol.block.encode(message.block_to_add, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.receipt_to_add != null && Object.hasOwnProperty.call(message, "receipt_to_add"))
                            $root.koinos.protocol.block_receipt.encode(message.receipt_to_add, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified add_block_request message, length delimited. Does not implicitly {@link koinos.rpc.block_store.add_block_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {koinos.rpc.block_store.Iadd_block_request} message add_block_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    add_block_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an add_block_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.add_block_request} add_block_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    add_block_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.add_block_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.block_to_add = $root.koinos.protocol.block.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.receipt_to_add = $root.koinos.protocol.block_receipt.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an add_block_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.add_block_request} add_block_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    add_block_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an add_block_request message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    add_block_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.block_to_add != null && message.hasOwnProperty("block_to_add")) {
                            var error = $root.koinos.protocol.block.verify(message.block_to_add);
                            if (error)
                                return "block_to_add." + error;
                        }
                        if (message.receipt_to_add != null && message.hasOwnProperty("receipt_to_add")) {
                            var error = $root.koinos.protocol.block_receipt.verify(message.receipt_to_add);
                            if (error)
                                return "receipt_to_add." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates an add_block_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.add_block_request} add_block_request
                     */
                    add_block_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.add_block_request)
                            return object;
                        var message = new $root.koinos.rpc.block_store.add_block_request();
                        if (object.block_to_add != null) {
                            if (typeof object.block_to_add !== "object")
                                throw TypeError(".koinos.rpc.block_store.add_block_request.block_to_add: object expected");
                            message.block_to_add = $root.koinos.protocol.block.fromObject(object.block_to_add);
                        }
                        if (object.receipt_to_add != null) {
                            if (typeof object.receipt_to_add !== "object")
                                throw TypeError(".koinos.rpc.block_store.add_block_request.receipt_to_add: object expected");
                            message.receipt_to_add = $root.koinos.protocol.block_receipt.fromObject(object.receipt_to_add);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an add_block_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @static
                     * @param {koinos.rpc.block_store.add_block_request} message add_block_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    add_block_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.block_to_add = null;
                            object.receipt_to_add = null;
                        }
                        if (message.block_to_add != null && message.hasOwnProperty("block_to_add"))
                            object.block_to_add = $root.koinos.protocol.block.toObject(message.block_to_add, options);
                        if (message.receipt_to_add != null && message.hasOwnProperty("receipt_to_add"))
                            object.receipt_to_add = $root.koinos.protocol.block_receipt.toObject(message.receipt_to_add, options);
                        return object;
                    };
    
                    /**
                     * Converts this add_block_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.add_block_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    add_block_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return add_block_request;
                })();
    
                block_store.add_block_response = (function() {
    
                    /**
                     * Properties of an add_block_response.
                     * @memberof koinos.rpc.block_store
                     * @interface Iadd_block_response
                     */
    
                    /**
                     * Constructs a new add_block_response.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents an add_block_response.
                     * @implements Iadd_block_response
                     * @constructor
                     * @param {koinos.rpc.block_store.Iadd_block_response=} [properties] Properties to set
                     */
                    function add_block_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new add_block_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {koinos.rpc.block_store.Iadd_block_response=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.add_block_response} add_block_response instance
                     */
                    add_block_response.create = function create(properties) {
                        return new add_block_response(properties);
                    };
    
                    /**
                     * Encodes the specified add_block_response message. Does not implicitly {@link koinos.rpc.block_store.add_block_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {koinos.rpc.block_store.Iadd_block_response} message add_block_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    add_block_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified add_block_response message, length delimited. Does not implicitly {@link koinos.rpc.block_store.add_block_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {koinos.rpc.block_store.Iadd_block_response} message add_block_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    add_block_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an add_block_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.add_block_response} add_block_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    add_block_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.add_block_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an add_block_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.add_block_response} add_block_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    add_block_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an add_block_response message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    add_block_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates an add_block_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.add_block_response} add_block_response
                     */
                    add_block_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.add_block_response)
                            return object;
                        return new $root.koinos.rpc.block_store.add_block_response();
                    };
    
                    /**
                     * Creates a plain object from an add_block_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @static
                     * @param {koinos.rpc.block_store.add_block_response} message add_block_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    add_block_response.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this add_block_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.add_block_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    add_block_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return add_block_response;
                })();
    
                block_store.get_highest_block_request = (function() {
    
                    /**
                     * Properties of a get_highest_block_request.
                     * @memberof koinos.rpc.block_store
                     * @interface Iget_highest_block_request
                     */
    
                    /**
                     * Constructs a new get_highest_block_request.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a get_highest_block_request.
                     * @implements Iget_highest_block_request
                     * @constructor
                     * @param {koinos.rpc.block_store.Iget_highest_block_request=} [properties] Properties to set
                     */
                    function get_highest_block_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_highest_block_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_highest_block_request=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.get_highest_block_request} get_highest_block_request instance
                     */
                    get_highest_block_request.create = function create(properties) {
                        return new get_highest_block_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_highest_block_request message. Does not implicitly {@link koinos.rpc.block_store.get_highest_block_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_highest_block_request} message get_highest_block_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_highest_block_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_highest_block_request message, length delimited. Does not implicitly {@link koinos.rpc.block_store.get_highest_block_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {koinos.rpc.block_store.Iget_highest_block_request} message get_highest_block_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_highest_block_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_highest_block_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.get_highest_block_request} get_highest_block_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_highest_block_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.get_highest_block_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_highest_block_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.get_highest_block_request} get_highest_block_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_highest_block_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_highest_block_request message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_highest_block_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_highest_block_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.get_highest_block_request} get_highest_block_request
                     */
                    get_highest_block_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.get_highest_block_request)
                            return object;
                        return new $root.koinos.rpc.block_store.get_highest_block_request();
                    };
    
                    /**
                     * Creates a plain object from a get_highest_block_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @static
                     * @param {koinos.rpc.block_store.get_highest_block_request} message get_highest_block_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_highest_block_request.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_highest_block_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.get_highest_block_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_highest_block_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_highest_block_request;
                })();
    
                block_store.get_highest_block_response = (function() {
    
                    /**
                     * Properties of a get_highest_block_response.
                     * @memberof koinos.rpc.block_store
                     * @interface Iget_highest_block_response
                     * @property {koinos.Iblock_topology|null} [topology] get_highest_block_response topology
                     */
    
                    /**
                     * Constructs a new get_highest_block_response.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a get_highest_block_response.
                     * @implements Iget_highest_block_response
                     * @constructor
                     * @param {koinos.rpc.block_store.Iget_highest_block_response=} [properties] Properties to set
                     */
                    function get_highest_block_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_highest_block_response topology.
                     * @member {koinos.Iblock_topology|null|undefined} topology
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @instance
                     */
                    get_highest_block_response.prototype.topology = null;
    
                    /**
                     * Creates a new get_highest_block_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_highest_block_response=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.get_highest_block_response} get_highest_block_response instance
                     */
                    get_highest_block_response.create = function create(properties) {
                        return new get_highest_block_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_highest_block_response message. Does not implicitly {@link koinos.rpc.block_store.get_highest_block_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_highest_block_response} message get_highest_block_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_highest_block_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.topology != null && Object.hasOwnProperty.call(message, "topology"))
                            $root.koinos.block_topology.encode(message.topology, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_highest_block_response message, length delimited. Does not implicitly {@link koinos.rpc.block_store.get_highest_block_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {koinos.rpc.block_store.Iget_highest_block_response} message get_highest_block_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_highest_block_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_highest_block_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.get_highest_block_response} get_highest_block_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_highest_block_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.get_highest_block_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.topology = $root.koinos.block_topology.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_highest_block_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.get_highest_block_response} get_highest_block_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_highest_block_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_highest_block_response message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_highest_block_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.topology != null && message.hasOwnProperty("topology")) {
                            var error = $root.koinos.block_topology.verify(message.topology);
                            if (error)
                                return "topology." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_highest_block_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.get_highest_block_response} get_highest_block_response
                     */
                    get_highest_block_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.get_highest_block_response)
                            return object;
                        var message = new $root.koinos.rpc.block_store.get_highest_block_response();
                        if (object.topology != null) {
                            if (typeof object.topology !== "object")
                                throw TypeError(".koinos.rpc.block_store.get_highest_block_response.topology: object expected");
                            message.topology = $root.koinos.block_topology.fromObject(object.topology);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_highest_block_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @static
                     * @param {koinos.rpc.block_store.get_highest_block_response} message get_highest_block_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_highest_block_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.topology = null;
                        if (message.topology != null && message.hasOwnProperty("topology"))
                            object.topology = $root.koinos.block_topology.toObject(message.topology, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_highest_block_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.get_highest_block_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_highest_block_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_highest_block_response;
                })();
    
                block_store.block_store_request = (function() {
    
                    /**
                     * Properties of a block_store_request.
                     * @memberof koinos.rpc.block_store
                     * @interface Iblock_store_request
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] block_store_request reserved
                     * @property {koinos.rpc.block_store.Iget_blocks_by_id_request|null} [get_blocks_by_id] block_store_request get_blocks_by_id
                     * @property {koinos.rpc.block_store.Iget_blocks_by_height_request|null} [get_blocks_by_height] block_store_request get_blocks_by_height
                     * @property {koinos.rpc.block_store.Iadd_block_request|null} [add_block] block_store_request add_block
                     * @property {koinos.rpc.block_store.Iget_highest_block_request|null} [get_highest_block] block_store_request get_highest_block
                     */
    
                    /**
                     * Constructs a new block_store_request.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a block_store_request.
                     * @implements Iblock_store_request
                     * @constructor
                     * @param {koinos.rpc.block_store.Iblock_store_request=} [properties] Properties to set
                     */
                    function block_store_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * block_store_request reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     */
                    block_store_request.prototype.reserved = null;
    
                    /**
                     * block_store_request get_blocks_by_id.
                     * @member {koinos.rpc.block_store.Iget_blocks_by_id_request|null|undefined} get_blocks_by_id
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     */
                    block_store_request.prototype.get_blocks_by_id = null;
    
                    /**
                     * block_store_request get_blocks_by_height.
                     * @member {koinos.rpc.block_store.Iget_blocks_by_height_request|null|undefined} get_blocks_by_height
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     */
                    block_store_request.prototype.get_blocks_by_height = null;
    
                    /**
                     * block_store_request add_block.
                     * @member {koinos.rpc.block_store.Iadd_block_request|null|undefined} add_block
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     */
                    block_store_request.prototype.add_block = null;
    
                    /**
                     * block_store_request get_highest_block.
                     * @member {koinos.rpc.block_store.Iget_highest_block_request|null|undefined} get_highest_block
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     */
                    block_store_request.prototype.get_highest_block = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * block_store_request request.
                     * @member {"reserved"|"get_blocks_by_id"|"get_blocks_by_height"|"add_block"|"get_highest_block"|undefined} request
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     */
                    Object.defineProperty(block_store_request.prototype, "request", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "get_blocks_by_id", "get_blocks_by_height", "add_block", "get_highest_block"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new block_store_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {koinos.rpc.block_store.Iblock_store_request=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.block_store_request} block_store_request instance
                     */
                    block_store_request.create = function create(properties) {
                        return new block_store_request(properties);
                    };
    
                    /**
                     * Encodes the specified block_store_request message. Does not implicitly {@link koinos.rpc.block_store.block_store_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {koinos.rpc.block_store.Iblock_store_request} message block_store_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    block_store_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.get_blocks_by_id != null && Object.hasOwnProperty.call(message, "get_blocks_by_id"))
                            $root.koinos.rpc.block_store.get_blocks_by_id_request.encode(message.get_blocks_by_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.get_blocks_by_height != null && Object.hasOwnProperty.call(message, "get_blocks_by_height"))
                            $root.koinos.rpc.block_store.get_blocks_by_height_request.encode(message.get_blocks_by_height, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.add_block != null && Object.hasOwnProperty.call(message, "add_block"))
                            $root.koinos.rpc.block_store.add_block_request.encode(message.add_block, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.get_highest_block != null && Object.hasOwnProperty.call(message, "get_highest_block"))
                            $root.koinos.rpc.block_store.get_highest_block_request.encode(message.get_highest_block, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified block_store_request message, length delimited. Does not implicitly {@link koinos.rpc.block_store.block_store_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {koinos.rpc.block_store.Iblock_store_request} message block_store_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    block_store_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a block_store_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.block_store_request} block_store_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    block_store_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.block_store_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.get_blocks_by_id = $root.koinos.rpc.block_store.get_blocks_by_id_request.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.get_blocks_by_height = $root.koinos.rpc.block_store.get_blocks_by_height_request.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.add_block = $root.koinos.rpc.block_store.add_block_request.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.get_highest_block = $root.koinos.rpc.block_store.get_highest_block_request.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a block_store_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.block_store_request} block_store_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    block_store_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a block_store_request message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    block_store_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.get_blocks_by_id != null && message.hasOwnProperty("get_blocks_by_id")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.block_store.get_blocks_by_id_request.verify(message.get_blocks_by_id);
                                if (error)
                                    return "get_blocks_by_id." + error;
                            }
                        }
                        if (message.get_blocks_by_height != null && message.hasOwnProperty("get_blocks_by_height")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.block_store.get_blocks_by_height_request.verify(message.get_blocks_by_height);
                                if (error)
                                    return "get_blocks_by_height." + error;
                            }
                        }
                        if (message.add_block != null && message.hasOwnProperty("add_block")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.block_store.add_block_request.verify(message.add_block);
                                if (error)
                                    return "add_block." + error;
                            }
                        }
                        if (message.get_highest_block != null && message.hasOwnProperty("get_highest_block")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.block_store.get_highest_block_request.verify(message.get_highest_block);
                                if (error)
                                    return "get_highest_block." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a block_store_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.block_store_request} block_store_request
                     */
                    block_store_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.block_store_request)
                            return object;
                        var message = new $root.koinos.rpc.block_store.block_store_request();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_request.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.get_blocks_by_id != null) {
                            if (typeof object.get_blocks_by_id !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_request.get_blocks_by_id: object expected");
                            message.get_blocks_by_id = $root.koinos.rpc.block_store.get_blocks_by_id_request.fromObject(object.get_blocks_by_id);
                        }
                        if (object.get_blocks_by_height != null) {
                            if (typeof object.get_blocks_by_height !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_request.get_blocks_by_height: object expected");
                            message.get_blocks_by_height = $root.koinos.rpc.block_store.get_blocks_by_height_request.fromObject(object.get_blocks_by_height);
                        }
                        if (object.add_block != null) {
                            if (typeof object.add_block !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_request.add_block: object expected");
                            message.add_block = $root.koinos.rpc.block_store.add_block_request.fromObject(object.add_block);
                        }
                        if (object.get_highest_block != null) {
                            if (typeof object.get_highest_block !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_request.get_highest_block: object expected");
                            message.get_highest_block = $root.koinos.rpc.block_store.get_highest_block_request.fromObject(object.get_highest_block);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a block_store_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @static
                     * @param {koinos.rpc.block_store.block_store_request} message block_store_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    block_store_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.request = "reserved";
                        }
                        if (message.get_blocks_by_id != null && message.hasOwnProperty("get_blocks_by_id")) {
                            object.get_blocks_by_id = $root.koinos.rpc.block_store.get_blocks_by_id_request.toObject(message.get_blocks_by_id, options);
                            if (options.oneofs)
                                object.request = "get_blocks_by_id";
                        }
                        if (message.get_blocks_by_height != null && message.hasOwnProperty("get_blocks_by_height")) {
                            object.get_blocks_by_height = $root.koinos.rpc.block_store.get_blocks_by_height_request.toObject(message.get_blocks_by_height, options);
                            if (options.oneofs)
                                object.request = "get_blocks_by_height";
                        }
                        if (message.add_block != null && message.hasOwnProperty("add_block")) {
                            object.add_block = $root.koinos.rpc.block_store.add_block_request.toObject(message.add_block, options);
                            if (options.oneofs)
                                object.request = "add_block";
                        }
                        if (message.get_highest_block != null && message.hasOwnProperty("get_highest_block")) {
                            object.get_highest_block = $root.koinos.rpc.block_store.get_highest_block_request.toObject(message.get_highest_block, options);
                            if (options.oneofs)
                                object.request = "get_highest_block";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this block_store_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.block_store_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    block_store_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return block_store_request;
                })();
    
                block_store.block_store_response = (function() {
    
                    /**
                     * Properties of a block_store_response.
                     * @memberof koinos.rpc.block_store
                     * @interface Iblock_store_response
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] block_store_response reserved
                     * @property {koinos.rpc.Ierror_response|null} [error] block_store_response error
                     * @property {koinos.rpc.block_store.Iget_blocks_by_id_response|null} [get_blocks_by_id] block_store_response get_blocks_by_id
                     * @property {koinos.rpc.block_store.Iget_blocks_by_height_response|null} [get_blocks_by_height] block_store_response get_blocks_by_height
                     * @property {koinos.rpc.block_store.Iadd_block_response|null} [add_block] block_store_response add_block
                     * @property {koinos.rpc.block_store.Iget_highest_block_response|null} [get_highest_block] block_store_response get_highest_block
                     */
    
                    /**
                     * Constructs a new block_store_response.
                     * @memberof koinos.rpc.block_store
                     * @classdesc Represents a block_store_response.
                     * @implements Iblock_store_response
                     * @constructor
                     * @param {koinos.rpc.block_store.Iblock_store_response=} [properties] Properties to set
                     */
                    function block_store_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * block_store_response reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    block_store_response.prototype.reserved = null;
    
                    /**
                     * block_store_response error.
                     * @member {koinos.rpc.Ierror_response|null|undefined} error
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    block_store_response.prototype.error = null;
    
                    /**
                     * block_store_response get_blocks_by_id.
                     * @member {koinos.rpc.block_store.Iget_blocks_by_id_response|null|undefined} get_blocks_by_id
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    block_store_response.prototype.get_blocks_by_id = null;
    
                    /**
                     * block_store_response get_blocks_by_height.
                     * @member {koinos.rpc.block_store.Iget_blocks_by_height_response|null|undefined} get_blocks_by_height
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    block_store_response.prototype.get_blocks_by_height = null;
    
                    /**
                     * block_store_response add_block.
                     * @member {koinos.rpc.block_store.Iadd_block_response|null|undefined} add_block
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    block_store_response.prototype.add_block = null;
    
                    /**
                     * block_store_response get_highest_block.
                     * @member {koinos.rpc.block_store.Iget_highest_block_response|null|undefined} get_highest_block
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    block_store_response.prototype.get_highest_block = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * block_store_response response.
                     * @member {"reserved"|"error"|"get_blocks_by_id"|"get_blocks_by_height"|"add_block"|"get_highest_block"|undefined} response
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     */
                    Object.defineProperty(block_store_response.prototype, "response", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "error", "get_blocks_by_id", "get_blocks_by_height", "add_block", "get_highest_block"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new block_store_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {koinos.rpc.block_store.Iblock_store_response=} [properties] Properties to set
                     * @returns {koinos.rpc.block_store.block_store_response} block_store_response instance
                     */
                    block_store_response.create = function create(properties) {
                        return new block_store_response(properties);
                    };
    
                    /**
                     * Encodes the specified block_store_response message. Does not implicitly {@link koinos.rpc.block_store.block_store_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {koinos.rpc.block_store.Iblock_store_response} message block_store_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    block_store_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.koinos.rpc.error_response.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.get_blocks_by_id != null && Object.hasOwnProperty.call(message, "get_blocks_by_id"))
                            $root.koinos.rpc.block_store.get_blocks_by_id_response.encode(message.get_blocks_by_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.get_blocks_by_height != null && Object.hasOwnProperty.call(message, "get_blocks_by_height"))
                            $root.koinos.rpc.block_store.get_blocks_by_height_response.encode(message.get_blocks_by_height, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.add_block != null && Object.hasOwnProperty.call(message, "add_block"))
                            $root.koinos.rpc.block_store.add_block_response.encode(message.add_block, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.get_highest_block != null && Object.hasOwnProperty.call(message, "get_highest_block"))
                            $root.koinos.rpc.block_store.get_highest_block_response.encode(message.get_highest_block, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified block_store_response message, length delimited. Does not implicitly {@link koinos.rpc.block_store.block_store_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {koinos.rpc.block_store.Iblock_store_response} message block_store_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    block_store_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a block_store_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.block_store.block_store_response} block_store_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    block_store_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.block_store.block_store_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.error = $root.koinos.rpc.error_response.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.get_blocks_by_id = $root.koinos.rpc.block_store.get_blocks_by_id_response.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.get_blocks_by_height = $root.koinos.rpc.block_store.get_blocks_by_height_response.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.add_block = $root.koinos.rpc.block_store.add_block_response.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.get_highest_block = $root.koinos.rpc.block_store.get_highest_block_response.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a block_store_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.block_store.block_store_response} block_store_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    block_store_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a block_store_response message.
                     * @function verify
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    block_store_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.error_response.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.get_blocks_by_id != null && message.hasOwnProperty("get_blocks_by_id")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.block_store.get_blocks_by_id_response.verify(message.get_blocks_by_id);
                                if (error)
                                    return "get_blocks_by_id." + error;
                            }
                        }
                        if (message.get_blocks_by_height != null && message.hasOwnProperty("get_blocks_by_height")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.block_store.get_blocks_by_height_response.verify(message.get_blocks_by_height);
                                if (error)
                                    return "get_blocks_by_height." + error;
                            }
                        }
                        if (message.add_block != null && message.hasOwnProperty("add_block")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.block_store.add_block_response.verify(message.add_block);
                                if (error)
                                    return "add_block." + error;
                            }
                        }
                        if (message.get_highest_block != null && message.hasOwnProperty("get_highest_block")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.block_store.get_highest_block_response.verify(message.get_highest_block);
                                if (error)
                                    return "get_highest_block." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a block_store_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.block_store.block_store_response} block_store_response
                     */
                    block_store_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.block_store.block_store_response)
                            return object;
                        var message = new $root.koinos.rpc.block_store.block_store_response();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_response.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_response.error: object expected");
                            message.error = $root.koinos.rpc.error_response.fromObject(object.error);
                        }
                        if (object.get_blocks_by_id != null) {
                            if (typeof object.get_blocks_by_id !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_response.get_blocks_by_id: object expected");
                            message.get_blocks_by_id = $root.koinos.rpc.block_store.get_blocks_by_id_response.fromObject(object.get_blocks_by_id);
                        }
                        if (object.get_blocks_by_height != null) {
                            if (typeof object.get_blocks_by_height !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_response.get_blocks_by_height: object expected");
                            message.get_blocks_by_height = $root.koinos.rpc.block_store.get_blocks_by_height_response.fromObject(object.get_blocks_by_height);
                        }
                        if (object.add_block != null) {
                            if (typeof object.add_block !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_response.add_block: object expected");
                            message.add_block = $root.koinos.rpc.block_store.add_block_response.fromObject(object.add_block);
                        }
                        if (object.get_highest_block != null) {
                            if (typeof object.get_highest_block !== "object")
                                throw TypeError(".koinos.rpc.block_store.block_store_response.get_highest_block: object expected");
                            message.get_highest_block = $root.koinos.rpc.block_store.get_highest_block_response.fromObject(object.get_highest_block);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a block_store_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @static
                     * @param {koinos.rpc.block_store.block_store_response} message block_store_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    block_store_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.response = "reserved";
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.koinos.rpc.error_response.toObject(message.error, options);
                            if (options.oneofs)
                                object.response = "error";
                        }
                        if (message.get_blocks_by_id != null && message.hasOwnProperty("get_blocks_by_id")) {
                            object.get_blocks_by_id = $root.koinos.rpc.block_store.get_blocks_by_id_response.toObject(message.get_blocks_by_id, options);
                            if (options.oneofs)
                                object.response = "get_blocks_by_id";
                        }
                        if (message.get_blocks_by_height != null && message.hasOwnProperty("get_blocks_by_height")) {
                            object.get_blocks_by_height = $root.koinos.rpc.block_store.get_blocks_by_height_response.toObject(message.get_blocks_by_height, options);
                            if (options.oneofs)
                                object.response = "get_blocks_by_height";
                        }
                        if (message.add_block != null && message.hasOwnProperty("add_block")) {
                            object.add_block = $root.koinos.rpc.block_store.add_block_response.toObject(message.add_block, options);
                            if (options.oneofs)
                                object.response = "add_block";
                        }
                        if (message.get_highest_block != null && message.hasOwnProperty("get_highest_block")) {
                            object.get_highest_block = $root.koinos.rpc.block_store.get_highest_block_response.toObject(message.get_highest_block, options);
                            if (options.oneofs)
                                object.response = "get_highest_block";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this block_store_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.block_store.block_store_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    block_store_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return block_store_response;
                })();
    
                return block_store;
            })();
    
            rpc.p2p = (function() {
    
                /**
                 * Namespace p2p.
                 * @memberof koinos.rpc
                 * @namespace
                 */
                var p2p = {};
    
                p2p.get_gossip_status_request = (function() {
    
                    /**
                     * Properties of a get_gossip_status_request.
                     * @memberof koinos.rpc.p2p
                     * @interface Iget_gossip_status_request
                     */
    
                    /**
                     * Constructs a new get_gossip_status_request.
                     * @memberof koinos.rpc.p2p
                     * @classdesc Represents a get_gossip_status_request.
                     * @implements Iget_gossip_status_request
                     * @constructor
                     * @param {koinos.rpc.p2p.Iget_gossip_status_request=} [properties] Properties to set
                     */
                    function get_gossip_status_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_gossip_status_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {koinos.rpc.p2p.Iget_gossip_status_request=} [properties] Properties to set
                     * @returns {koinos.rpc.p2p.get_gossip_status_request} get_gossip_status_request instance
                     */
                    get_gossip_status_request.create = function create(properties) {
                        return new get_gossip_status_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_gossip_status_request message. Does not implicitly {@link koinos.rpc.p2p.get_gossip_status_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {koinos.rpc.p2p.Iget_gossip_status_request} message get_gossip_status_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_gossip_status_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_gossip_status_request message, length delimited. Does not implicitly {@link koinos.rpc.p2p.get_gossip_status_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {koinos.rpc.p2p.Iget_gossip_status_request} message get_gossip_status_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_gossip_status_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_gossip_status_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.p2p.get_gossip_status_request} get_gossip_status_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_gossip_status_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.p2p.get_gossip_status_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_gossip_status_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.p2p.get_gossip_status_request} get_gossip_status_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_gossip_status_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_gossip_status_request message.
                     * @function verify
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_gossip_status_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_gossip_status_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.p2p.get_gossip_status_request} get_gossip_status_request
                     */
                    get_gossip_status_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.p2p.get_gossip_status_request)
                            return object;
                        return new $root.koinos.rpc.p2p.get_gossip_status_request();
                    };
    
                    /**
                     * Creates a plain object from a get_gossip_status_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @static
                     * @param {koinos.rpc.p2p.get_gossip_status_request} message get_gossip_status_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_gossip_status_request.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_gossip_status_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.p2p.get_gossip_status_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_gossip_status_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_gossip_status_request;
                })();
    
                p2p.get_gossip_status_response = (function() {
    
                    /**
                     * Properties of a get_gossip_status_response.
                     * @memberof koinos.rpc.p2p
                     * @interface Iget_gossip_status_response
                     * @property {boolean|null} [enabled] get_gossip_status_response enabled
                     */
    
                    /**
                     * Constructs a new get_gossip_status_response.
                     * @memberof koinos.rpc.p2p
                     * @classdesc Represents a get_gossip_status_response.
                     * @implements Iget_gossip_status_response
                     * @constructor
                     * @param {koinos.rpc.p2p.Iget_gossip_status_response=} [properties] Properties to set
                     */
                    function get_gossip_status_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_gossip_status_response enabled.
                     * @member {boolean} enabled
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @instance
                     */
                    get_gossip_status_response.prototype.enabled = false;
    
                    /**
                     * Creates a new get_gossip_status_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {koinos.rpc.p2p.Iget_gossip_status_response=} [properties] Properties to set
                     * @returns {koinos.rpc.p2p.get_gossip_status_response} get_gossip_status_response instance
                     */
                    get_gossip_status_response.create = function create(properties) {
                        return new get_gossip_status_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_gossip_status_response message. Does not implicitly {@link koinos.rpc.p2p.get_gossip_status_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {koinos.rpc.p2p.Iget_gossip_status_response} message get_gossip_status_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_gossip_status_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_gossip_status_response message, length delimited. Does not implicitly {@link koinos.rpc.p2p.get_gossip_status_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {koinos.rpc.p2p.Iget_gossip_status_response} message get_gossip_status_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_gossip_status_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_gossip_status_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.p2p.get_gossip_status_response} get_gossip_status_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_gossip_status_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.p2p.get_gossip_status_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.enabled = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_gossip_status_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.p2p.get_gossip_status_response} get_gossip_status_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_gossip_status_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_gossip_status_response message.
                     * @function verify
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_gossip_status_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            if (typeof message.enabled !== "boolean")
                                return "enabled: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_gossip_status_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.p2p.get_gossip_status_response} get_gossip_status_response
                     */
                    get_gossip_status_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.p2p.get_gossip_status_response)
                            return object;
                        var message = new $root.koinos.rpc.p2p.get_gossip_status_response();
                        if (object.enabled != null)
                            message.enabled = Boolean(object.enabled);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_gossip_status_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @static
                     * @param {koinos.rpc.p2p.get_gossip_status_response} message get_gossip_status_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_gossip_status_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.enabled = false;
                        if (message.enabled != null && message.hasOwnProperty("enabled"))
                            object.enabled = message.enabled;
                        return object;
                    };
    
                    /**
                     * Converts this get_gossip_status_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.p2p.get_gossip_status_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_gossip_status_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_gossip_status_response;
                })();
    
                p2p.p2p_request = (function() {
    
                    /**
                     * Properties of a p2p_request.
                     * @memberof koinos.rpc.p2p
                     * @interface Ip2p_request
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] p2p_request reserved
                     * @property {koinos.rpc.p2p.Iget_gossip_status_request|null} [get_gossip_status] p2p_request get_gossip_status
                     */
    
                    /**
                     * Constructs a new p2p_request.
                     * @memberof koinos.rpc.p2p
                     * @classdesc Represents a p2p_request.
                     * @implements Ip2p_request
                     * @constructor
                     * @param {koinos.rpc.p2p.Ip2p_request=} [properties] Properties to set
                     */
                    function p2p_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * p2p_request reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @instance
                     */
                    p2p_request.prototype.reserved = null;
    
                    /**
                     * p2p_request get_gossip_status.
                     * @member {koinos.rpc.p2p.Iget_gossip_status_request|null|undefined} get_gossip_status
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @instance
                     */
                    p2p_request.prototype.get_gossip_status = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * p2p_request request.
                     * @member {"reserved"|"get_gossip_status"|undefined} request
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @instance
                     */
                    Object.defineProperty(p2p_request.prototype, "request", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "get_gossip_status"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new p2p_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {koinos.rpc.p2p.Ip2p_request=} [properties] Properties to set
                     * @returns {koinos.rpc.p2p.p2p_request} p2p_request instance
                     */
                    p2p_request.create = function create(properties) {
                        return new p2p_request(properties);
                    };
    
                    /**
                     * Encodes the specified p2p_request message. Does not implicitly {@link koinos.rpc.p2p.p2p_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {koinos.rpc.p2p.Ip2p_request} message p2p_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    p2p_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.get_gossip_status != null && Object.hasOwnProperty.call(message, "get_gossip_status"))
                            $root.koinos.rpc.p2p.get_gossip_status_request.encode(message.get_gossip_status, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified p2p_request message, length delimited. Does not implicitly {@link koinos.rpc.p2p.p2p_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {koinos.rpc.p2p.Ip2p_request} message p2p_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    p2p_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a p2p_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.p2p.p2p_request} p2p_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    p2p_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.p2p.p2p_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.get_gossip_status = $root.koinos.rpc.p2p.get_gossip_status_request.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a p2p_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.p2p.p2p_request} p2p_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    p2p_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a p2p_request message.
                     * @function verify
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    p2p_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.get_gossip_status != null && message.hasOwnProperty("get_gossip_status")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.p2p.get_gossip_status_request.verify(message.get_gossip_status);
                                if (error)
                                    return "get_gossip_status." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a p2p_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.p2p.p2p_request} p2p_request
                     */
                    p2p_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.p2p.p2p_request)
                            return object;
                        var message = new $root.koinos.rpc.p2p.p2p_request();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.p2p.p2p_request.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.get_gossip_status != null) {
                            if (typeof object.get_gossip_status !== "object")
                                throw TypeError(".koinos.rpc.p2p.p2p_request.get_gossip_status: object expected");
                            message.get_gossip_status = $root.koinos.rpc.p2p.get_gossip_status_request.fromObject(object.get_gossip_status);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a p2p_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @static
                     * @param {koinos.rpc.p2p.p2p_request} message p2p_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    p2p_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.request = "reserved";
                        }
                        if (message.get_gossip_status != null && message.hasOwnProperty("get_gossip_status")) {
                            object.get_gossip_status = $root.koinos.rpc.p2p.get_gossip_status_request.toObject(message.get_gossip_status, options);
                            if (options.oneofs)
                                object.request = "get_gossip_status";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this p2p_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.p2p.p2p_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    p2p_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return p2p_request;
                })();
    
                p2p.p2p_response = (function() {
    
                    /**
                     * Properties of a p2p_response.
                     * @memberof koinos.rpc.p2p
                     * @interface Ip2p_response
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] p2p_response reserved
                     * @property {koinos.rpc.Ierror_response|null} [error] p2p_response error
                     * @property {koinos.rpc.p2p.Iget_gossip_status_response|null} [get_gossip_status] p2p_response get_gossip_status
                     */
    
                    /**
                     * Constructs a new p2p_response.
                     * @memberof koinos.rpc.p2p
                     * @classdesc Represents a p2p_response.
                     * @implements Ip2p_response
                     * @constructor
                     * @param {koinos.rpc.p2p.Ip2p_response=} [properties] Properties to set
                     */
                    function p2p_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * p2p_response reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @instance
                     */
                    p2p_response.prototype.reserved = null;
    
                    /**
                     * p2p_response error.
                     * @member {koinos.rpc.Ierror_response|null|undefined} error
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @instance
                     */
                    p2p_response.prototype.error = null;
    
                    /**
                     * p2p_response get_gossip_status.
                     * @member {koinos.rpc.p2p.Iget_gossip_status_response|null|undefined} get_gossip_status
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @instance
                     */
                    p2p_response.prototype.get_gossip_status = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * p2p_response response.
                     * @member {"reserved"|"error"|"get_gossip_status"|undefined} response
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @instance
                     */
                    Object.defineProperty(p2p_response.prototype, "response", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "error", "get_gossip_status"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new p2p_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {koinos.rpc.p2p.Ip2p_response=} [properties] Properties to set
                     * @returns {koinos.rpc.p2p.p2p_response} p2p_response instance
                     */
                    p2p_response.create = function create(properties) {
                        return new p2p_response(properties);
                    };
    
                    /**
                     * Encodes the specified p2p_response message. Does not implicitly {@link koinos.rpc.p2p.p2p_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {koinos.rpc.p2p.Ip2p_response} message p2p_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    p2p_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.koinos.rpc.error_response.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.get_gossip_status != null && Object.hasOwnProperty.call(message, "get_gossip_status"))
                            $root.koinos.rpc.p2p.get_gossip_status_response.encode(message.get_gossip_status, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified p2p_response message, length delimited. Does not implicitly {@link koinos.rpc.p2p.p2p_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {koinos.rpc.p2p.Ip2p_response} message p2p_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    p2p_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a p2p_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.p2p.p2p_response} p2p_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    p2p_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.p2p.p2p_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.error = $root.koinos.rpc.error_response.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.get_gossip_status = $root.koinos.rpc.p2p.get_gossip_status_response.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a p2p_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.p2p.p2p_response} p2p_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    p2p_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a p2p_response message.
                     * @function verify
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    p2p_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.error_response.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.get_gossip_status != null && message.hasOwnProperty("get_gossip_status")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.p2p.get_gossip_status_response.verify(message.get_gossip_status);
                                if (error)
                                    return "get_gossip_status." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a p2p_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.p2p.p2p_response} p2p_response
                     */
                    p2p_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.p2p.p2p_response)
                            return object;
                        var message = new $root.koinos.rpc.p2p.p2p_response();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.p2p.p2p_response.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".koinos.rpc.p2p.p2p_response.error: object expected");
                            message.error = $root.koinos.rpc.error_response.fromObject(object.error);
                        }
                        if (object.get_gossip_status != null) {
                            if (typeof object.get_gossip_status !== "object")
                                throw TypeError(".koinos.rpc.p2p.p2p_response.get_gossip_status: object expected");
                            message.get_gossip_status = $root.koinos.rpc.p2p.get_gossip_status_response.fromObject(object.get_gossip_status);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a p2p_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @static
                     * @param {koinos.rpc.p2p.p2p_response} message p2p_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    p2p_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.response = "reserved";
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.koinos.rpc.error_response.toObject(message.error, options);
                            if (options.oneofs)
                                object.response = "error";
                        }
                        if (message.get_gossip_status != null && message.hasOwnProperty("get_gossip_status")) {
                            object.get_gossip_status = $root.koinos.rpc.p2p.get_gossip_status_response.toObject(message.get_gossip_status, options);
                            if (options.oneofs)
                                object.response = "get_gossip_status";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this p2p_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.p2p.p2p_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    p2p_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return p2p_response;
                })();
    
                return p2p;
            })();
    
            rpc.reserved_rpc = (function() {
    
                /**
                 * Properties of a reserved_rpc.
                 * @memberof koinos.rpc
                 * @interface Ireserved_rpc
                 */
    
                /**
                 * Constructs a new reserved_rpc.
                 * @memberof koinos.rpc
                 * @classdesc Represents a reserved_rpc.
                 * @implements Ireserved_rpc
                 * @constructor
                 * @param {koinos.rpc.Ireserved_rpc=} [properties] Properties to set
                 */
                function reserved_rpc(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new reserved_rpc instance using the specified properties.
                 * @function create
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {koinos.rpc.Ireserved_rpc=} [properties] Properties to set
                 * @returns {koinos.rpc.reserved_rpc} reserved_rpc instance
                 */
                reserved_rpc.create = function create(properties) {
                    return new reserved_rpc(properties);
                };
    
                /**
                 * Encodes the specified reserved_rpc message. Does not implicitly {@link koinos.rpc.reserved_rpc.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {koinos.rpc.Ireserved_rpc} message reserved_rpc message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                reserved_rpc.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified reserved_rpc message, length delimited. Does not implicitly {@link koinos.rpc.reserved_rpc.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {koinos.rpc.Ireserved_rpc} message reserved_rpc message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                reserved_rpc.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a reserved_rpc message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.rpc.reserved_rpc} reserved_rpc
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                reserved_rpc.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.reserved_rpc();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a reserved_rpc message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.rpc.reserved_rpc} reserved_rpc
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                reserved_rpc.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a reserved_rpc message.
                 * @function verify
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                reserved_rpc.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a reserved_rpc message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.rpc.reserved_rpc} reserved_rpc
                 */
                reserved_rpc.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.rpc.reserved_rpc)
                        return object;
                    return new $root.koinos.rpc.reserved_rpc();
                };
    
                /**
                 * Creates a plain object from a reserved_rpc message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.rpc.reserved_rpc
                 * @static
                 * @param {koinos.rpc.reserved_rpc} message reserved_rpc
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                reserved_rpc.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this reserved_rpc to JSON.
                 * @function toJSON
                 * @memberof koinos.rpc.reserved_rpc
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                reserved_rpc.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return reserved_rpc;
            })();
    
            rpc.error_response = (function() {
    
                /**
                 * Properties of an error_response.
                 * @memberof koinos.rpc
                 * @interface Ierror_response
                 * @property {string|null} [message] error_response message
                 * @property {string|null} [data] error_response data
                 */
    
                /**
                 * Constructs a new error_response.
                 * @memberof koinos.rpc
                 * @classdesc Represents an error_response.
                 * @implements Ierror_response
                 * @constructor
                 * @param {koinos.rpc.Ierror_response=} [properties] Properties to set
                 */
                function error_response(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * error_response message.
                 * @member {string} message
                 * @memberof koinos.rpc.error_response
                 * @instance
                 */
                error_response.prototype.message = "";
    
                /**
                 * error_response data.
                 * @member {string} data
                 * @memberof koinos.rpc.error_response
                 * @instance
                 */
                error_response.prototype.data = "";
    
                /**
                 * Creates a new error_response instance using the specified properties.
                 * @function create
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {koinos.rpc.Ierror_response=} [properties] Properties to set
                 * @returns {koinos.rpc.error_response} error_response instance
                 */
                error_response.create = function create(properties) {
                    return new error_response(properties);
                };
    
                /**
                 * Encodes the specified error_response message. Does not implicitly {@link koinos.rpc.error_response.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {koinos.rpc.Ierror_response} message error_response message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                error_response.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                    return writer;
                };
    
                /**
                 * Encodes the specified error_response message, length delimited. Does not implicitly {@link koinos.rpc.error_response.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {koinos.rpc.Ierror_response} message error_response message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                error_response.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an error_response message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.rpc.error_response} error_response
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                error_response.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.error_response();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        case 2:
                            message.data = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an error_response message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.rpc.error_response} error_response
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                error_response.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an error_response message.
                 * @function verify
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                error_response.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!$util.isString(message.data))
                            return "data: string expected";
                    return null;
                };
    
                /**
                 * Creates an error_response message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.rpc.error_response} error_response
                 */
                error_response.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.rpc.error_response)
                        return object;
                    var message = new $root.koinos.rpc.error_response();
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.data != null)
                        message.data = String(object.data);
                    return message;
                };
    
                /**
                 * Creates a plain object from an error_response message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.rpc.error_response
                 * @static
                 * @param {koinos.rpc.error_response} message error_response
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                error_response.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.message = "";
                        object.data = "";
                    }
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = message.data;
                    return object;
                };
    
                /**
                 * Converts this error_response to JSON.
                 * @function toJSON
                 * @memberof koinos.rpc.error_response
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                error_response.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return error_response;
            })();
    
            rpc.transaction_store = (function() {
    
                /**
                 * Namespace transaction_store.
                 * @memberof koinos.rpc
                 * @namespace
                 */
                var transaction_store = {};
    
                transaction_store.get_transactions_by_id_request = (function() {
    
                    /**
                     * Properties of a get_transactions_by_id_request.
                     * @memberof koinos.rpc.transaction_store
                     * @interface Iget_transactions_by_id_request
                     * @property {Array.<Uint8Array>|null} [transaction_ids] get_transactions_by_id_request transaction_ids
                     */
    
                    /**
                     * Constructs a new get_transactions_by_id_request.
                     * @memberof koinos.rpc.transaction_store
                     * @classdesc Represents a get_transactions_by_id_request.
                     * @implements Iget_transactions_by_id_request
                     * @constructor
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_request=} [properties] Properties to set
                     */
                    function get_transactions_by_id_request(properties) {
                        this.transaction_ids = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_transactions_by_id_request transaction_ids.
                     * @member {Array.<Uint8Array>} transaction_ids
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @instance
                     */
                    get_transactions_by_id_request.prototype.transaction_ids = $util.emptyArray;
    
                    /**
                     * Creates a new get_transactions_by_id_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_request=} [properties] Properties to set
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_request} get_transactions_by_id_request instance
                     */
                    get_transactions_by_id_request.create = function create(properties) {
                        return new get_transactions_by_id_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_transactions_by_id_request message. Does not implicitly {@link koinos.rpc.transaction_store.get_transactions_by_id_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_request} message get_transactions_by_id_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_transactions_by_id_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction_ids != null && message.transaction_ids.length)
                            for (var i = 0; i < message.transaction_ids.length; ++i)
                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.transaction_ids[i]);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_transactions_by_id_request message, length delimited. Does not implicitly {@link koinos.rpc.transaction_store.get_transactions_by_id_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_request} message get_transactions_by_id_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_transactions_by_id_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_transactions_by_id_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_request} get_transactions_by_id_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_transactions_by_id_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.transaction_store.get_transactions_by_id_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.transaction_ids && message.transaction_ids.length))
                                    message.transaction_ids = [];
                                message.transaction_ids.push(reader.bytes());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_transactions_by_id_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_request} get_transactions_by_id_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_transactions_by_id_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_transactions_by_id_request message.
                     * @function verify
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_transactions_by_id_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction_ids != null && message.hasOwnProperty("transaction_ids")) {
                            if (!Array.isArray(message.transaction_ids))
                                return "transaction_ids: array expected";
                            for (var i = 0; i < message.transaction_ids.length; ++i)
                                if (!(message.transaction_ids[i] && typeof message.transaction_ids[i].length === "number" || $util.isString(message.transaction_ids[i])))
                                    return "transaction_ids: buffer[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_transactions_by_id_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_request} get_transactions_by_id_request
                     */
                    get_transactions_by_id_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.transaction_store.get_transactions_by_id_request)
                            return object;
                        var message = new $root.koinos.rpc.transaction_store.get_transactions_by_id_request();
                        if (object.transaction_ids) {
                            if (!Array.isArray(object.transaction_ids))
                                throw TypeError(".koinos.rpc.transaction_store.get_transactions_by_id_request.transaction_ids: array expected");
                            message.transaction_ids = [];
                            for (var i = 0; i < object.transaction_ids.length; ++i)
                                if (typeof object.transaction_ids[i] === "string")
                                    $util.base64.decode(object.transaction_ids[i], message.transaction_ids[i] = $util.newBuffer($util.base64.length(object.transaction_ids[i])), 0);
                                else if (object.transaction_ids[i].length)
                                    message.transaction_ids[i] = object.transaction_ids[i];
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_transactions_by_id_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @static
                     * @param {koinos.rpc.transaction_store.get_transactions_by_id_request} message get_transactions_by_id_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_transactions_by_id_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.transaction_ids = [];
                        if (message.transaction_ids && message.transaction_ids.length) {
                            object.transaction_ids = [];
                            for (var j = 0; j < message.transaction_ids.length; ++j)
                                object.transaction_ids[j] = options.bytes === String ? $util.base64.encode(message.transaction_ids[j], 0, message.transaction_ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.transaction_ids[j]) : message.transaction_ids[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_transactions_by_id_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_transactions_by_id_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_transactions_by_id_request;
                })();
    
                transaction_store.get_transactions_by_id_response = (function() {
    
                    /**
                     * Properties of a get_transactions_by_id_response.
                     * @memberof koinos.rpc.transaction_store
                     * @interface Iget_transactions_by_id_response
                     * @property {Array.<koinos.transaction_store.Itransaction_item>|null} [transactions] get_transactions_by_id_response transactions
                     */
    
                    /**
                     * Constructs a new get_transactions_by_id_response.
                     * @memberof koinos.rpc.transaction_store
                     * @classdesc Represents a get_transactions_by_id_response.
                     * @implements Iget_transactions_by_id_response
                     * @constructor
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_response=} [properties] Properties to set
                     */
                    function get_transactions_by_id_response(properties) {
                        this.transactions = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_transactions_by_id_response transactions.
                     * @member {Array.<koinos.transaction_store.Itransaction_item>} transactions
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @instance
                     */
                    get_transactions_by_id_response.prototype.transactions = $util.emptyArray;
    
                    /**
                     * Creates a new get_transactions_by_id_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_response=} [properties] Properties to set
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_response} get_transactions_by_id_response instance
                     */
                    get_transactions_by_id_response.create = function create(properties) {
                        return new get_transactions_by_id_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_transactions_by_id_response message. Does not implicitly {@link koinos.rpc.transaction_store.get_transactions_by_id_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_response} message get_transactions_by_id_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_transactions_by_id_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transactions != null && message.transactions.length)
                            for (var i = 0; i < message.transactions.length; ++i)
                                $root.koinos.transaction_store.transaction_item.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_transactions_by_id_response message, length delimited. Does not implicitly {@link koinos.rpc.transaction_store.get_transactions_by_id_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {koinos.rpc.transaction_store.Iget_transactions_by_id_response} message get_transactions_by_id_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_transactions_by_id_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_transactions_by_id_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_response} get_transactions_by_id_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_transactions_by_id_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.transaction_store.get_transactions_by_id_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.transactions && message.transactions.length))
                                    message.transactions = [];
                                message.transactions.push($root.koinos.transaction_store.transaction_item.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_transactions_by_id_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_response} get_transactions_by_id_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_transactions_by_id_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_transactions_by_id_response message.
                     * @function verify
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_transactions_by_id_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transactions != null && message.hasOwnProperty("transactions")) {
                            if (!Array.isArray(message.transactions))
                                return "transactions: array expected";
                            for (var i = 0; i < message.transactions.length; ++i) {
                                var error = $root.koinos.transaction_store.transaction_item.verify(message.transactions[i]);
                                if (error)
                                    return "transactions." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_transactions_by_id_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.transaction_store.get_transactions_by_id_response} get_transactions_by_id_response
                     */
                    get_transactions_by_id_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.transaction_store.get_transactions_by_id_response)
                            return object;
                        var message = new $root.koinos.rpc.transaction_store.get_transactions_by_id_response();
                        if (object.transactions) {
                            if (!Array.isArray(object.transactions))
                                throw TypeError(".koinos.rpc.transaction_store.get_transactions_by_id_response.transactions: array expected");
                            message.transactions = [];
                            for (var i = 0; i < object.transactions.length; ++i) {
                                if (typeof object.transactions[i] !== "object")
                                    throw TypeError(".koinos.rpc.transaction_store.get_transactions_by_id_response.transactions: object expected");
                                message.transactions[i] = $root.koinos.transaction_store.transaction_item.fromObject(object.transactions[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_transactions_by_id_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @static
                     * @param {koinos.rpc.transaction_store.get_transactions_by_id_response} message get_transactions_by_id_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_transactions_by_id_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.transactions = [];
                        if (message.transactions && message.transactions.length) {
                            object.transactions = [];
                            for (var j = 0; j < message.transactions.length; ++j)
                                object.transactions[j] = $root.koinos.transaction_store.transaction_item.toObject(message.transactions[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_transactions_by_id_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.transaction_store.get_transactions_by_id_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_transactions_by_id_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_transactions_by_id_response;
                })();
    
                transaction_store.transaction_store_request = (function() {
    
                    /**
                     * Properties of a transaction_store_request.
                     * @memberof koinos.rpc.transaction_store
                     * @interface Itransaction_store_request
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] transaction_store_request reserved
                     * @property {koinos.rpc.transaction_store.Iget_transactions_by_id_request|null} [get_transactions_by_id] transaction_store_request get_transactions_by_id
                     */
    
                    /**
                     * Constructs a new transaction_store_request.
                     * @memberof koinos.rpc.transaction_store
                     * @classdesc Represents a transaction_store_request.
                     * @implements Itransaction_store_request
                     * @constructor
                     * @param {koinos.rpc.transaction_store.Itransaction_store_request=} [properties] Properties to set
                     */
                    function transaction_store_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * transaction_store_request reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @instance
                     */
                    transaction_store_request.prototype.reserved = null;
    
                    /**
                     * transaction_store_request get_transactions_by_id.
                     * @member {koinos.rpc.transaction_store.Iget_transactions_by_id_request|null|undefined} get_transactions_by_id
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @instance
                     */
                    transaction_store_request.prototype.get_transactions_by_id = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * transaction_store_request request.
                     * @member {"reserved"|"get_transactions_by_id"|undefined} request
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @instance
                     */
                    Object.defineProperty(transaction_store_request.prototype, "request", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "get_transactions_by_id"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new transaction_store_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {koinos.rpc.transaction_store.Itransaction_store_request=} [properties] Properties to set
                     * @returns {koinos.rpc.transaction_store.transaction_store_request} transaction_store_request instance
                     */
                    transaction_store_request.create = function create(properties) {
                        return new transaction_store_request(properties);
                    };
    
                    /**
                     * Encodes the specified transaction_store_request message. Does not implicitly {@link koinos.rpc.transaction_store.transaction_store_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {koinos.rpc.transaction_store.Itransaction_store_request} message transaction_store_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transaction_store_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.get_transactions_by_id != null && Object.hasOwnProperty.call(message, "get_transactions_by_id"))
                            $root.koinos.rpc.transaction_store.get_transactions_by_id_request.encode(message.get_transactions_by_id, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified transaction_store_request message, length delimited. Does not implicitly {@link koinos.rpc.transaction_store.transaction_store_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {koinos.rpc.transaction_store.Itransaction_store_request} message transaction_store_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transaction_store_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a transaction_store_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.transaction_store.transaction_store_request} transaction_store_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transaction_store_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.transaction_store.transaction_store_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.get_transactions_by_id = $root.koinos.rpc.transaction_store.get_transactions_by_id_request.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a transaction_store_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.transaction_store.transaction_store_request} transaction_store_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transaction_store_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a transaction_store_request message.
                     * @function verify
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    transaction_store_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.get_transactions_by_id != null && message.hasOwnProperty("get_transactions_by_id")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.transaction_store.get_transactions_by_id_request.verify(message.get_transactions_by_id);
                                if (error)
                                    return "get_transactions_by_id." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a transaction_store_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.transaction_store.transaction_store_request} transaction_store_request
                     */
                    transaction_store_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.transaction_store.transaction_store_request)
                            return object;
                        var message = new $root.koinos.rpc.transaction_store.transaction_store_request();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.transaction_store.transaction_store_request.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.get_transactions_by_id != null) {
                            if (typeof object.get_transactions_by_id !== "object")
                                throw TypeError(".koinos.rpc.transaction_store.transaction_store_request.get_transactions_by_id: object expected");
                            message.get_transactions_by_id = $root.koinos.rpc.transaction_store.get_transactions_by_id_request.fromObject(object.get_transactions_by_id);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a transaction_store_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @static
                     * @param {koinos.rpc.transaction_store.transaction_store_request} message transaction_store_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    transaction_store_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.request = "reserved";
                        }
                        if (message.get_transactions_by_id != null && message.hasOwnProperty("get_transactions_by_id")) {
                            object.get_transactions_by_id = $root.koinos.rpc.transaction_store.get_transactions_by_id_request.toObject(message.get_transactions_by_id, options);
                            if (options.oneofs)
                                object.request = "get_transactions_by_id";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this transaction_store_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.transaction_store.transaction_store_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    transaction_store_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return transaction_store_request;
                })();
    
                transaction_store.transaction_store_response = (function() {
    
                    /**
                     * Properties of a transaction_store_response.
                     * @memberof koinos.rpc.transaction_store
                     * @interface Itransaction_store_response
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] transaction_store_response reserved
                     * @property {koinos.rpc.Ierror_response|null} [error] transaction_store_response error
                     * @property {koinos.rpc.transaction_store.Iget_transactions_by_id_response|null} [get_transactions_by_id] transaction_store_response get_transactions_by_id
                     */
    
                    /**
                     * Constructs a new transaction_store_response.
                     * @memberof koinos.rpc.transaction_store
                     * @classdesc Represents a transaction_store_response.
                     * @implements Itransaction_store_response
                     * @constructor
                     * @param {koinos.rpc.transaction_store.Itransaction_store_response=} [properties] Properties to set
                     */
                    function transaction_store_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * transaction_store_response reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @instance
                     */
                    transaction_store_response.prototype.reserved = null;
    
                    /**
                     * transaction_store_response error.
                     * @member {koinos.rpc.Ierror_response|null|undefined} error
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @instance
                     */
                    transaction_store_response.prototype.error = null;
    
                    /**
                     * transaction_store_response get_transactions_by_id.
                     * @member {koinos.rpc.transaction_store.Iget_transactions_by_id_response|null|undefined} get_transactions_by_id
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @instance
                     */
                    transaction_store_response.prototype.get_transactions_by_id = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * transaction_store_response response.
                     * @member {"reserved"|"error"|"get_transactions_by_id"|undefined} response
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @instance
                     */
                    Object.defineProperty(transaction_store_response.prototype, "response", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "error", "get_transactions_by_id"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new transaction_store_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {koinos.rpc.transaction_store.Itransaction_store_response=} [properties] Properties to set
                     * @returns {koinos.rpc.transaction_store.transaction_store_response} transaction_store_response instance
                     */
                    transaction_store_response.create = function create(properties) {
                        return new transaction_store_response(properties);
                    };
    
                    /**
                     * Encodes the specified transaction_store_response message. Does not implicitly {@link koinos.rpc.transaction_store.transaction_store_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {koinos.rpc.transaction_store.Itransaction_store_response} message transaction_store_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transaction_store_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.koinos.rpc.error_response.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.get_transactions_by_id != null && Object.hasOwnProperty.call(message, "get_transactions_by_id"))
                            $root.koinos.rpc.transaction_store.get_transactions_by_id_response.encode(message.get_transactions_by_id, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified transaction_store_response message, length delimited. Does not implicitly {@link koinos.rpc.transaction_store.transaction_store_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {koinos.rpc.transaction_store.Itransaction_store_response} message transaction_store_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    transaction_store_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a transaction_store_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.transaction_store.transaction_store_response} transaction_store_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transaction_store_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.transaction_store.transaction_store_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.error = $root.koinos.rpc.error_response.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.get_transactions_by_id = $root.koinos.rpc.transaction_store.get_transactions_by_id_response.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a transaction_store_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.transaction_store.transaction_store_response} transaction_store_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    transaction_store_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a transaction_store_response message.
                     * @function verify
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    transaction_store_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.error_response.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.get_transactions_by_id != null && message.hasOwnProperty("get_transactions_by_id")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.transaction_store.get_transactions_by_id_response.verify(message.get_transactions_by_id);
                                if (error)
                                    return "get_transactions_by_id." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a transaction_store_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.transaction_store.transaction_store_response} transaction_store_response
                     */
                    transaction_store_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.transaction_store.transaction_store_response)
                            return object;
                        var message = new $root.koinos.rpc.transaction_store.transaction_store_response();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.transaction_store.transaction_store_response.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".koinos.rpc.transaction_store.transaction_store_response.error: object expected");
                            message.error = $root.koinos.rpc.error_response.fromObject(object.error);
                        }
                        if (object.get_transactions_by_id != null) {
                            if (typeof object.get_transactions_by_id !== "object")
                                throw TypeError(".koinos.rpc.transaction_store.transaction_store_response.get_transactions_by_id: object expected");
                            message.get_transactions_by_id = $root.koinos.rpc.transaction_store.get_transactions_by_id_response.fromObject(object.get_transactions_by_id);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a transaction_store_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @static
                     * @param {koinos.rpc.transaction_store.transaction_store_response} message transaction_store_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    transaction_store_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.response = "reserved";
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.koinos.rpc.error_response.toObject(message.error, options);
                            if (options.oneofs)
                                object.response = "error";
                        }
                        if (message.get_transactions_by_id != null && message.hasOwnProperty("get_transactions_by_id")) {
                            object.get_transactions_by_id = $root.koinos.rpc.transaction_store.get_transactions_by_id_response.toObject(message.get_transactions_by_id, options);
                            if (options.oneofs)
                                object.response = "get_transactions_by_id";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this transaction_store_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.transaction_store.transaction_store_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    transaction_store_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return transaction_store_response;
                })();
    
                return transaction_store;
            })();
    
            rpc.chain = (function() {
    
                /**
                 * Namespace chain.
                 * @memberof koinos.rpc
                 * @namespace
                 */
                var chain = {};
    
                chain.submit_block_request = (function() {
    
                    /**
                     * Properties of a submit_block_request.
                     * @memberof koinos.rpc.chain
                     * @interface Isubmit_block_request
                     * @property {koinos.protocol.Iblock|null} [block] submit_block_request block
                     */
    
                    /**
                     * Constructs a new submit_block_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a submit_block_request.
                     * @implements Isubmit_block_request
                     * @constructor
                     * @param {koinos.rpc.chain.Isubmit_block_request=} [properties] Properties to set
                     */
                    function submit_block_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * submit_block_request block.
                     * @member {koinos.protocol.Iblock|null|undefined} block
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @instance
                     */
                    submit_block_request.prototype.block = null;
    
                    /**
                     * Creates a new submit_block_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_block_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.submit_block_request} submit_block_request instance
                     */
                    submit_block_request.create = function create(properties) {
                        return new submit_block_request(properties);
                    };
    
                    /**
                     * Encodes the specified submit_block_request message. Does not implicitly {@link koinos.rpc.chain.submit_block_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_block_request} message submit_block_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_block_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                            $root.koinos.protocol.block.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified submit_block_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.submit_block_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_block_request} message submit_block_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_block_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a submit_block_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.submit_block_request} submit_block_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_block_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.submit_block_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.block = $root.koinos.protocol.block.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a submit_block_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.submit_block_request} submit_block_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_block_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a submit_block_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    submit_block_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.block != null && message.hasOwnProperty("block")) {
                            var error = $root.koinos.protocol.block.verify(message.block);
                            if (error)
                                return "block." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a submit_block_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.submit_block_request} submit_block_request
                     */
                    submit_block_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.submit_block_request)
                            return object;
                        var message = new $root.koinos.rpc.chain.submit_block_request();
                        if (object.block != null) {
                            if (typeof object.block !== "object")
                                throw TypeError(".koinos.rpc.chain.submit_block_request.block: object expected");
                            message.block = $root.koinos.protocol.block.fromObject(object.block);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a submit_block_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @static
                     * @param {koinos.rpc.chain.submit_block_request} message submit_block_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    submit_block_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.block = null;
                        if (message.block != null && message.hasOwnProperty("block"))
                            object.block = $root.koinos.protocol.block.toObject(message.block, options);
                        return object;
                    };
    
                    /**
                     * Converts this submit_block_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.submit_block_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    submit_block_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return submit_block_request;
                })();
    
                chain.submit_block_response = (function() {
    
                    /**
                     * Properties of a submit_block_response.
                     * @memberof koinos.rpc.chain
                     * @interface Isubmit_block_response
                     * @property {koinos.protocol.Iblock_receipt|null} [receipt] submit_block_response receipt
                     */
    
                    /**
                     * Constructs a new submit_block_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a submit_block_response.
                     * @implements Isubmit_block_response
                     * @constructor
                     * @param {koinos.rpc.chain.Isubmit_block_response=} [properties] Properties to set
                     */
                    function submit_block_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * submit_block_response receipt.
                     * @member {koinos.protocol.Iblock_receipt|null|undefined} receipt
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @instance
                     */
                    submit_block_response.prototype.receipt = null;
    
                    /**
                     * Creates a new submit_block_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_block_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.submit_block_response} submit_block_response instance
                     */
                    submit_block_response.create = function create(properties) {
                        return new submit_block_response(properties);
                    };
    
                    /**
                     * Encodes the specified submit_block_response message. Does not implicitly {@link koinos.rpc.chain.submit_block_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_block_response} message submit_block_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_block_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                            $root.koinos.protocol.block_receipt.encode(message.receipt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified submit_block_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.submit_block_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_block_response} message submit_block_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_block_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a submit_block_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.submit_block_response} submit_block_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_block_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.submit_block_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.receipt = $root.koinos.protocol.block_receipt.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a submit_block_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.submit_block_response} submit_block_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_block_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a submit_block_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    submit_block_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.receipt != null && message.hasOwnProperty("receipt")) {
                            var error = $root.koinos.protocol.block_receipt.verify(message.receipt);
                            if (error)
                                return "receipt." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a submit_block_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.submit_block_response} submit_block_response
                     */
                    submit_block_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.submit_block_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.submit_block_response();
                        if (object.receipt != null) {
                            if (typeof object.receipt !== "object")
                                throw TypeError(".koinos.rpc.chain.submit_block_response.receipt: object expected");
                            message.receipt = $root.koinos.protocol.block_receipt.fromObject(object.receipt);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a submit_block_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @static
                     * @param {koinos.rpc.chain.submit_block_response} message submit_block_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    submit_block_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.receipt = null;
                        if (message.receipt != null && message.hasOwnProperty("receipt"))
                            object.receipt = $root.koinos.protocol.block_receipt.toObject(message.receipt, options);
                        return object;
                    };
    
                    /**
                     * Converts this submit_block_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.submit_block_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    submit_block_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return submit_block_response;
                })();
    
                chain.submit_transaction_request = (function() {
    
                    /**
                     * Properties of a submit_transaction_request.
                     * @memberof koinos.rpc.chain
                     * @interface Isubmit_transaction_request
                     * @property {koinos.protocol.Itransaction|null} [transaction] submit_transaction_request transaction
                     * @property {boolean|null} [broadcast] submit_transaction_request broadcast
                     */
    
                    /**
                     * Constructs a new submit_transaction_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a submit_transaction_request.
                     * @implements Isubmit_transaction_request
                     * @constructor
                     * @param {koinos.rpc.chain.Isubmit_transaction_request=} [properties] Properties to set
                     */
                    function submit_transaction_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * submit_transaction_request transaction.
                     * @member {koinos.protocol.Itransaction|null|undefined} transaction
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @instance
                     */
                    submit_transaction_request.prototype.transaction = null;
    
                    /**
                     * submit_transaction_request broadcast.
                     * @member {boolean} broadcast
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @instance
                     */
                    submit_transaction_request.prototype.broadcast = false;
    
                    /**
                     * Creates a new submit_transaction_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_transaction_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.submit_transaction_request} submit_transaction_request instance
                     */
                    submit_transaction_request.create = function create(properties) {
                        return new submit_transaction_request(properties);
                    };
    
                    /**
                     * Encodes the specified submit_transaction_request message. Does not implicitly {@link koinos.rpc.chain.submit_transaction_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_transaction_request} message submit_transaction_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_transaction_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                            $root.koinos.protocol.transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.broadcast != null && Object.hasOwnProperty.call(message, "broadcast"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.broadcast);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified submit_transaction_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.submit_transaction_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_transaction_request} message submit_transaction_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_transaction_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a submit_transaction_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.submit_transaction_request} submit_transaction_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_transaction_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.submit_transaction_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.transaction = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.broadcast = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a submit_transaction_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.submit_transaction_request} submit_transaction_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_transaction_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a submit_transaction_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    submit_transaction_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.transaction != null && message.hasOwnProperty("transaction")) {
                            var error = $root.koinos.protocol.transaction.verify(message.transaction);
                            if (error)
                                return "transaction." + error;
                        }
                        if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                            if (typeof message.broadcast !== "boolean")
                                return "broadcast: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a submit_transaction_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.submit_transaction_request} submit_transaction_request
                     */
                    submit_transaction_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.submit_transaction_request)
                            return object;
                        var message = new $root.koinos.rpc.chain.submit_transaction_request();
                        if (object.transaction != null) {
                            if (typeof object.transaction !== "object")
                                throw TypeError(".koinos.rpc.chain.submit_transaction_request.transaction: object expected");
                            message.transaction = $root.koinos.protocol.transaction.fromObject(object.transaction);
                        }
                        if (object.broadcast != null)
                            message.broadcast = Boolean(object.broadcast);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a submit_transaction_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @static
                     * @param {koinos.rpc.chain.submit_transaction_request} message submit_transaction_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    submit_transaction_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.transaction = null;
                            object.broadcast = false;
                        }
                        if (message.transaction != null && message.hasOwnProperty("transaction"))
                            object.transaction = $root.koinos.protocol.transaction.toObject(message.transaction, options);
                        if (message.broadcast != null && message.hasOwnProperty("broadcast"))
                            object.broadcast = message.broadcast;
                        return object;
                    };
    
                    /**
                     * Converts this submit_transaction_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.submit_transaction_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    submit_transaction_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return submit_transaction_request;
                })();
    
                chain.submit_transaction_response = (function() {
    
                    /**
                     * Properties of a submit_transaction_response.
                     * @memberof koinos.rpc.chain
                     * @interface Isubmit_transaction_response
                     * @property {koinos.protocol.Itransaction_receipt|null} [receipt] submit_transaction_response receipt
                     */
    
                    /**
                     * Constructs a new submit_transaction_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a submit_transaction_response.
                     * @implements Isubmit_transaction_response
                     * @constructor
                     * @param {koinos.rpc.chain.Isubmit_transaction_response=} [properties] Properties to set
                     */
                    function submit_transaction_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * submit_transaction_response receipt.
                     * @member {koinos.protocol.Itransaction_receipt|null|undefined} receipt
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @instance
                     */
                    submit_transaction_response.prototype.receipt = null;
    
                    /**
                     * Creates a new submit_transaction_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_transaction_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.submit_transaction_response} submit_transaction_response instance
                     */
                    submit_transaction_response.create = function create(properties) {
                        return new submit_transaction_response(properties);
                    };
    
                    /**
                     * Encodes the specified submit_transaction_response message. Does not implicitly {@link koinos.rpc.chain.submit_transaction_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_transaction_response} message submit_transaction_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_transaction_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                            $root.koinos.protocol.transaction_receipt.encode(message.receipt, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified submit_transaction_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.submit_transaction_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {koinos.rpc.chain.Isubmit_transaction_response} message submit_transaction_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    submit_transaction_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a submit_transaction_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.submit_transaction_response} submit_transaction_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_transaction_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.submit_transaction_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.receipt = $root.koinos.protocol.transaction_receipt.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a submit_transaction_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.submit_transaction_response} submit_transaction_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    submit_transaction_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a submit_transaction_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    submit_transaction_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.receipt != null && message.hasOwnProperty("receipt")) {
                            var error = $root.koinos.protocol.transaction_receipt.verify(message.receipt);
                            if (error)
                                return "receipt." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a submit_transaction_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.submit_transaction_response} submit_transaction_response
                     */
                    submit_transaction_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.submit_transaction_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.submit_transaction_response();
                        if (object.receipt != null) {
                            if (typeof object.receipt !== "object")
                                throw TypeError(".koinos.rpc.chain.submit_transaction_response.receipt: object expected");
                            message.receipt = $root.koinos.protocol.transaction_receipt.fromObject(object.receipt);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a submit_transaction_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @static
                     * @param {koinos.rpc.chain.submit_transaction_response} message submit_transaction_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    submit_transaction_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.receipt = null;
                        if (message.receipt != null && message.hasOwnProperty("receipt"))
                            object.receipt = $root.koinos.protocol.transaction_receipt.toObject(message.receipt, options);
                        return object;
                    };
    
                    /**
                     * Converts this submit_transaction_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.submit_transaction_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    submit_transaction_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return submit_transaction_response;
                })();
    
                chain.get_head_info_request = (function() {
    
                    /**
                     * Properties of a get_head_info_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_head_info_request
                     */
    
                    /**
                     * Constructs a new get_head_info_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_head_info_request.
                     * @implements Iget_head_info_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_head_info_request=} [properties] Properties to set
                     */
                    function get_head_info_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_head_info_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_head_info_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_head_info_request} get_head_info_request instance
                     */
                    get_head_info_request.create = function create(properties) {
                        return new get_head_info_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_head_info_request message. Does not implicitly {@link koinos.rpc.chain.get_head_info_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_head_info_request} message get_head_info_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_head_info_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_head_info_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_head_info_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_head_info_request} message get_head_info_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_head_info_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_head_info_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_head_info_request} get_head_info_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_head_info_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_head_info_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_head_info_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_head_info_request} get_head_info_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_head_info_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_head_info_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_head_info_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_head_info_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_head_info_request} get_head_info_request
                     */
                    get_head_info_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_head_info_request)
                            return object;
                        return new $root.koinos.rpc.chain.get_head_info_request();
                    };
    
                    /**
                     * Creates a plain object from a get_head_info_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @static
                     * @param {koinos.rpc.chain.get_head_info_request} message get_head_info_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_head_info_request.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_head_info_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_head_info_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_head_info_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_head_info_request;
                })();
    
                chain.get_head_info_response = (function() {
    
                    /**
                     * Properties of a get_head_info_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_head_info_response
                     * @property {koinos.Iblock_topology|null} [head_topology] get_head_info_response head_topology
                     * @property {number|Long|null} [last_irreversible_block] get_head_info_response last_irreversible_block
                     * @property {Uint8Array|null} [head_state_merkle_root] get_head_info_response head_state_merkle_root
                     * @property {number|Long|null} [head_block_time] get_head_info_response head_block_time
                     */
    
                    /**
                     * Constructs a new get_head_info_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_head_info_response.
                     * @implements Iget_head_info_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_head_info_response=} [properties] Properties to set
                     */
                    function get_head_info_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_head_info_response head_topology.
                     * @member {koinos.Iblock_topology|null|undefined} head_topology
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @instance
                     */
                    get_head_info_response.prototype.head_topology = null;
    
                    /**
                     * get_head_info_response last_irreversible_block.
                     * @member {number|Long} last_irreversible_block
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @instance
                     */
                    get_head_info_response.prototype.last_irreversible_block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * get_head_info_response head_state_merkle_root.
                     * @member {Uint8Array} head_state_merkle_root
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @instance
                     */
                    get_head_info_response.prototype.head_state_merkle_root = $util.newBuffer([]);
    
                    /**
                     * get_head_info_response head_block_time.
                     * @member {number|Long} head_block_time
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @instance
                     */
                    get_head_info_response.prototype.head_block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new get_head_info_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_head_info_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_head_info_response} get_head_info_response instance
                     */
                    get_head_info_response.create = function create(properties) {
                        return new get_head_info_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_head_info_response message. Does not implicitly {@link koinos.rpc.chain.get_head_info_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_head_info_response} message get_head_info_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_head_info_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.head_topology != null && Object.hasOwnProperty.call(message, "head_topology"))
                            $root.koinos.block_topology.encode(message.head_topology, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.last_irreversible_block != null && Object.hasOwnProperty.call(message, "last_irreversible_block"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.last_irreversible_block);
                        if (message.head_state_merkle_root != null && Object.hasOwnProperty.call(message, "head_state_merkle_root"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.head_state_merkle_root);
                        if (message.head_block_time != null && Object.hasOwnProperty.call(message, "head_block_time"))
                            writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.head_block_time);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_head_info_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_head_info_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_head_info_response} message get_head_info_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_head_info_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_head_info_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_head_info_response} get_head_info_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_head_info_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_head_info_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.head_topology = $root.koinos.block_topology.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.last_irreversible_block = reader.uint64();
                                break;
                            case 3:
                                message.head_state_merkle_root = reader.bytes();
                                break;
                            case 4:
                                message.head_block_time = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_head_info_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_head_info_response} get_head_info_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_head_info_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_head_info_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_head_info_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.head_topology != null && message.hasOwnProperty("head_topology")) {
                            var error = $root.koinos.block_topology.verify(message.head_topology);
                            if (error)
                                return "head_topology." + error;
                        }
                        if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block"))
                            if (!$util.isInteger(message.last_irreversible_block) && !(message.last_irreversible_block && $util.isInteger(message.last_irreversible_block.low) && $util.isInteger(message.last_irreversible_block.high)))
                                return "last_irreversible_block: integer|Long expected";
                        if (message.head_state_merkle_root != null && message.hasOwnProperty("head_state_merkle_root"))
                            if (!(message.head_state_merkle_root && typeof message.head_state_merkle_root.length === "number" || $util.isString(message.head_state_merkle_root)))
                                return "head_state_merkle_root: buffer expected";
                        if (message.head_block_time != null && message.hasOwnProperty("head_block_time"))
                            if (!$util.isInteger(message.head_block_time) && !(message.head_block_time && $util.isInteger(message.head_block_time.low) && $util.isInteger(message.head_block_time.high)))
                                return "head_block_time: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_head_info_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_head_info_response} get_head_info_response
                     */
                    get_head_info_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_head_info_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_head_info_response();
                        if (object.head_topology != null) {
                            if (typeof object.head_topology !== "object")
                                throw TypeError(".koinos.rpc.chain.get_head_info_response.head_topology: object expected");
                            message.head_topology = $root.koinos.block_topology.fromObject(object.head_topology);
                        }
                        if (object.last_irreversible_block != null)
                            if ($util.Long)
                                (message.last_irreversible_block = $util.Long.fromValue(object.last_irreversible_block)).unsigned = true;
                            else if (typeof object.last_irreversible_block === "string")
                                message.last_irreversible_block = parseInt(object.last_irreversible_block, 10);
                            else if (typeof object.last_irreversible_block === "number")
                                message.last_irreversible_block = object.last_irreversible_block;
                            else if (typeof object.last_irreversible_block === "object")
                                message.last_irreversible_block = new $util.LongBits(object.last_irreversible_block.low >>> 0, object.last_irreversible_block.high >>> 0).toNumber(true);
                        if (object.head_state_merkle_root != null)
                            if (typeof object.head_state_merkle_root === "string")
                                $util.base64.decode(object.head_state_merkle_root, message.head_state_merkle_root = $util.newBuffer($util.base64.length(object.head_state_merkle_root)), 0);
                            else if (object.head_state_merkle_root.length)
                                message.head_state_merkle_root = object.head_state_merkle_root;
                        if (object.head_block_time != null)
                            if ($util.Long)
                                (message.head_block_time = $util.Long.fromValue(object.head_block_time)).unsigned = true;
                            else if (typeof object.head_block_time === "string")
                                message.head_block_time = parseInt(object.head_block_time, 10);
                            else if (typeof object.head_block_time === "number")
                                message.head_block_time = object.head_block_time;
                            else if (typeof object.head_block_time === "object")
                                message.head_block_time = new $util.LongBits(object.head_block_time.low >>> 0, object.head_block_time.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_head_info_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @static
                     * @param {koinos.rpc.chain.get_head_info_response} message get_head_info_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_head_info_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.head_topology = null;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.last_irreversible_block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.last_irreversible_block = options.longs === String ? "0" : 0;
                            if (options.bytes === String)
                                object.head_state_merkle_root = "";
                            else {
                                object.head_state_merkle_root = [];
                                if (options.bytes !== Array)
                                    object.head_state_merkle_root = $util.newBuffer(object.head_state_merkle_root);
                            }
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.head_block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.head_block_time = options.longs === String ? "0" : 0;
                        }
                        if (message.head_topology != null && message.hasOwnProperty("head_topology"))
                            object.head_topology = $root.koinos.block_topology.toObject(message.head_topology, options);
                        if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block"))
                            if (typeof message.last_irreversible_block === "number")
                                object.last_irreversible_block = options.longs === String ? String(message.last_irreversible_block) : message.last_irreversible_block;
                            else
                                object.last_irreversible_block = options.longs === String ? $util.Long.prototype.toString.call(message.last_irreversible_block) : options.longs === Number ? new $util.LongBits(message.last_irreversible_block.low >>> 0, message.last_irreversible_block.high >>> 0).toNumber(true) : message.last_irreversible_block;
                        if (message.head_state_merkle_root != null && message.hasOwnProperty("head_state_merkle_root"))
                            object.head_state_merkle_root = options.bytes === String ? $util.base64.encode(message.head_state_merkle_root, 0, message.head_state_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.head_state_merkle_root) : message.head_state_merkle_root;
                        if (message.head_block_time != null && message.hasOwnProperty("head_block_time"))
                            if (typeof message.head_block_time === "number")
                                object.head_block_time = options.longs === String ? String(message.head_block_time) : message.head_block_time;
                            else
                                object.head_block_time = options.longs === String ? $util.Long.prototype.toString.call(message.head_block_time) : options.longs === Number ? new $util.LongBits(message.head_block_time.low >>> 0, message.head_block_time.high >>> 0).toNumber(true) : message.head_block_time;
                        return object;
                    };
    
                    /**
                     * Converts this get_head_info_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_head_info_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_head_info_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_head_info_response;
                })();
    
                chain.get_chain_id_request = (function() {
    
                    /**
                     * Properties of a get_chain_id_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_chain_id_request
                     */
    
                    /**
                     * Constructs a new get_chain_id_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_chain_id_request.
                     * @implements Iget_chain_id_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_chain_id_request=} [properties] Properties to set
                     */
                    function get_chain_id_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_chain_id_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_chain_id_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_chain_id_request} get_chain_id_request instance
                     */
                    get_chain_id_request.create = function create(properties) {
                        return new get_chain_id_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_chain_id_request message. Does not implicitly {@link koinos.rpc.chain.get_chain_id_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_chain_id_request} message get_chain_id_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_chain_id_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_chain_id_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_chain_id_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_chain_id_request} message get_chain_id_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_chain_id_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_chain_id_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_chain_id_request} get_chain_id_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_chain_id_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_chain_id_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_chain_id_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_chain_id_request} get_chain_id_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_chain_id_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_chain_id_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_chain_id_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_chain_id_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_chain_id_request} get_chain_id_request
                     */
                    get_chain_id_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_chain_id_request)
                            return object;
                        return new $root.koinos.rpc.chain.get_chain_id_request();
                    };
    
                    /**
                     * Creates a plain object from a get_chain_id_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @static
                     * @param {koinos.rpc.chain.get_chain_id_request} message get_chain_id_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_chain_id_request.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_chain_id_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_chain_id_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_chain_id_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_chain_id_request;
                })();
    
                chain.get_chain_id_response = (function() {
    
                    /**
                     * Properties of a get_chain_id_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_chain_id_response
                     * @property {Uint8Array|null} [chain_id] get_chain_id_response chain_id
                     */
    
                    /**
                     * Constructs a new get_chain_id_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_chain_id_response.
                     * @implements Iget_chain_id_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_chain_id_response=} [properties] Properties to set
                     */
                    function get_chain_id_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_chain_id_response chain_id.
                     * @member {Uint8Array} chain_id
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @instance
                     */
                    get_chain_id_response.prototype.chain_id = $util.newBuffer([]);
    
                    /**
                     * Creates a new get_chain_id_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_chain_id_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_chain_id_response} get_chain_id_response instance
                     */
                    get_chain_id_response.create = function create(properties) {
                        return new get_chain_id_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_chain_id_response message. Does not implicitly {@link koinos.rpc.chain.get_chain_id_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_chain_id_response} message get_chain_id_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_chain_id_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.chain_id != null && Object.hasOwnProperty.call(message, "chain_id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chain_id);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_chain_id_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_chain_id_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_chain_id_response} message get_chain_id_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_chain_id_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_chain_id_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_chain_id_response} get_chain_id_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_chain_id_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_chain_id_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.chain_id = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_chain_id_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_chain_id_response} get_chain_id_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_chain_id_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_chain_id_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_chain_id_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.chain_id != null && message.hasOwnProperty("chain_id"))
                            if (!(message.chain_id && typeof message.chain_id.length === "number" || $util.isString(message.chain_id)))
                                return "chain_id: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_chain_id_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_chain_id_response} get_chain_id_response
                     */
                    get_chain_id_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_chain_id_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_chain_id_response();
                        if (object.chain_id != null)
                            if (typeof object.chain_id === "string")
                                $util.base64.decode(object.chain_id, message.chain_id = $util.newBuffer($util.base64.length(object.chain_id)), 0);
                            else if (object.chain_id.length)
                                message.chain_id = object.chain_id;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_chain_id_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @static
                     * @param {koinos.rpc.chain.get_chain_id_response} message get_chain_id_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_chain_id_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.chain_id = "";
                            else {
                                object.chain_id = [];
                                if (options.bytes !== Array)
                                    object.chain_id = $util.newBuffer(object.chain_id);
                            }
                        if (message.chain_id != null && message.hasOwnProperty("chain_id"))
                            object.chain_id = options.bytes === String ? $util.base64.encode(message.chain_id, 0, message.chain_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.chain_id) : message.chain_id;
                        return object;
                    };
    
                    /**
                     * Converts this get_chain_id_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_chain_id_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_chain_id_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_chain_id_response;
                })();
    
                chain.get_fork_heads_request = (function() {
    
                    /**
                     * Properties of a get_fork_heads_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_fork_heads_request
                     */
    
                    /**
                     * Constructs a new get_fork_heads_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_fork_heads_request.
                     * @implements Iget_fork_heads_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_fork_heads_request=} [properties] Properties to set
                     */
                    function get_fork_heads_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_fork_heads_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_fork_heads_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_fork_heads_request} get_fork_heads_request instance
                     */
                    get_fork_heads_request.create = function create(properties) {
                        return new get_fork_heads_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_fork_heads_request message. Does not implicitly {@link koinos.rpc.chain.get_fork_heads_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_fork_heads_request} message get_fork_heads_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_fork_heads_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_fork_heads_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_fork_heads_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_fork_heads_request} message get_fork_heads_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_fork_heads_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_fork_heads_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_fork_heads_request} get_fork_heads_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_fork_heads_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_fork_heads_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_fork_heads_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_fork_heads_request} get_fork_heads_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_fork_heads_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_fork_heads_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_fork_heads_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_fork_heads_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_fork_heads_request} get_fork_heads_request
                     */
                    get_fork_heads_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_fork_heads_request)
                            return object;
                        return new $root.koinos.rpc.chain.get_fork_heads_request();
                    };
    
                    /**
                     * Creates a plain object from a get_fork_heads_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @static
                     * @param {koinos.rpc.chain.get_fork_heads_request} message get_fork_heads_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_fork_heads_request.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_fork_heads_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_fork_heads_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_fork_heads_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_fork_heads_request;
                })();
    
                chain.get_fork_heads_response = (function() {
    
                    /**
                     * Properties of a get_fork_heads_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_fork_heads_response
                     * @property {koinos.Iblock_topology|null} [last_irreversible_block] get_fork_heads_response last_irreversible_block
                     * @property {Array.<koinos.Iblock_topology>|null} [fork_heads] get_fork_heads_response fork_heads
                     */
    
                    /**
                     * Constructs a new get_fork_heads_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_fork_heads_response.
                     * @implements Iget_fork_heads_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_fork_heads_response=} [properties] Properties to set
                     */
                    function get_fork_heads_response(properties) {
                        this.fork_heads = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_fork_heads_response last_irreversible_block.
                     * @member {koinos.Iblock_topology|null|undefined} last_irreversible_block
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @instance
                     */
                    get_fork_heads_response.prototype.last_irreversible_block = null;
    
                    /**
                     * get_fork_heads_response fork_heads.
                     * @member {Array.<koinos.Iblock_topology>} fork_heads
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @instance
                     */
                    get_fork_heads_response.prototype.fork_heads = $util.emptyArray;
    
                    /**
                     * Creates a new get_fork_heads_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_fork_heads_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_fork_heads_response} get_fork_heads_response instance
                     */
                    get_fork_heads_response.create = function create(properties) {
                        return new get_fork_heads_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_fork_heads_response message. Does not implicitly {@link koinos.rpc.chain.get_fork_heads_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_fork_heads_response} message get_fork_heads_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_fork_heads_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.last_irreversible_block != null && Object.hasOwnProperty.call(message, "last_irreversible_block"))
                            $root.koinos.block_topology.encode(message.last_irreversible_block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.fork_heads != null && message.fork_heads.length)
                            for (var i = 0; i < message.fork_heads.length; ++i)
                                $root.koinos.block_topology.encode(message.fork_heads[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_fork_heads_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_fork_heads_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_fork_heads_response} message get_fork_heads_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_fork_heads_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_fork_heads_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_fork_heads_response} get_fork_heads_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_fork_heads_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_fork_heads_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.last_irreversible_block = $root.koinos.block_topology.decode(reader, reader.uint32());
                                break;
                            case 2:
                                if (!(message.fork_heads && message.fork_heads.length))
                                    message.fork_heads = [];
                                message.fork_heads.push($root.koinos.block_topology.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_fork_heads_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_fork_heads_response} get_fork_heads_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_fork_heads_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_fork_heads_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_fork_heads_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block")) {
                            var error = $root.koinos.block_topology.verify(message.last_irreversible_block);
                            if (error)
                                return "last_irreversible_block." + error;
                        }
                        if (message.fork_heads != null && message.hasOwnProperty("fork_heads")) {
                            if (!Array.isArray(message.fork_heads))
                                return "fork_heads: array expected";
                            for (var i = 0; i < message.fork_heads.length; ++i) {
                                var error = $root.koinos.block_topology.verify(message.fork_heads[i]);
                                if (error)
                                    return "fork_heads." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_fork_heads_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_fork_heads_response} get_fork_heads_response
                     */
                    get_fork_heads_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_fork_heads_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_fork_heads_response();
                        if (object.last_irreversible_block != null) {
                            if (typeof object.last_irreversible_block !== "object")
                                throw TypeError(".koinos.rpc.chain.get_fork_heads_response.last_irreversible_block: object expected");
                            message.last_irreversible_block = $root.koinos.block_topology.fromObject(object.last_irreversible_block);
                        }
                        if (object.fork_heads) {
                            if (!Array.isArray(object.fork_heads))
                                throw TypeError(".koinos.rpc.chain.get_fork_heads_response.fork_heads: array expected");
                            message.fork_heads = [];
                            for (var i = 0; i < object.fork_heads.length; ++i) {
                                if (typeof object.fork_heads[i] !== "object")
                                    throw TypeError(".koinos.rpc.chain.get_fork_heads_response.fork_heads: object expected");
                                message.fork_heads[i] = $root.koinos.block_topology.fromObject(object.fork_heads[i]);
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_fork_heads_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @static
                     * @param {koinos.rpc.chain.get_fork_heads_response} message get_fork_heads_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_fork_heads_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.fork_heads = [];
                        if (options.defaults)
                            object.last_irreversible_block = null;
                        if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block"))
                            object.last_irreversible_block = $root.koinos.block_topology.toObject(message.last_irreversible_block, options);
                        if (message.fork_heads && message.fork_heads.length) {
                            object.fork_heads = [];
                            for (var j = 0; j < message.fork_heads.length; ++j)
                                object.fork_heads[j] = $root.koinos.block_topology.toObject(message.fork_heads[j], options);
                        }
                        return object;
                    };
    
                    /**
                     * Converts this get_fork_heads_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_fork_heads_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_fork_heads_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_fork_heads_response;
                })();
    
                chain.read_contract_request = (function() {
    
                    /**
                     * Properties of a read_contract_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iread_contract_request
                     * @property {Uint8Array|null} [contract_id] read_contract_request contract_id
                     * @property {number|null} [entry_point] read_contract_request entry_point
                     * @property {Uint8Array|null} [args] read_contract_request args
                     */
    
                    /**
                     * Constructs a new read_contract_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a read_contract_request.
                     * @implements Iread_contract_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iread_contract_request=} [properties] Properties to set
                     */
                    function read_contract_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * read_contract_request contract_id.
                     * @member {Uint8Array} contract_id
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @instance
                     */
                    read_contract_request.prototype.contract_id = $util.newBuffer([]);
    
                    /**
                     * read_contract_request entry_point.
                     * @member {number} entry_point
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @instance
                     */
                    read_contract_request.prototype.entry_point = 0;
    
                    /**
                     * read_contract_request args.
                     * @member {Uint8Array} args
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @instance
                     */
                    read_contract_request.prototype.args = $util.newBuffer([]);
    
                    /**
                     * Creates a new read_contract_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {koinos.rpc.chain.Iread_contract_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.read_contract_request} read_contract_request instance
                     */
                    read_contract_request.create = function create(properties) {
                        return new read_contract_request(properties);
                    };
    
                    /**
                     * Encodes the specified read_contract_request message. Does not implicitly {@link koinos.rpc.chain.read_contract_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {koinos.rpc.chain.Iread_contract_request} message read_contract_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    read_contract_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                        if (message.entry_point != null && Object.hasOwnProperty.call(message, "entry_point"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entry_point);
                        if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.args);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified read_contract_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.read_contract_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {koinos.rpc.chain.Iread_contract_request} message read_contract_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    read_contract_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a read_contract_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.read_contract_request} read_contract_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    read_contract_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.read_contract_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contract_id = reader.bytes();
                                break;
                            case 2:
                                message.entry_point = reader.uint32();
                                break;
                            case 3:
                                message.args = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a read_contract_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.read_contract_request} read_contract_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    read_contract_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a read_contract_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    read_contract_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                            if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                                return "contract_id: buffer expected";
                        if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                            if (!$util.isInteger(message.entry_point))
                                return "entry_point: integer expected";
                        if (message.args != null && message.hasOwnProperty("args"))
                            if (!(message.args && typeof message.args.length === "number" || $util.isString(message.args)))
                                return "args: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a read_contract_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.read_contract_request} read_contract_request
                     */
                    read_contract_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.read_contract_request)
                            return object;
                        var message = new $root.koinos.rpc.chain.read_contract_request();
                        if (object.contract_id != null)
                            if (typeof object.contract_id === "string")
                                $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                            else if (object.contract_id.length)
                                message.contract_id = object.contract_id;
                        if (object.entry_point != null)
                            message.entry_point = object.entry_point >>> 0;
                        if (object.args != null)
                            if (typeof object.args === "string")
                                $util.base64.decode(object.args, message.args = $util.newBuffer($util.base64.length(object.args)), 0);
                            else if (object.args.length)
                                message.args = object.args;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a read_contract_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @static
                     * @param {koinos.rpc.chain.read_contract_request} message read_contract_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    read_contract_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if (options.bytes === String)
                                object.contract_id = "";
                            else {
                                object.contract_id = [];
                                if (options.bytes !== Array)
                                    object.contract_id = $util.newBuffer(object.contract_id);
                            }
                            object.entry_point = 0;
                            if (options.bytes === String)
                                object.args = "";
                            else {
                                object.args = [];
                                if (options.bytes !== Array)
                                    object.args = $util.newBuffer(object.args);
                            }
                        }
                        if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                            object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                        if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                            object.entry_point = message.entry_point;
                        if (message.args != null && message.hasOwnProperty("args"))
                            object.args = options.bytes === String ? $util.base64.encode(message.args, 0, message.args.length) : options.bytes === Array ? Array.prototype.slice.call(message.args) : message.args;
                        return object;
                    };
    
                    /**
                     * Converts this read_contract_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.read_contract_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    read_contract_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return read_contract_request;
                })();
    
                chain.read_contract_response = (function() {
    
                    /**
                     * Properties of a read_contract_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iread_contract_response
                     * @property {Uint8Array|null} [result] read_contract_response result
                     * @property {Array.<string>|null} [logs] read_contract_response logs
                     */
    
                    /**
                     * Constructs a new read_contract_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a read_contract_response.
                     * @implements Iread_contract_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iread_contract_response=} [properties] Properties to set
                     */
                    function read_contract_response(properties) {
                        this.logs = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * read_contract_response result.
                     * @member {Uint8Array} result
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @instance
                     */
                    read_contract_response.prototype.result = $util.newBuffer([]);
    
                    /**
                     * read_contract_response logs.
                     * @member {Array.<string>} logs
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @instance
                     */
                    read_contract_response.prototype.logs = $util.emptyArray;
    
                    /**
                     * Creates a new read_contract_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {koinos.rpc.chain.Iread_contract_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.read_contract_response} read_contract_response instance
                     */
                    read_contract_response.create = function create(properties) {
                        return new read_contract_response(properties);
                    };
    
                    /**
                     * Encodes the specified read_contract_response message. Does not implicitly {@link koinos.rpc.chain.read_contract_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {koinos.rpc.chain.Iread_contract_response} message read_contract_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    read_contract_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.result);
                        if (message.logs != null && message.logs.length)
                            for (var i = 0; i < message.logs.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.logs[i]);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified read_contract_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.read_contract_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {koinos.rpc.chain.Iread_contract_response} message read_contract_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    read_contract_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a read_contract_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.read_contract_response} read_contract_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    read_contract_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.read_contract_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.result = reader.bytes();
                                break;
                            case 2:
                                if (!(message.logs && message.logs.length))
                                    message.logs = [];
                                message.logs.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a read_contract_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.read_contract_response} read_contract_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    read_contract_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a read_contract_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    read_contract_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.result != null && message.hasOwnProperty("result"))
                            if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))
                                return "result: buffer expected";
                        if (message.logs != null && message.hasOwnProperty("logs")) {
                            if (!Array.isArray(message.logs))
                                return "logs: array expected";
                            for (var i = 0; i < message.logs.length; ++i)
                                if (!$util.isString(message.logs[i]))
                                    return "logs: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a read_contract_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.read_contract_response} read_contract_response
                     */
                    read_contract_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.read_contract_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.read_contract_response();
                        if (object.result != null)
                            if (typeof object.result === "string")
                                $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);
                            else if (object.result.length)
                                message.result = object.result;
                        if (object.logs) {
                            if (!Array.isArray(object.logs))
                                throw TypeError(".koinos.rpc.chain.read_contract_response.logs: array expected");
                            message.logs = [];
                            for (var i = 0; i < object.logs.length; ++i)
                                message.logs[i] = String(object.logs[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a read_contract_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @static
                     * @param {koinos.rpc.chain.read_contract_response} message read_contract_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    read_contract_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.logs = [];
                        if (options.defaults)
                            if (options.bytes === String)
                                object.result = "";
                            else {
                                object.result = [];
                                if (options.bytes !== Array)
                                    object.result = $util.newBuffer(object.result);
                            }
                        if (message.result != null && message.hasOwnProperty("result"))
                            object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;
                        if (message.logs && message.logs.length) {
                            object.logs = [];
                            for (var j = 0; j < message.logs.length; ++j)
                                object.logs[j] = message.logs[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this read_contract_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.read_contract_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    read_contract_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return read_contract_response;
                })();
    
                chain.get_account_nonce_request = (function() {
    
                    /**
                     * Properties of a get_account_nonce_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_account_nonce_request
                     * @property {Uint8Array|null} [account] get_account_nonce_request account
                     */
    
                    /**
                     * Constructs a new get_account_nonce_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_account_nonce_request.
                     * @implements Iget_account_nonce_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_account_nonce_request=} [properties] Properties to set
                     */
                    function get_account_nonce_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_account_nonce_request account.
                     * @member {Uint8Array} account
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @instance
                     */
                    get_account_nonce_request.prototype.account = $util.newBuffer([]);
    
                    /**
                     * Creates a new get_account_nonce_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_nonce_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_account_nonce_request} get_account_nonce_request instance
                     */
                    get_account_nonce_request.create = function create(properties) {
                        return new get_account_nonce_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_account_nonce_request message. Does not implicitly {@link koinos.rpc.chain.get_account_nonce_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_nonce_request} message get_account_nonce_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_nonce_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_account_nonce_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_account_nonce_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_nonce_request} message get_account_nonce_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_nonce_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_account_nonce_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_account_nonce_request} get_account_nonce_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_nonce_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_account_nonce_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_account_nonce_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_account_nonce_request} get_account_nonce_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_nonce_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_account_nonce_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_account_nonce_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                                return "account: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_account_nonce_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_account_nonce_request} get_account_nonce_request
                     */
                    get_account_nonce_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_account_nonce_request)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_account_nonce_request();
                        if (object.account != null)
                            if (typeof object.account === "string")
                                $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                            else if (object.account.length)
                                message.account = object.account;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_account_nonce_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @static
                     * @param {koinos.rpc.chain.get_account_nonce_request} message get_account_nonce_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_account_nonce_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.account = "";
                            else {
                                object.account = [];
                                if (options.bytes !== Array)
                                    object.account = $util.newBuffer(object.account);
                            }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                        return object;
                    };
    
                    /**
                     * Converts this get_account_nonce_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_account_nonce_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_account_nonce_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_account_nonce_request;
                })();
    
                chain.get_account_nonce_response = (function() {
    
                    /**
                     * Properties of a get_account_nonce_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_account_nonce_response
                     * @property {Uint8Array|null} [nonce] get_account_nonce_response nonce
                     */
    
                    /**
                     * Constructs a new get_account_nonce_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_account_nonce_response.
                     * @implements Iget_account_nonce_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_account_nonce_response=} [properties] Properties to set
                     */
                    function get_account_nonce_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_account_nonce_response nonce.
                     * @member {Uint8Array} nonce
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @instance
                     */
                    get_account_nonce_response.prototype.nonce = $util.newBuffer([]);
    
                    /**
                     * Creates a new get_account_nonce_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_nonce_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_account_nonce_response} get_account_nonce_response instance
                     */
                    get_account_nonce_response.create = function create(properties) {
                        return new get_account_nonce_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_account_nonce_response message. Does not implicitly {@link koinos.rpc.chain.get_account_nonce_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_nonce_response} message get_account_nonce_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_nonce_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.nonce);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_account_nonce_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_account_nonce_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_nonce_response} message get_account_nonce_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_nonce_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_account_nonce_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_account_nonce_response} get_account_nonce_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_nonce_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_account_nonce_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.nonce = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_account_nonce_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_account_nonce_response} get_account_nonce_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_nonce_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_account_nonce_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_account_nonce_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                                return "nonce: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_account_nonce_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_account_nonce_response} get_account_nonce_response
                     */
                    get_account_nonce_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_account_nonce_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_account_nonce_response();
                        if (object.nonce != null)
                            if (typeof object.nonce === "string")
                                $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                            else if (object.nonce.length)
                                message.nonce = object.nonce;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_account_nonce_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @static
                     * @param {koinos.rpc.chain.get_account_nonce_response} message get_account_nonce_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_account_nonce_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.nonce = "";
                            else {
                                object.nonce = [];
                                if (options.bytes !== Array)
                                    object.nonce = $util.newBuffer(object.nonce);
                            }
                        if (message.nonce != null && message.hasOwnProperty("nonce"))
                            object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                        return object;
                    };
    
                    /**
                     * Converts this get_account_nonce_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_account_nonce_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_account_nonce_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_account_nonce_response;
                })();
    
                chain.get_account_rc_request = (function() {
    
                    /**
                     * Properties of a get_account_rc_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_account_rc_request
                     * @property {Uint8Array|null} [account] get_account_rc_request account
                     */
    
                    /**
                     * Constructs a new get_account_rc_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_account_rc_request.
                     * @implements Iget_account_rc_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_account_rc_request=} [properties] Properties to set
                     */
                    function get_account_rc_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_account_rc_request account.
                     * @member {Uint8Array} account
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @instance
                     */
                    get_account_rc_request.prototype.account = $util.newBuffer([]);
    
                    /**
                     * Creates a new get_account_rc_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_rc_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_account_rc_request} get_account_rc_request instance
                     */
                    get_account_rc_request.create = function create(properties) {
                        return new get_account_rc_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_account_rc_request message. Does not implicitly {@link koinos.rpc.chain.get_account_rc_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_rc_request} message get_account_rc_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_rc_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_account_rc_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_account_rc_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_rc_request} message get_account_rc_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_rc_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_account_rc_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_account_rc_request} get_account_rc_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_rc_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_account_rc_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_account_rc_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_account_rc_request} get_account_rc_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_rc_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_account_rc_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_account_rc_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                                return "account: buffer expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_account_rc_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_account_rc_request} get_account_rc_request
                     */
                    get_account_rc_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_account_rc_request)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_account_rc_request();
                        if (object.account != null)
                            if (typeof object.account === "string")
                                $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                            else if (object.account.length)
                                message.account = object.account;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_account_rc_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @static
                     * @param {koinos.rpc.chain.get_account_rc_request} message get_account_rc_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_account_rc_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if (options.bytes === String)
                                object.account = "";
                            else {
                                object.account = [];
                                if (options.bytes !== Array)
                                    object.account = $util.newBuffer(object.account);
                            }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                        return object;
                    };
    
                    /**
                     * Converts this get_account_rc_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_account_rc_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_account_rc_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_account_rc_request;
                })();
    
                chain.get_account_rc_response = (function() {
    
                    /**
                     * Properties of a get_account_rc_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_account_rc_response
                     * @property {number|Long|null} [rc] get_account_rc_response rc
                     */
    
                    /**
                     * Constructs a new get_account_rc_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_account_rc_response.
                     * @implements Iget_account_rc_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_account_rc_response=} [properties] Properties to set
                     */
                    function get_account_rc_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_account_rc_response rc.
                     * @member {number|Long} rc
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @instance
                     */
                    get_account_rc_response.prototype.rc = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new get_account_rc_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_rc_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_account_rc_response} get_account_rc_response instance
                     */
                    get_account_rc_response.create = function create(properties) {
                        return new get_account_rc_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_account_rc_response message. Does not implicitly {@link koinos.rpc.chain.get_account_rc_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_rc_response} message get_account_rc_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_rc_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rc != null && Object.hasOwnProperty.call(message, "rc"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rc);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_account_rc_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_account_rc_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_account_rc_response} message get_account_rc_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_account_rc_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_account_rc_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_account_rc_response} get_account_rc_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_rc_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_account_rc_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.rc = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_account_rc_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_account_rc_response} get_account_rc_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_account_rc_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_account_rc_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_account_rc_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rc != null && message.hasOwnProperty("rc"))
                            if (!$util.isInteger(message.rc) && !(message.rc && $util.isInteger(message.rc.low) && $util.isInteger(message.rc.high)))
                                return "rc: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_account_rc_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_account_rc_response} get_account_rc_response
                     */
                    get_account_rc_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_account_rc_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_account_rc_response();
                        if (object.rc != null)
                            if ($util.Long)
                                (message.rc = $util.Long.fromValue(object.rc)).unsigned = true;
                            else if (typeof object.rc === "string")
                                message.rc = parseInt(object.rc, 10);
                            else if (typeof object.rc === "number")
                                message.rc = object.rc;
                            else if (typeof object.rc === "object")
                                message.rc = new $util.LongBits(object.rc.low >>> 0, object.rc.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_account_rc_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @static
                     * @param {koinos.rpc.chain.get_account_rc_response} message get_account_rc_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_account_rc_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.rc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.rc = options.longs === String ? "0" : 0;
                        if (message.rc != null && message.hasOwnProperty("rc"))
                            if (typeof message.rc === "number")
                                object.rc = options.longs === String ? String(message.rc) : message.rc;
                            else
                                object.rc = options.longs === String ? $util.Long.prototype.toString.call(message.rc) : options.longs === Number ? new $util.LongBits(message.rc.low >>> 0, message.rc.high >>> 0).toNumber(true) : message.rc;
                        return object;
                    };
    
                    /**
                     * Converts this get_account_rc_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_account_rc_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_account_rc_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_account_rc_response;
                })();
    
                chain.get_resource_limits_request = (function() {
    
                    /**
                     * Properties of a get_resource_limits_request.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_resource_limits_request
                     */
    
                    /**
                     * Constructs a new get_resource_limits_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_resource_limits_request.
                     * @implements Iget_resource_limits_request
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_resource_limits_request=} [properties] Properties to set
                     */
                    function get_resource_limits_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new get_resource_limits_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_resource_limits_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_resource_limits_request} get_resource_limits_request instance
                     */
                    get_resource_limits_request.create = function create(properties) {
                        return new get_resource_limits_request(properties);
                    };
    
                    /**
                     * Encodes the specified get_resource_limits_request message. Does not implicitly {@link koinos.rpc.chain.get_resource_limits_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_resource_limits_request} message get_resource_limits_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_limits_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_resource_limits_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_resource_limits_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {koinos.rpc.chain.Iget_resource_limits_request} message get_resource_limits_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_limits_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_resource_limits_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_resource_limits_request} get_resource_limits_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_limits_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_resource_limits_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_resource_limits_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_resource_limits_request} get_resource_limits_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_limits_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_resource_limits_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_resource_limits_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a get_resource_limits_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_resource_limits_request} get_resource_limits_request
                     */
                    get_resource_limits_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_resource_limits_request)
                            return object;
                        return new $root.koinos.rpc.chain.get_resource_limits_request();
                    };
    
                    /**
                     * Creates a plain object from a get_resource_limits_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @static
                     * @param {koinos.rpc.chain.get_resource_limits_request} message get_resource_limits_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_resource_limits_request.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this get_resource_limits_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_resource_limits_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_resource_limits_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_resource_limits_request;
                })();
    
                chain.get_resource_limits_response = (function() {
    
                    /**
                     * Properties of a get_resource_limits_response.
                     * @memberof koinos.rpc.chain
                     * @interface Iget_resource_limits_response
                     * @property {koinos.chain.Iresource_limit_data|null} [resource_limit_data] get_resource_limits_response resource_limit_data
                     */
    
                    /**
                     * Constructs a new get_resource_limits_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a get_resource_limits_response.
                     * @implements Iget_resource_limits_response
                     * @constructor
                     * @param {koinos.rpc.chain.Iget_resource_limits_response=} [properties] Properties to set
                     */
                    function get_resource_limits_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * get_resource_limits_response resource_limit_data.
                     * @member {koinos.chain.Iresource_limit_data|null|undefined} resource_limit_data
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @instance
                     */
                    get_resource_limits_response.prototype.resource_limit_data = null;
    
                    /**
                     * Creates a new get_resource_limits_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_resource_limits_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.get_resource_limits_response} get_resource_limits_response instance
                     */
                    get_resource_limits_response.create = function create(properties) {
                        return new get_resource_limits_response(properties);
                    };
    
                    /**
                     * Encodes the specified get_resource_limits_response message. Does not implicitly {@link koinos.rpc.chain.get_resource_limits_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_resource_limits_response} message get_resource_limits_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_limits_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.resource_limit_data != null && Object.hasOwnProperty.call(message, "resource_limit_data"))
                            $root.koinos.chain.resource_limit_data.encode(message.resource_limit_data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified get_resource_limits_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.get_resource_limits_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {koinos.rpc.chain.Iget_resource_limits_response} message get_resource_limits_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    get_resource_limits_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a get_resource_limits_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.get_resource_limits_response} get_resource_limits_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_limits_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.get_resource_limits_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.resource_limit_data = $root.koinos.chain.resource_limit_data.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a get_resource_limits_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.get_resource_limits_response} get_resource_limits_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    get_resource_limits_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a get_resource_limits_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    get_resource_limits_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.resource_limit_data != null && message.hasOwnProperty("resource_limit_data")) {
                            var error = $root.koinos.chain.resource_limit_data.verify(message.resource_limit_data);
                            if (error)
                                return "resource_limit_data." + error;
                        }
                        return null;
                    };
    
                    /**
                     * Creates a get_resource_limits_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.get_resource_limits_response} get_resource_limits_response
                     */
                    get_resource_limits_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.get_resource_limits_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.get_resource_limits_response();
                        if (object.resource_limit_data != null) {
                            if (typeof object.resource_limit_data !== "object")
                                throw TypeError(".koinos.rpc.chain.get_resource_limits_response.resource_limit_data: object expected");
                            message.resource_limit_data = $root.koinos.chain.resource_limit_data.fromObject(object.resource_limit_data);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a get_resource_limits_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @static
                     * @param {koinos.rpc.chain.get_resource_limits_response} message get_resource_limits_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    get_resource_limits_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.resource_limit_data = null;
                        if (message.resource_limit_data != null && message.hasOwnProperty("resource_limit_data"))
                            object.resource_limit_data = $root.koinos.chain.resource_limit_data.toObject(message.resource_limit_data, options);
                        return object;
                    };
    
                    /**
                     * Converts this get_resource_limits_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.get_resource_limits_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    get_resource_limits_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return get_resource_limits_response;
                })();
    
                chain.chain_request = (function() {
    
                    /**
                     * Properties of a chain_request.
                     * @memberof koinos.rpc.chain
                     * @interface Ichain_request
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] chain_request reserved
                     * @property {koinos.rpc.chain.Isubmit_block_request|null} [submit_block] chain_request submit_block
                     * @property {koinos.rpc.chain.Isubmit_transaction_request|null} [submit_transaction] chain_request submit_transaction
                     * @property {koinos.rpc.chain.Iget_head_info_request|null} [get_head_info] chain_request get_head_info
                     * @property {koinos.rpc.chain.Iget_chain_id_request|null} [get_chain_id] chain_request get_chain_id
                     * @property {koinos.rpc.chain.Iget_fork_heads_request|null} [get_fork_heads] chain_request get_fork_heads
                     * @property {koinos.rpc.chain.Iread_contract_request|null} [read_contract] chain_request read_contract
                     * @property {koinos.rpc.chain.Iget_account_nonce_request|null} [get_account_nonce] chain_request get_account_nonce
                     * @property {koinos.rpc.chain.Iget_account_rc_request|null} [get_account_rc] chain_request get_account_rc
                     * @property {koinos.rpc.chain.Iget_resource_limits_request|null} [get_resource_limits] chain_request get_resource_limits
                     */
    
                    /**
                     * Constructs a new chain_request.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a chain_request.
                     * @implements Ichain_request
                     * @constructor
                     * @param {koinos.rpc.chain.Ichain_request=} [properties] Properties to set
                     */
                    function chain_request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * chain_request reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.reserved = null;
    
                    /**
                     * chain_request submit_block.
                     * @member {koinos.rpc.chain.Isubmit_block_request|null|undefined} submit_block
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.submit_block = null;
    
                    /**
                     * chain_request submit_transaction.
                     * @member {koinos.rpc.chain.Isubmit_transaction_request|null|undefined} submit_transaction
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.submit_transaction = null;
    
                    /**
                     * chain_request get_head_info.
                     * @member {koinos.rpc.chain.Iget_head_info_request|null|undefined} get_head_info
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.get_head_info = null;
    
                    /**
                     * chain_request get_chain_id.
                     * @member {koinos.rpc.chain.Iget_chain_id_request|null|undefined} get_chain_id
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.get_chain_id = null;
    
                    /**
                     * chain_request get_fork_heads.
                     * @member {koinos.rpc.chain.Iget_fork_heads_request|null|undefined} get_fork_heads
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.get_fork_heads = null;
    
                    /**
                     * chain_request read_contract.
                     * @member {koinos.rpc.chain.Iread_contract_request|null|undefined} read_contract
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.read_contract = null;
    
                    /**
                     * chain_request get_account_nonce.
                     * @member {koinos.rpc.chain.Iget_account_nonce_request|null|undefined} get_account_nonce
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.get_account_nonce = null;
    
                    /**
                     * chain_request get_account_rc.
                     * @member {koinos.rpc.chain.Iget_account_rc_request|null|undefined} get_account_rc
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.get_account_rc = null;
    
                    /**
                     * chain_request get_resource_limits.
                     * @member {koinos.rpc.chain.Iget_resource_limits_request|null|undefined} get_resource_limits
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    chain_request.prototype.get_resource_limits = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * chain_request request.
                     * @member {"reserved"|"submit_block"|"submit_transaction"|"get_head_info"|"get_chain_id"|"get_fork_heads"|"read_contract"|"get_account_nonce"|"get_account_rc"|"get_resource_limits"|undefined} request
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     */
                    Object.defineProperty(chain_request.prototype, "request", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "submit_block", "submit_transaction", "get_head_info", "get_chain_id", "get_fork_heads", "read_contract", "get_account_nonce", "get_account_rc", "get_resource_limits"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new chain_request instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {koinos.rpc.chain.Ichain_request=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.chain_request} chain_request instance
                     */
                    chain_request.create = function create(properties) {
                        return new chain_request(properties);
                    };
    
                    /**
                     * Encodes the specified chain_request message. Does not implicitly {@link koinos.rpc.chain.chain_request.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {koinos.rpc.chain.Ichain_request} message chain_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    chain_request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.submit_block != null && Object.hasOwnProperty.call(message, "submit_block"))
                            $root.koinos.rpc.chain.submit_block_request.encode(message.submit_block, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.submit_transaction != null && Object.hasOwnProperty.call(message, "submit_transaction"))
                            $root.koinos.rpc.chain.submit_transaction_request.encode(message.submit_transaction, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.get_head_info != null && Object.hasOwnProperty.call(message, "get_head_info"))
                            $root.koinos.rpc.chain.get_head_info_request.encode(message.get_head_info, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.get_chain_id != null && Object.hasOwnProperty.call(message, "get_chain_id"))
                            $root.koinos.rpc.chain.get_chain_id_request.encode(message.get_chain_id, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.get_fork_heads != null && Object.hasOwnProperty.call(message, "get_fork_heads"))
                            $root.koinos.rpc.chain.get_fork_heads_request.encode(message.get_fork_heads, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.read_contract != null && Object.hasOwnProperty.call(message, "read_contract"))
                            $root.koinos.rpc.chain.read_contract_request.encode(message.read_contract, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.get_account_nonce != null && Object.hasOwnProperty.call(message, "get_account_nonce"))
                            $root.koinos.rpc.chain.get_account_nonce_request.encode(message.get_account_nonce, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.get_account_rc != null && Object.hasOwnProperty.call(message, "get_account_rc"))
                            $root.koinos.rpc.chain.get_account_rc_request.encode(message.get_account_rc, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.get_resource_limits != null && Object.hasOwnProperty.call(message, "get_resource_limits"))
                            $root.koinos.rpc.chain.get_resource_limits_request.encode(message.get_resource_limits, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified chain_request message, length delimited. Does not implicitly {@link koinos.rpc.chain.chain_request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {koinos.rpc.chain.Ichain_request} message chain_request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    chain_request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a chain_request message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.chain_request} chain_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    chain_request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.chain_request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.submit_block = $root.koinos.rpc.chain.submit_block_request.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.submit_transaction = $root.koinos.rpc.chain.submit_transaction_request.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.get_head_info = $root.koinos.rpc.chain.get_head_info_request.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.get_chain_id = $root.koinos.rpc.chain.get_chain_id_request.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.get_fork_heads = $root.koinos.rpc.chain.get_fork_heads_request.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.read_contract = $root.koinos.rpc.chain.read_contract_request.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.get_account_nonce = $root.koinos.rpc.chain.get_account_nonce_request.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.get_account_rc = $root.koinos.rpc.chain.get_account_rc_request.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.get_resource_limits = $root.koinos.rpc.chain.get_resource_limits_request.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a chain_request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.chain_request} chain_request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    chain_request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a chain_request message.
                     * @function verify
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    chain_request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.submit_block != null && message.hasOwnProperty("submit_block")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.submit_block_request.verify(message.submit_block);
                                if (error)
                                    return "submit_block." + error;
                            }
                        }
                        if (message.submit_transaction != null && message.hasOwnProperty("submit_transaction")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.submit_transaction_request.verify(message.submit_transaction);
                                if (error)
                                    return "submit_transaction." + error;
                            }
                        }
                        if (message.get_head_info != null && message.hasOwnProperty("get_head_info")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_head_info_request.verify(message.get_head_info);
                                if (error)
                                    return "get_head_info." + error;
                            }
                        }
                        if (message.get_chain_id != null && message.hasOwnProperty("get_chain_id")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_chain_id_request.verify(message.get_chain_id);
                                if (error)
                                    return "get_chain_id." + error;
                            }
                        }
                        if (message.get_fork_heads != null && message.hasOwnProperty("get_fork_heads")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_fork_heads_request.verify(message.get_fork_heads);
                                if (error)
                                    return "get_fork_heads." + error;
                            }
                        }
                        if (message.read_contract != null && message.hasOwnProperty("read_contract")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.read_contract_request.verify(message.read_contract);
                                if (error)
                                    return "read_contract." + error;
                            }
                        }
                        if (message.get_account_nonce != null && message.hasOwnProperty("get_account_nonce")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_account_nonce_request.verify(message.get_account_nonce);
                                if (error)
                                    return "get_account_nonce." + error;
                            }
                        }
                        if (message.get_account_rc != null && message.hasOwnProperty("get_account_rc")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_account_rc_request.verify(message.get_account_rc);
                                if (error)
                                    return "get_account_rc." + error;
                            }
                        }
                        if (message.get_resource_limits != null && message.hasOwnProperty("get_resource_limits")) {
                            if (properties.request === 1)
                                return "request: multiple values";
                            properties.request = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_resource_limits_request.verify(message.get_resource_limits);
                                if (error)
                                    return "get_resource_limits." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a chain_request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.chain_request} chain_request
                     */
                    chain_request.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.chain_request)
                            return object;
                        var message = new $root.koinos.rpc.chain.chain_request();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.submit_block != null) {
                            if (typeof object.submit_block !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.submit_block: object expected");
                            message.submit_block = $root.koinos.rpc.chain.submit_block_request.fromObject(object.submit_block);
                        }
                        if (object.submit_transaction != null) {
                            if (typeof object.submit_transaction !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.submit_transaction: object expected");
                            message.submit_transaction = $root.koinos.rpc.chain.submit_transaction_request.fromObject(object.submit_transaction);
                        }
                        if (object.get_head_info != null) {
                            if (typeof object.get_head_info !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.get_head_info: object expected");
                            message.get_head_info = $root.koinos.rpc.chain.get_head_info_request.fromObject(object.get_head_info);
                        }
                        if (object.get_chain_id != null) {
                            if (typeof object.get_chain_id !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.get_chain_id: object expected");
                            message.get_chain_id = $root.koinos.rpc.chain.get_chain_id_request.fromObject(object.get_chain_id);
                        }
                        if (object.get_fork_heads != null) {
                            if (typeof object.get_fork_heads !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.get_fork_heads: object expected");
                            message.get_fork_heads = $root.koinos.rpc.chain.get_fork_heads_request.fromObject(object.get_fork_heads);
                        }
                        if (object.read_contract != null) {
                            if (typeof object.read_contract !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.read_contract: object expected");
                            message.read_contract = $root.koinos.rpc.chain.read_contract_request.fromObject(object.read_contract);
                        }
                        if (object.get_account_nonce != null) {
                            if (typeof object.get_account_nonce !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.get_account_nonce: object expected");
                            message.get_account_nonce = $root.koinos.rpc.chain.get_account_nonce_request.fromObject(object.get_account_nonce);
                        }
                        if (object.get_account_rc != null) {
                            if (typeof object.get_account_rc !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.get_account_rc: object expected");
                            message.get_account_rc = $root.koinos.rpc.chain.get_account_rc_request.fromObject(object.get_account_rc);
                        }
                        if (object.get_resource_limits != null) {
                            if (typeof object.get_resource_limits !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_request.get_resource_limits: object expected");
                            message.get_resource_limits = $root.koinos.rpc.chain.get_resource_limits_request.fromObject(object.get_resource_limits);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a chain_request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.chain_request
                     * @static
                     * @param {koinos.rpc.chain.chain_request} message chain_request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    chain_request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.request = "reserved";
                        }
                        if (message.submit_block != null && message.hasOwnProperty("submit_block")) {
                            object.submit_block = $root.koinos.rpc.chain.submit_block_request.toObject(message.submit_block, options);
                            if (options.oneofs)
                                object.request = "submit_block";
                        }
                        if (message.submit_transaction != null && message.hasOwnProperty("submit_transaction")) {
                            object.submit_transaction = $root.koinos.rpc.chain.submit_transaction_request.toObject(message.submit_transaction, options);
                            if (options.oneofs)
                                object.request = "submit_transaction";
                        }
                        if (message.get_head_info != null && message.hasOwnProperty("get_head_info")) {
                            object.get_head_info = $root.koinos.rpc.chain.get_head_info_request.toObject(message.get_head_info, options);
                            if (options.oneofs)
                                object.request = "get_head_info";
                        }
                        if (message.get_chain_id != null && message.hasOwnProperty("get_chain_id")) {
                            object.get_chain_id = $root.koinos.rpc.chain.get_chain_id_request.toObject(message.get_chain_id, options);
                            if (options.oneofs)
                                object.request = "get_chain_id";
                        }
                        if (message.get_fork_heads != null && message.hasOwnProperty("get_fork_heads")) {
                            object.get_fork_heads = $root.koinos.rpc.chain.get_fork_heads_request.toObject(message.get_fork_heads, options);
                            if (options.oneofs)
                                object.request = "get_fork_heads";
                        }
                        if (message.read_contract != null && message.hasOwnProperty("read_contract")) {
                            object.read_contract = $root.koinos.rpc.chain.read_contract_request.toObject(message.read_contract, options);
                            if (options.oneofs)
                                object.request = "read_contract";
                        }
                        if (message.get_account_nonce != null && message.hasOwnProperty("get_account_nonce")) {
                            object.get_account_nonce = $root.koinos.rpc.chain.get_account_nonce_request.toObject(message.get_account_nonce, options);
                            if (options.oneofs)
                                object.request = "get_account_nonce";
                        }
                        if (message.get_account_rc != null && message.hasOwnProperty("get_account_rc")) {
                            object.get_account_rc = $root.koinos.rpc.chain.get_account_rc_request.toObject(message.get_account_rc, options);
                            if (options.oneofs)
                                object.request = "get_account_rc";
                        }
                        if (message.get_resource_limits != null && message.hasOwnProperty("get_resource_limits")) {
                            object.get_resource_limits = $root.koinos.rpc.chain.get_resource_limits_request.toObject(message.get_resource_limits, options);
                            if (options.oneofs)
                                object.request = "get_resource_limits";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this chain_request to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.chain_request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    chain_request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return chain_request;
                })();
    
                chain.chain_response = (function() {
    
                    /**
                     * Properties of a chain_response.
                     * @memberof koinos.rpc.chain
                     * @interface Ichain_response
                     * @property {koinos.rpc.Ireserved_rpc|null} [reserved] chain_response reserved
                     * @property {koinos.rpc.Ierror_response|null} [error] chain_response error
                     * @property {koinos.rpc.chain.Isubmit_block_response|null} [submit_block] chain_response submit_block
                     * @property {koinos.rpc.chain.Isubmit_transaction_response|null} [submit_transaction] chain_response submit_transaction
                     * @property {koinos.rpc.chain.Iget_head_info_response|null} [get_head_info] chain_response get_head_info
                     * @property {koinos.rpc.chain.Iget_chain_id_response|null} [get_chain_id] chain_response get_chain_id
                     * @property {koinos.rpc.chain.Iget_fork_heads_response|null} [get_fork_heads] chain_response get_fork_heads
                     * @property {koinos.rpc.chain.Iread_contract_response|null} [read_contract] chain_response read_contract
                     * @property {koinos.rpc.chain.Iget_account_nonce_response|null} [get_account_nonce] chain_response get_account_nonce
                     * @property {koinos.rpc.chain.Iget_account_rc_response|null} [get_account_rc] chain_response get_account_rc
                     * @property {koinos.rpc.chain.Iget_resource_limits_response|null} [get_resource_limits] chain_response get_resource_limits
                     */
    
                    /**
                     * Constructs a new chain_response.
                     * @memberof koinos.rpc.chain
                     * @classdesc Represents a chain_response.
                     * @implements Ichain_response
                     * @constructor
                     * @param {koinos.rpc.chain.Ichain_response=} [properties] Properties to set
                     */
                    function chain_response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * chain_response reserved.
                     * @member {koinos.rpc.Ireserved_rpc|null|undefined} reserved
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.reserved = null;
    
                    /**
                     * chain_response error.
                     * @member {koinos.rpc.Ierror_response|null|undefined} error
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.error = null;
    
                    /**
                     * chain_response submit_block.
                     * @member {koinos.rpc.chain.Isubmit_block_response|null|undefined} submit_block
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.submit_block = null;
    
                    /**
                     * chain_response submit_transaction.
                     * @member {koinos.rpc.chain.Isubmit_transaction_response|null|undefined} submit_transaction
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.submit_transaction = null;
    
                    /**
                     * chain_response get_head_info.
                     * @member {koinos.rpc.chain.Iget_head_info_response|null|undefined} get_head_info
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.get_head_info = null;
    
                    /**
                     * chain_response get_chain_id.
                     * @member {koinos.rpc.chain.Iget_chain_id_response|null|undefined} get_chain_id
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.get_chain_id = null;
    
                    /**
                     * chain_response get_fork_heads.
                     * @member {koinos.rpc.chain.Iget_fork_heads_response|null|undefined} get_fork_heads
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.get_fork_heads = null;
    
                    /**
                     * chain_response read_contract.
                     * @member {koinos.rpc.chain.Iread_contract_response|null|undefined} read_contract
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.read_contract = null;
    
                    /**
                     * chain_response get_account_nonce.
                     * @member {koinos.rpc.chain.Iget_account_nonce_response|null|undefined} get_account_nonce
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.get_account_nonce = null;
    
                    /**
                     * chain_response get_account_rc.
                     * @member {koinos.rpc.chain.Iget_account_rc_response|null|undefined} get_account_rc
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.get_account_rc = null;
    
                    /**
                     * chain_response get_resource_limits.
                     * @member {koinos.rpc.chain.Iget_resource_limits_response|null|undefined} get_resource_limits
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    chain_response.prototype.get_resource_limits = null;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * chain_response response.
                     * @member {"reserved"|"error"|"submit_block"|"submit_transaction"|"get_head_info"|"get_chain_id"|"get_fork_heads"|"read_contract"|"get_account_nonce"|"get_account_rc"|"get_resource_limits"|undefined} response
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     */
                    Object.defineProperty(chain_response.prototype, "response", {
                        get: $util.oneOfGetter($oneOfFields = ["reserved", "error", "submit_block", "submit_transaction", "get_head_info", "get_chain_id", "get_fork_heads", "read_contract", "get_account_nonce", "get_account_rc", "get_resource_limits"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new chain_response instance using the specified properties.
                     * @function create
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {koinos.rpc.chain.Ichain_response=} [properties] Properties to set
                     * @returns {koinos.rpc.chain.chain_response} chain_response instance
                     */
                    chain_response.create = function create(properties) {
                        return new chain_response(properties);
                    };
    
                    /**
                     * Encodes the specified chain_response message. Does not implicitly {@link koinos.rpc.chain.chain_response.verify|verify} messages.
                     * @function encode
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {koinos.rpc.chain.Ichain_response} message chain_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    chain_response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.reserved != null && Object.hasOwnProperty.call(message, "reserved"))
                            $root.koinos.rpc.reserved_rpc.encode(message.reserved, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                            $root.koinos.rpc.error_response.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.submit_block != null && Object.hasOwnProperty.call(message, "submit_block"))
                            $root.koinos.rpc.chain.submit_block_response.encode(message.submit_block, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.submit_transaction != null && Object.hasOwnProperty.call(message, "submit_transaction"))
                            $root.koinos.rpc.chain.submit_transaction_response.encode(message.submit_transaction, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.get_head_info != null && Object.hasOwnProperty.call(message, "get_head_info"))
                            $root.koinos.rpc.chain.get_head_info_response.encode(message.get_head_info, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.get_chain_id != null && Object.hasOwnProperty.call(message, "get_chain_id"))
                            $root.koinos.rpc.chain.get_chain_id_response.encode(message.get_chain_id, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.get_fork_heads != null && Object.hasOwnProperty.call(message, "get_fork_heads"))
                            $root.koinos.rpc.chain.get_fork_heads_response.encode(message.get_fork_heads, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        if (message.read_contract != null && Object.hasOwnProperty.call(message, "read_contract"))
                            $root.koinos.rpc.chain.read_contract_response.encode(message.read_contract, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                        if (message.get_account_nonce != null && Object.hasOwnProperty.call(message, "get_account_nonce"))
                            $root.koinos.rpc.chain.get_account_nonce_response.encode(message.get_account_nonce, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                        if (message.get_account_rc != null && Object.hasOwnProperty.call(message, "get_account_rc"))
                            $root.koinos.rpc.chain.get_account_rc_response.encode(message.get_account_rc, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                        if (message.get_resource_limits != null && Object.hasOwnProperty.call(message, "get_resource_limits"))
                            $root.koinos.rpc.chain.get_resource_limits_response.encode(message.get_resource_limits, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified chain_response message, length delimited. Does not implicitly {@link koinos.rpc.chain.chain_response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {koinos.rpc.chain.Ichain_response} message chain_response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    chain_response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a chain_response message from the specified reader or buffer.
                     * @function decode
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {koinos.rpc.chain.chain_response} chain_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    chain_response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.rpc.chain.chain_response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.reserved = $root.koinos.rpc.reserved_rpc.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.error = $root.koinos.rpc.error_response.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.submit_block = $root.koinos.rpc.chain.submit_block_response.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.submit_transaction = $root.koinos.rpc.chain.submit_transaction_response.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.get_head_info = $root.koinos.rpc.chain.get_head_info_response.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.get_chain_id = $root.koinos.rpc.chain.get_chain_id_response.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.get_fork_heads = $root.koinos.rpc.chain.get_fork_heads_response.decode(reader, reader.uint32());
                                break;
                            case 8:
                                message.read_contract = $root.koinos.rpc.chain.read_contract_response.decode(reader, reader.uint32());
                                break;
                            case 9:
                                message.get_account_nonce = $root.koinos.rpc.chain.get_account_nonce_response.decode(reader, reader.uint32());
                                break;
                            case 10:
                                message.get_account_rc = $root.koinos.rpc.chain.get_account_rc_response.decode(reader, reader.uint32());
                                break;
                            case 11:
                                message.get_resource_limits = $root.koinos.rpc.chain.get_resource_limits_response.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a chain_response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {koinos.rpc.chain.chain_response} chain_response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    chain_response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a chain_response message.
                     * @function verify
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    chain_response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.reserved_rpc.verify(message.reserved);
                                if (error)
                                    return "reserved." + error;
                            }
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.error_response.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                        }
                        if (message.submit_block != null && message.hasOwnProperty("submit_block")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.submit_block_response.verify(message.submit_block);
                                if (error)
                                    return "submit_block." + error;
                            }
                        }
                        if (message.submit_transaction != null && message.hasOwnProperty("submit_transaction")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.submit_transaction_response.verify(message.submit_transaction);
                                if (error)
                                    return "submit_transaction." + error;
                            }
                        }
                        if (message.get_head_info != null && message.hasOwnProperty("get_head_info")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_head_info_response.verify(message.get_head_info);
                                if (error)
                                    return "get_head_info." + error;
                            }
                        }
                        if (message.get_chain_id != null && message.hasOwnProperty("get_chain_id")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_chain_id_response.verify(message.get_chain_id);
                                if (error)
                                    return "get_chain_id." + error;
                            }
                        }
                        if (message.get_fork_heads != null && message.hasOwnProperty("get_fork_heads")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_fork_heads_response.verify(message.get_fork_heads);
                                if (error)
                                    return "get_fork_heads." + error;
                            }
                        }
                        if (message.read_contract != null && message.hasOwnProperty("read_contract")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.read_contract_response.verify(message.read_contract);
                                if (error)
                                    return "read_contract." + error;
                            }
                        }
                        if (message.get_account_nonce != null && message.hasOwnProperty("get_account_nonce")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_account_nonce_response.verify(message.get_account_nonce);
                                if (error)
                                    return "get_account_nonce." + error;
                            }
                        }
                        if (message.get_account_rc != null && message.hasOwnProperty("get_account_rc")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_account_rc_response.verify(message.get_account_rc);
                                if (error)
                                    return "get_account_rc." + error;
                            }
                        }
                        if (message.get_resource_limits != null && message.hasOwnProperty("get_resource_limits")) {
                            if (properties.response === 1)
                                return "response: multiple values";
                            properties.response = 1;
                            {
                                var error = $root.koinos.rpc.chain.get_resource_limits_response.verify(message.get_resource_limits);
                                if (error)
                                    return "get_resource_limits." + error;
                            }
                        }
                        return null;
                    };
    
                    /**
                     * Creates a chain_response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {koinos.rpc.chain.chain_response} chain_response
                     */
                    chain_response.fromObject = function fromObject(object) {
                        if (object instanceof $root.koinos.rpc.chain.chain_response)
                            return object;
                        var message = new $root.koinos.rpc.chain.chain_response();
                        if (object.reserved != null) {
                            if (typeof object.reserved !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.reserved: object expected");
                            message.reserved = $root.koinos.rpc.reserved_rpc.fromObject(object.reserved);
                        }
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.error: object expected");
                            message.error = $root.koinos.rpc.error_response.fromObject(object.error);
                        }
                        if (object.submit_block != null) {
                            if (typeof object.submit_block !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.submit_block: object expected");
                            message.submit_block = $root.koinos.rpc.chain.submit_block_response.fromObject(object.submit_block);
                        }
                        if (object.submit_transaction != null) {
                            if (typeof object.submit_transaction !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.submit_transaction: object expected");
                            message.submit_transaction = $root.koinos.rpc.chain.submit_transaction_response.fromObject(object.submit_transaction);
                        }
                        if (object.get_head_info != null) {
                            if (typeof object.get_head_info !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.get_head_info: object expected");
                            message.get_head_info = $root.koinos.rpc.chain.get_head_info_response.fromObject(object.get_head_info);
                        }
                        if (object.get_chain_id != null) {
                            if (typeof object.get_chain_id !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.get_chain_id: object expected");
                            message.get_chain_id = $root.koinos.rpc.chain.get_chain_id_response.fromObject(object.get_chain_id);
                        }
                        if (object.get_fork_heads != null) {
                            if (typeof object.get_fork_heads !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.get_fork_heads: object expected");
                            message.get_fork_heads = $root.koinos.rpc.chain.get_fork_heads_response.fromObject(object.get_fork_heads);
                        }
                        if (object.read_contract != null) {
                            if (typeof object.read_contract !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.read_contract: object expected");
                            message.read_contract = $root.koinos.rpc.chain.read_contract_response.fromObject(object.read_contract);
                        }
                        if (object.get_account_nonce != null) {
                            if (typeof object.get_account_nonce !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.get_account_nonce: object expected");
                            message.get_account_nonce = $root.koinos.rpc.chain.get_account_nonce_response.fromObject(object.get_account_nonce);
                        }
                        if (object.get_account_rc != null) {
                            if (typeof object.get_account_rc !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.get_account_rc: object expected");
                            message.get_account_rc = $root.koinos.rpc.chain.get_account_rc_response.fromObject(object.get_account_rc);
                        }
                        if (object.get_resource_limits != null) {
                            if (typeof object.get_resource_limits !== "object")
                                throw TypeError(".koinos.rpc.chain.chain_response.get_resource_limits: object expected");
                            message.get_resource_limits = $root.koinos.rpc.chain.get_resource_limits_response.fromObject(object.get_resource_limits);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a chain_response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof koinos.rpc.chain.chain_response
                     * @static
                     * @param {koinos.rpc.chain.chain_response} message chain_response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    chain_response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.reserved != null && message.hasOwnProperty("reserved")) {
                            object.reserved = $root.koinos.rpc.reserved_rpc.toObject(message.reserved, options);
                            if (options.oneofs)
                                object.response = "reserved";
                        }
                        if (message.error != null && message.hasOwnProperty("error")) {
                            object.error = $root.koinos.rpc.error_response.toObject(message.error, options);
                            if (options.oneofs)
                                object.response = "error";
                        }
                        if (message.submit_block != null && message.hasOwnProperty("submit_block")) {
                            object.submit_block = $root.koinos.rpc.chain.submit_block_response.toObject(message.submit_block, options);
                            if (options.oneofs)
                                object.response = "submit_block";
                        }
                        if (message.submit_transaction != null && message.hasOwnProperty("submit_transaction")) {
                            object.submit_transaction = $root.koinos.rpc.chain.submit_transaction_response.toObject(message.submit_transaction, options);
                            if (options.oneofs)
                                object.response = "submit_transaction";
                        }
                        if (message.get_head_info != null && message.hasOwnProperty("get_head_info")) {
                            object.get_head_info = $root.koinos.rpc.chain.get_head_info_response.toObject(message.get_head_info, options);
                            if (options.oneofs)
                                object.response = "get_head_info";
                        }
                        if (message.get_chain_id != null && message.hasOwnProperty("get_chain_id")) {
                            object.get_chain_id = $root.koinos.rpc.chain.get_chain_id_response.toObject(message.get_chain_id, options);
                            if (options.oneofs)
                                object.response = "get_chain_id";
                        }
                        if (message.get_fork_heads != null && message.hasOwnProperty("get_fork_heads")) {
                            object.get_fork_heads = $root.koinos.rpc.chain.get_fork_heads_response.toObject(message.get_fork_heads, options);
                            if (options.oneofs)
                                object.response = "get_fork_heads";
                        }
                        if (message.read_contract != null && message.hasOwnProperty("read_contract")) {
                            object.read_contract = $root.koinos.rpc.chain.read_contract_response.toObject(message.read_contract, options);
                            if (options.oneofs)
                                object.response = "read_contract";
                        }
                        if (message.get_account_nonce != null && message.hasOwnProperty("get_account_nonce")) {
                            object.get_account_nonce = $root.koinos.rpc.chain.get_account_nonce_response.toObject(message.get_account_nonce, options);
                            if (options.oneofs)
                                object.response = "get_account_nonce";
                        }
                        if (message.get_account_rc != null && message.hasOwnProperty("get_account_rc")) {
                            object.get_account_rc = $root.koinos.rpc.chain.get_account_rc_response.toObject(message.get_account_rc, options);
                            if (options.oneofs)
                                object.response = "get_account_rc";
                        }
                        if (message.get_resource_limits != null && message.hasOwnProperty("get_resource_limits")) {
                            object.get_resource_limits = $root.koinos.rpc.chain.get_resource_limits_response.toObject(message.get_resource_limits, options);
                            if (options.oneofs)
                                object.response = "get_resource_limits";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this chain_response to JSON.
                     * @function toJSON
                     * @memberof koinos.rpc.chain.chain_response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    chain_response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return chain_response;
                })();
    
                return chain;
            })();
    
            return rpc;
        })();
    
        koinos.protocol = (function() {
    
            /**
             * Namespace protocol.
             * @memberof koinos
             * @namespace
             */
            var protocol = {};
    
            protocol.event_data = (function() {
    
                /**
                 * Properties of an event_data.
                 * @memberof koinos.protocol
                 * @interface Ievent_data
                 * @property {number|null} [sequence] event_data sequence
                 * @property {Uint8Array|null} [source] event_data source
                 * @property {string|null} [name] event_data name
                 * @property {Uint8Array|null} [data] event_data data
                 * @property {Array.<Uint8Array>|null} [impacted] event_data impacted
                 */
    
                /**
                 * Constructs a new event_data.
                 * @memberof koinos.protocol
                 * @classdesc Represents an event_data.
                 * @implements Ievent_data
                 * @constructor
                 * @param {koinos.protocol.Ievent_data=} [properties] Properties to set
                 */
                function event_data(properties) {
                    this.impacted = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * event_data sequence.
                 * @member {number} sequence
                 * @memberof koinos.protocol.event_data
                 * @instance
                 */
                event_data.prototype.sequence = 0;
    
                /**
                 * event_data source.
                 * @member {Uint8Array} source
                 * @memberof koinos.protocol.event_data
                 * @instance
                 */
                event_data.prototype.source = $util.newBuffer([]);
    
                /**
                 * event_data name.
                 * @member {string} name
                 * @memberof koinos.protocol.event_data
                 * @instance
                 */
                event_data.prototype.name = "";
    
                /**
                 * event_data data.
                 * @member {Uint8Array} data
                 * @memberof koinos.protocol.event_data
                 * @instance
                 */
                event_data.prototype.data = $util.newBuffer([]);
    
                /**
                 * event_data impacted.
                 * @member {Array.<Uint8Array>} impacted
                 * @memberof koinos.protocol.event_data
                 * @instance
                 */
                event_data.prototype.impacted = $util.emptyArray;
    
                /**
                 * Creates a new event_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {koinos.protocol.Ievent_data=} [properties] Properties to set
                 * @returns {koinos.protocol.event_data} event_data instance
                 */
                event_data.create = function create(properties) {
                    return new event_data(properties);
                };
    
                /**
                 * Encodes the specified event_data message. Does not implicitly {@link koinos.protocol.event_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {koinos.protocol.Ievent_data} message event_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sequence != null && Object.hasOwnProperty.call(message, "sequence"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sequence);
                    if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.source);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                    if (message.impacted != null && message.impacted.length)
                        for (var i = 0; i < message.impacted.length; ++i)
                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.impacted[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified event_data message, length delimited. Does not implicitly {@link koinos.protocol.event_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {koinos.protocol.Ievent_data} message event_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an event_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.event_data} event_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.event_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.sequence = reader.uint32();
                            break;
                        case 2:
                            message.source = reader.bytes();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            message.data = reader.bytes();
                            break;
                        case 5:
                            if (!(message.impacted && message.impacted.length))
                                message.impacted = [];
                            message.impacted.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an event_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.event_data} event_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an event_data message.
                 * @function verify
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                event_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        if (!$util.isInteger(message.sequence))
                            return "sequence: integer expected";
                    if (message.source != null && message.hasOwnProperty("source"))
                        if (!(message.source && typeof message.source.length === "number" || $util.isString(message.source)))
                            return "source: buffer expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    if (message.impacted != null && message.hasOwnProperty("impacted")) {
                        if (!Array.isArray(message.impacted))
                            return "impacted: array expected";
                        for (var i = 0; i < message.impacted.length; ++i)
                            if (!(message.impacted[i] && typeof message.impacted[i].length === "number" || $util.isString(message.impacted[i])))
                                return "impacted: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an event_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.event_data} event_data
                 */
                event_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.event_data)
                        return object;
                    var message = new $root.koinos.protocol.event_data();
                    if (object.sequence != null)
                        message.sequence = object.sequence >>> 0;
                    if (object.source != null)
                        if (typeof object.source === "string")
                            $util.base64.decode(object.source, message.source = $util.newBuffer($util.base64.length(object.source)), 0);
                        else if (object.source.length)
                            message.source = object.source;
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    if (object.impacted) {
                        if (!Array.isArray(object.impacted))
                            throw TypeError(".koinos.protocol.event_data.impacted: array expected");
                        message.impacted = [];
                        for (var i = 0; i < object.impacted.length; ++i)
                            if (typeof object.impacted[i] === "string")
                                $util.base64.decode(object.impacted[i], message.impacted[i] = $util.newBuffer($util.base64.length(object.impacted[i])), 0);
                            else if (object.impacted[i].length)
                                message.impacted[i] = object.impacted[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an event_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.event_data
                 * @static
                 * @param {koinos.protocol.event_data} message event_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                event_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.impacted = [];
                    if (options.defaults) {
                        object.sequence = 0;
                        if (options.bytes === String)
                            object.source = "";
                        else {
                            object.source = [];
                            if (options.bytes !== Array)
                                object.source = $util.newBuffer(object.source);
                        }
                        object.name = "";
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.sequence != null && message.hasOwnProperty("sequence"))
                        object.sequence = message.sequence;
                    if (message.source != null && message.hasOwnProperty("source"))
                        object.source = options.bytes === String ? $util.base64.encode(message.source, 0, message.source.length) : options.bytes === Array ? Array.prototype.slice.call(message.source) : message.source;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    if (message.impacted && message.impacted.length) {
                        object.impacted = [];
                        for (var j = 0; j < message.impacted.length; ++j)
                            object.impacted[j] = options.bytes === String ? $util.base64.encode(message.impacted[j], 0, message.impacted[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.impacted[j]) : message.impacted[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this event_data to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.event_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                event_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return event_data;
            })();
    
            protocol.contract_call_bundle = (function() {
    
                /**
                 * Properties of a contract_call_bundle.
                 * @memberof koinos.protocol
                 * @interface Icontract_call_bundle
                 * @property {Uint8Array|null} [contract_id] contract_call_bundle contract_id
                 * @property {number|null} [entry_point] contract_call_bundle entry_point
                 */
    
                /**
                 * Constructs a new contract_call_bundle.
                 * @memberof koinos.protocol
                 * @classdesc Represents a contract_call_bundle.
                 * @implements Icontract_call_bundle
                 * @constructor
                 * @param {koinos.protocol.Icontract_call_bundle=} [properties] Properties to set
                 */
                function contract_call_bundle(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * contract_call_bundle contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.protocol.contract_call_bundle
                 * @instance
                 */
                contract_call_bundle.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * contract_call_bundle entry_point.
                 * @member {number} entry_point
                 * @memberof koinos.protocol.contract_call_bundle
                 * @instance
                 */
                contract_call_bundle.prototype.entry_point = 0;
    
                /**
                 * Creates a new contract_call_bundle instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {koinos.protocol.Icontract_call_bundle=} [properties] Properties to set
                 * @returns {koinos.protocol.contract_call_bundle} contract_call_bundle instance
                 */
                contract_call_bundle.create = function create(properties) {
                    return new contract_call_bundle(properties);
                };
    
                /**
                 * Encodes the specified contract_call_bundle message. Does not implicitly {@link koinos.protocol.contract_call_bundle.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {koinos.protocol.Icontract_call_bundle} message contract_call_bundle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                contract_call_bundle.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.entry_point != null && Object.hasOwnProperty.call(message, "entry_point"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entry_point);
                    return writer;
                };
    
                /**
                 * Encodes the specified contract_call_bundle message, length delimited. Does not implicitly {@link koinos.protocol.contract_call_bundle.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {koinos.protocol.Icontract_call_bundle} message contract_call_bundle message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                contract_call_bundle.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a contract_call_bundle message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.contract_call_bundle} contract_call_bundle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                contract_call_bundle.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.contract_call_bundle();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.entry_point = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a contract_call_bundle message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.contract_call_bundle} contract_call_bundle
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                contract_call_bundle.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a contract_call_bundle message.
                 * @function verify
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                contract_call_bundle.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        if (!$util.isInteger(message.entry_point))
                            return "entry_point: integer expected";
                    return null;
                };
    
                /**
                 * Creates a contract_call_bundle message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.contract_call_bundle} contract_call_bundle
                 */
                contract_call_bundle.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.contract_call_bundle)
                        return object;
                    var message = new $root.koinos.protocol.contract_call_bundle();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.entry_point != null)
                        message.entry_point = object.entry_point >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a contract_call_bundle message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.contract_call_bundle
                 * @static
                 * @param {koinos.protocol.contract_call_bundle} message contract_call_bundle
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                contract_call_bundle.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        object.entry_point = 0;
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        object.entry_point = message.entry_point;
                    return object;
                };
    
                /**
                 * Converts this contract_call_bundle to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.contract_call_bundle
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                contract_call_bundle.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return contract_call_bundle;
            })();
    
            protocol.system_call_target = (function() {
    
                /**
                 * Properties of a system_call_target.
                 * @memberof koinos.protocol
                 * @interface Isystem_call_target
                 * @property {number|null} [thunk_id] system_call_target thunk_id
                 * @property {koinos.protocol.Icontract_call_bundle|null} [system_call_bundle] system_call_target system_call_bundle
                 */
    
                /**
                 * Constructs a new system_call_target.
                 * @memberof koinos.protocol
                 * @classdesc Represents a system_call_target.
                 * @implements Isystem_call_target
                 * @constructor
                 * @param {koinos.protocol.Isystem_call_target=} [properties] Properties to set
                 */
                function system_call_target(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * system_call_target thunk_id.
                 * @member {number|null|undefined} thunk_id
                 * @memberof koinos.protocol.system_call_target
                 * @instance
                 */
                system_call_target.prototype.thunk_id = null;
    
                /**
                 * system_call_target system_call_bundle.
                 * @member {koinos.protocol.Icontract_call_bundle|null|undefined} system_call_bundle
                 * @memberof koinos.protocol.system_call_target
                 * @instance
                 */
                system_call_target.prototype.system_call_bundle = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * system_call_target target.
                 * @member {"thunk_id"|"system_call_bundle"|undefined} target
                 * @memberof koinos.protocol.system_call_target
                 * @instance
                 */
                Object.defineProperty(system_call_target.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["thunk_id", "system_call_bundle"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new system_call_target instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {koinos.protocol.Isystem_call_target=} [properties] Properties to set
                 * @returns {koinos.protocol.system_call_target} system_call_target instance
                 */
                system_call_target.create = function create(properties) {
                    return new system_call_target(properties);
                };
    
                /**
                 * Encodes the specified system_call_target message. Does not implicitly {@link koinos.protocol.system_call_target.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {koinos.protocol.Isystem_call_target} message system_call_target message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                system_call_target.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.thunk_id != null && Object.hasOwnProperty.call(message, "thunk_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.thunk_id);
                    if (message.system_call_bundle != null && Object.hasOwnProperty.call(message, "system_call_bundle"))
                        $root.koinos.protocol.contract_call_bundle.encode(message.system_call_bundle, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified system_call_target message, length delimited. Does not implicitly {@link koinos.protocol.system_call_target.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {koinos.protocol.Isystem_call_target} message system_call_target message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                system_call_target.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a system_call_target message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.system_call_target} system_call_target
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                system_call_target.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.system_call_target();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.thunk_id = reader.uint32();
                            break;
                        case 2:
                            message.system_call_bundle = $root.koinos.protocol.contract_call_bundle.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a system_call_target message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.system_call_target} system_call_target
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                system_call_target.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a system_call_target message.
                 * @function verify
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                system_call_target.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.thunk_id != null && message.hasOwnProperty("thunk_id")) {
                        properties.target = 1;
                        if (!$util.isInteger(message.thunk_id))
                            return "thunk_id: integer expected";
                    }
                    if (message.system_call_bundle != null && message.hasOwnProperty("system_call_bundle")) {
                        if (properties.target === 1)
                            return "target: multiple values";
                        properties.target = 1;
                        {
                            var error = $root.koinos.protocol.contract_call_bundle.verify(message.system_call_bundle);
                            if (error)
                                return "system_call_bundle." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a system_call_target message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.system_call_target} system_call_target
                 */
                system_call_target.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.system_call_target)
                        return object;
                    var message = new $root.koinos.protocol.system_call_target();
                    if (object.thunk_id != null)
                        message.thunk_id = object.thunk_id >>> 0;
                    if (object.system_call_bundle != null) {
                        if (typeof object.system_call_bundle !== "object")
                            throw TypeError(".koinos.protocol.system_call_target.system_call_bundle: object expected");
                        message.system_call_bundle = $root.koinos.protocol.contract_call_bundle.fromObject(object.system_call_bundle);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a system_call_target message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.system_call_target
                 * @static
                 * @param {koinos.protocol.system_call_target} message system_call_target
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                system_call_target.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.thunk_id != null && message.hasOwnProperty("thunk_id")) {
                        object.thunk_id = message.thunk_id;
                        if (options.oneofs)
                            object.target = "thunk_id";
                    }
                    if (message.system_call_bundle != null && message.hasOwnProperty("system_call_bundle")) {
                        object.system_call_bundle = $root.koinos.protocol.contract_call_bundle.toObject(message.system_call_bundle, options);
                        if (options.oneofs)
                            object.target = "system_call_bundle";
                    }
                    return object;
                };
    
                /**
                 * Converts this system_call_target to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.system_call_target
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                system_call_target.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return system_call_target;
            })();
    
            protocol.upload_contract_operation = (function() {
    
                /**
                 * Properties of an upload_contract_operation.
                 * @memberof koinos.protocol
                 * @interface Iupload_contract_operation
                 * @property {Uint8Array|null} [contract_id] upload_contract_operation contract_id
                 * @property {Uint8Array|null} [bytecode] upload_contract_operation bytecode
                 * @property {string|null} [abi] upload_contract_operation abi
                 * @property {boolean|null} [authorizes_call_contract] upload_contract_operation authorizes_call_contract
                 * @property {boolean|null} [authorizes_transaction_application] upload_contract_operation authorizes_transaction_application
                 * @property {boolean|null} [authorizes_upload_contract] upload_contract_operation authorizes_upload_contract
                 */
    
                /**
                 * Constructs a new upload_contract_operation.
                 * @memberof koinos.protocol
                 * @classdesc Represents an upload_contract_operation.
                 * @implements Iupload_contract_operation
                 * @constructor
                 * @param {koinos.protocol.Iupload_contract_operation=} [properties] Properties to set
                 */
                function upload_contract_operation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * upload_contract_operation contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 */
                upload_contract_operation.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * upload_contract_operation bytecode.
                 * @member {Uint8Array} bytecode
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 */
                upload_contract_operation.prototype.bytecode = $util.newBuffer([]);
    
                /**
                 * upload_contract_operation abi.
                 * @member {string} abi
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 */
                upload_contract_operation.prototype.abi = "";
    
                /**
                 * upload_contract_operation authorizes_call_contract.
                 * @member {boolean} authorizes_call_contract
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 */
                upload_contract_operation.prototype.authorizes_call_contract = false;
    
                /**
                 * upload_contract_operation authorizes_transaction_application.
                 * @member {boolean} authorizes_transaction_application
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 */
                upload_contract_operation.prototype.authorizes_transaction_application = false;
    
                /**
                 * upload_contract_operation authorizes_upload_contract.
                 * @member {boolean} authorizes_upload_contract
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 */
                upload_contract_operation.prototype.authorizes_upload_contract = false;
    
                /**
                 * Creates a new upload_contract_operation instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {koinos.protocol.Iupload_contract_operation=} [properties] Properties to set
                 * @returns {koinos.protocol.upload_contract_operation} upload_contract_operation instance
                 */
                upload_contract_operation.create = function create(properties) {
                    return new upload_contract_operation(properties);
                };
    
                /**
                 * Encodes the specified upload_contract_operation message. Does not implicitly {@link koinos.protocol.upload_contract_operation.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {koinos.protocol.Iupload_contract_operation} message upload_contract_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                upload_contract_operation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.bytecode != null && Object.hasOwnProperty.call(message, "bytecode"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bytecode);
                    if (message.abi != null && Object.hasOwnProperty.call(message, "abi"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.abi);
                    if (message.authorizes_call_contract != null && Object.hasOwnProperty.call(message, "authorizes_call_contract"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.authorizes_call_contract);
                    if (message.authorizes_transaction_application != null && Object.hasOwnProperty.call(message, "authorizes_transaction_application"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.authorizes_transaction_application);
                    if (message.authorizes_upload_contract != null && Object.hasOwnProperty.call(message, "authorizes_upload_contract"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.authorizes_upload_contract);
                    return writer;
                };
    
                /**
                 * Encodes the specified upload_contract_operation message, length delimited. Does not implicitly {@link koinos.protocol.upload_contract_operation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {koinos.protocol.Iupload_contract_operation} message upload_contract_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                upload_contract_operation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an upload_contract_operation message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.upload_contract_operation} upload_contract_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                upload_contract_operation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.upload_contract_operation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.bytecode = reader.bytes();
                            break;
                        case 3:
                            message.abi = reader.string();
                            break;
                        case 4:
                            message.authorizes_call_contract = reader.bool();
                            break;
                        case 5:
                            message.authorizes_transaction_application = reader.bool();
                            break;
                        case 6:
                            message.authorizes_upload_contract = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an upload_contract_operation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.upload_contract_operation} upload_contract_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                upload_contract_operation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an upload_contract_operation message.
                 * @function verify
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                upload_contract_operation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                        if (!(message.bytecode && typeof message.bytecode.length === "number" || $util.isString(message.bytecode)))
                            return "bytecode: buffer expected";
                    if (message.abi != null && message.hasOwnProperty("abi"))
                        if (!$util.isString(message.abi))
                            return "abi: string expected";
                    if (message.authorizes_call_contract != null && message.hasOwnProperty("authorizes_call_contract"))
                        if (typeof message.authorizes_call_contract !== "boolean")
                            return "authorizes_call_contract: boolean expected";
                    if (message.authorizes_transaction_application != null && message.hasOwnProperty("authorizes_transaction_application"))
                        if (typeof message.authorizes_transaction_application !== "boolean")
                            return "authorizes_transaction_application: boolean expected";
                    if (message.authorizes_upload_contract != null && message.hasOwnProperty("authorizes_upload_contract"))
                        if (typeof message.authorizes_upload_contract !== "boolean")
                            return "authorizes_upload_contract: boolean expected";
                    return null;
                };
    
                /**
                 * Creates an upload_contract_operation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.upload_contract_operation} upload_contract_operation
                 */
                upload_contract_operation.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.upload_contract_operation)
                        return object;
                    var message = new $root.koinos.protocol.upload_contract_operation();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.bytecode != null)
                        if (typeof object.bytecode === "string")
                            $util.base64.decode(object.bytecode, message.bytecode = $util.newBuffer($util.base64.length(object.bytecode)), 0);
                        else if (object.bytecode.length)
                            message.bytecode = object.bytecode;
                    if (object.abi != null)
                        message.abi = String(object.abi);
                    if (object.authorizes_call_contract != null)
                        message.authorizes_call_contract = Boolean(object.authorizes_call_contract);
                    if (object.authorizes_transaction_application != null)
                        message.authorizes_transaction_application = Boolean(object.authorizes_transaction_application);
                    if (object.authorizes_upload_contract != null)
                        message.authorizes_upload_contract = Boolean(object.authorizes_upload_contract);
                    return message;
                };
    
                /**
                 * Creates a plain object from an upload_contract_operation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.upload_contract_operation
                 * @static
                 * @param {koinos.protocol.upload_contract_operation} message upload_contract_operation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                upload_contract_operation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        if (options.bytes === String)
                            object.bytecode = "";
                        else {
                            object.bytecode = [];
                            if (options.bytes !== Array)
                                object.bytecode = $util.newBuffer(object.bytecode);
                        }
                        object.abi = "";
                        object.authorizes_call_contract = false;
                        object.authorizes_transaction_application = false;
                        object.authorizes_upload_contract = false;
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                        object.bytecode = options.bytes === String ? $util.base64.encode(message.bytecode, 0, message.bytecode.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytecode) : message.bytecode;
                    if (message.abi != null && message.hasOwnProperty("abi"))
                        object.abi = message.abi;
                    if (message.authorizes_call_contract != null && message.hasOwnProperty("authorizes_call_contract"))
                        object.authorizes_call_contract = message.authorizes_call_contract;
                    if (message.authorizes_transaction_application != null && message.hasOwnProperty("authorizes_transaction_application"))
                        object.authorizes_transaction_application = message.authorizes_transaction_application;
                    if (message.authorizes_upload_contract != null && message.hasOwnProperty("authorizes_upload_contract"))
                        object.authorizes_upload_contract = message.authorizes_upload_contract;
                    return object;
                };
    
                /**
                 * Converts this upload_contract_operation to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.upload_contract_operation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                upload_contract_operation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return upload_contract_operation;
            })();
    
            protocol.call_contract_operation = (function() {
    
                /**
                 * Properties of a call_contract_operation.
                 * @memberof koinos.protocol
                 * @interface Icall_contract_operation
                 * @property {Uint8Array|null} [contract_id] call_contract_operation contract_id
                 * @property {number|null} [entry_point] call_contract_operation entry_point
                 * @property {Uint8Array|null} [args] call_contract_operation args
                 */
    
                /**
                 * Constructs a new call_contract_operation.
                 * @memberof koinos.protocol
                 * @classdesc Represents a call_contract_operation.
                 * @implements Icall_contract_operation
                 * @constructor
                 * @param {koinos.protocol.Icall_contract_operation=} [properties] Properties to set
                 */
                function call_contract_operation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * call_contract_operation contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.protocol.call_contract_operation
                 * @instance
                 */
                call_contract_operation.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * call_contract_operation entry_point.
                 * @member {number} entry_point
                 * @memberof koinos.protocol.call_contract_operation
                 * @instance
                 */
                call_contract_operation.prototype.entry_point = 0;
    
                /**
                 * call_contract_operation args.
                 * @member {Uint8Array} args
                 * @memberof koinos.protocol.call_contract_operation
                 * @instance
                 */
                call_contract_operation.prototype.args = $util.newBuffer([]);
    
                /**
                 * Creates a new call_contract_operation instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {koinos.protocol.Icall_contract_operation=} [properties] Properties to set
                 * @returns {koinos.protocol.call_contract_operation} call_contract_operation instance
                 */
                call_contract_operation.create = function create(properties) {
                    return new call_contract_operation(properties);
                };
    
                /**
                 * Encodes the specified call_contract_operation message. Does not implicitly {@link koinos.protocol.call_contract_operation.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {koinos.protocol.Icall_contract_operation} message call_contract_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_contract_operation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.entry_point != null && Object.hasOwnProperty.call(message, "entry_point"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entry_point);
                    if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.args);
                    return writer;
                };
    
                /**
                 * Encodes the specified call_contract_operation message, length delimited. Does not implicitly {@link koinos.protocol.call_contract_operation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {koinos.protocol.Icall_contract_operation} message call_contract_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_contract_operation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a call_contract_operation message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.call_contract_operation} call_contract_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_contract_operation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.call_contract_operation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.entry_point = reader.uint32();
                            break;
                        case 3:
                            message.args = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a call_contract_operation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.call_contract_operation} call_contract_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_contract_operation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a call_contract_operation message.
                 * @function verify
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                call_contract_operation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        if (!$util.isInteger(message.entry_point))
                            return "entry_point: integer expected";
                    if (message.args != null && message.hasOwnProperty("args"))
                        if (!(message.args && typeof message.args.length === "number" || $util.isString(message.args)))
                            return "args: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a call_contract_operation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.call_contract_operation} call_contract_operation
                 */
                call_contract_operation.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.call_contract_operation)
                        return object;
                    var message = new $root.koinos.protocol.call_contract_operation();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.entry_point != null)
                        message.entry_point = object.entry_point >>> 0;
                    if (object.args != null)
                        if (typeof object.args === "string")
                            $util.base64.decode(object.args, message.args = $util.newBuffer($util.base64.length(object.args)), 0);
                        else if (object.args.length)
                            message.args = object.args;
                    return message;
                };
    
                /**
                 * Creates a plain object from a call_contract_operation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.call_contract_operation
                 * @static
                 * @param {koinos.protocol.call_contract_operation} message call_contract_operation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                call_contract_operation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        object.entry_point = 0;
                        if (options.bytes === String)
                            object.args = "";
                        else {
                            object.args = [];
                            if (options.bytes !== Array)
                                object.args = $util.newBuffer(object.args);
                        }
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        object.entry_point = message.entry_point;
                    if (message.args != null && message.hasOwnProperty("args"))
                        object.args = options.bytes === String ? $util.base64.encode(message.args, 0, message.args.length) : options.bytes === Array ? Array.prototype.slice.call(message.args) : message.args;
                    return object;
                };
    
                /**
                 * Converts this call_contract_operation to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.call_contract_operation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                call_contract_operation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return call_contract_operation;
            })();
    
            protocol.set_system_call_operation = (function() {
    
                /**
                 * Properties of a set_system_call_operation.
                 * @memberof koinos.protocol
                 * @interface Iset_system_call_operation
                 * @property {number|null} [call_id] set_system_call_operation call_id
                 * @property {koinos.protocol.Isystem_call_target|null} [target] set_system_call_operation target
                 */
    
                /**
                 * Constructs a new set_system_call_operation.
                 * @memberof koinos.protocol
                 * @classdesc Represents a set_system_call_operation.
                 * @implements Iset_system_call_operation
                 * @constructor
                 * @param {koinos.protocol.Iset_system_call_operation=} [properties] Properties to set
                 */
                function set_system_call_operation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * set_system_call_operation call_id.
                 * @member {number} call_id
                 * @memberof koinos.protocol.set_system_call_operation
                 * @instance
                 */
                set_system_call_operation.prototype.call_id = 0;
    
                /**
                 * set_system_call_operation target.
                 * @member {koinos.protocol.Isystem_call_target|null|undefined} target
                 * @memberof koinos.protocol.set_system_call_operation
                 * @instance
                 */
                set_system_call_operation.prototype.target = null;
    
                /**
                 * Creates a new set_system_call_operation instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {koinos.protocol.Iset_system_call_operation=} [properties] Properties to set
                 * @returns {koinos.protocol.set_system_call_operation} set_system_call_operation instance
                 */
                set_system_call_operation.create = function create(properties) {
                    return new set_system_call_operation(properties);
                };
    
                /**
                 * Encodes the specified set_system_call_operation message. Does not implicitly {@link koinos.protocol.set_system_call_operation.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {koinos.protocol.Iset_system_call_operation} message set_system_call_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_call_operation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.call_id != null && Object.hasOwnProperty.call(message, "call_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.call_id);
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.koinos.protocol.system_call_target.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified set_system_call_operation message, length delimited. Does not implicitly {@link koinos.protocol.set_system_call_operation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {koinos.protocol.Iset_system_call_operation} message set_system_call_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_call_operation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a set_system_call_operation message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.set_system_call_operation} set_system_call_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_call_operation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.set_system_call_operation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.call_id = reader.uint32();
                            break;
                        case 2:
                            message.target = $root.koinos.protocol.system_call_target.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a set_system_call_operation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.set_system_call_operation} set_system_call_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_call_operation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a set_system_call_operation message.
                 * @function verify
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                set_system_call_operation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.call_id != null && message.hasOwnProperty("call_id"))
                        if (!$util.isInteger(message.call_id))
                            return "call_id: integer expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        var error = $root.koinos.protocol.system_call_target.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a set_system_call_operation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.set_system_call_operation} set_system_call_operation
                 */
                set_system_call_operation.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.set_system_call_operation)
                        return object;
                    var message = new $root.koinos.protocol.set_system_call_operation();
                    if (object.call_id != null)
                        message.call_id = object.call_id >>> 0;
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".koinos.protocol.set_system_call_operation.target: object expected");
                        message.target = $root.koinos.protocol.system_call_target.fromObject(object.target);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a set_system_call_operation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.set_system_call_operation
                 * @static
                 * @param {koinos.protocol.set_system_call_operation} message set_system_call_operation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                set_system_call_operation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.call_id = 0;
                        object.target = null;
                    }
                    if (message.call_id != null && message.hasOwnProperty("call_id"))
                        object.call_id = message.call_id;
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.koinos.protocol.system_call_target.toObject(message.target, options);
                    return object;
                };
    
                /**
                 * Converts this set_system_call_operation to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.set_system_call_operation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                set_system_call_operation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return set_system_call_operation;
            })();
    
            protocol.set_system_contract_operation = (function() {
    
                /**
                 * Properties of a set_system_contract_operation.
                 * @memberof koinos.protocol
                 * @interface Iset_system_contract_operation
                 * @property {Uint8Array|null} [contract_id] set_system_contract_operation contract_id
                 * @property {boolean|null} [system_contract] set_system_contract_operation system_contract
                 */
    
                /**
                 * Constructs a new set_system_contract_operation.
                 * @memberof koinos.protocol
                 * @classdesc Represents a set_system_contract_operation.
                 * @implements Iset_system_contract_operation
                 * @constructor
                 * @param {koinos.protocol.Iset_system_contract_operation=} [properties] Properties to set
                 */
                function set_system_contract_operation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * set_system_contract_operation contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @instance
                 */
                set_system_contract_operation.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * set_system_contract_operation system_contract.
                 * @member {boolean} system_contract
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @instance
                 */
                set_system_contract_operation.prototype.system_contract = false;
    
                /**
                 * Creates a new set_system_contract_operation instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {koinos.protocol.Iset_system_contract_operation=} [properties] Properties to set
                 * @returns {koinos.protocol.set_system_contract_operation} set_system_contract_operation instance
                 */
                set_system_contract_operation.create = function create(properties) {
                    return new set_system_contract_operation(properties);
                };
    
                /**
                 * Encodes the specified set_system_contract_operation message. Does not implicitly {@link koinos.protocol.set_system_contract_operation.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {koinos.protocol.Iset_system_contract_operation} message set_system_contract_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_contract_operation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.system_contract != null && Object.hasOwnProperty.call(message, "system_contract"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.system_contract);
                    return writer;
                };
    
                /**
                 * Encodes the specified set_system_contract_operation message, length delimited. Does not implicitly {@link koinos.protocol.set_system_contract_operation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {koinos.protocol.Iset_system_contract_operation} message set_system_contract_operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_contract_operation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a set_system_contract_operation message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.set_system_contract_operation} set_system_contract_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_contract_operation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.set_system_contract_operation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.system_contract = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a set_system_contract_operation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.set_system_contract_operation} set_system_contract_operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_contract_operation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a set_system_contract_operation message.
                 * @function verify
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                set_system_contract_operation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.system_contract != null && message.hasOwnProperty("system_contract"))
                        if (typeof message.system_contract !== "boolean")
                            return "system_contract: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a set_system_contract_operation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.set_system_contract_operation} set_system_contract_operation
                 */
                set_system_contract_operation.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.set_system_contract_operation)
                        return object;
                    var message = new $root.koinos.protocol.set_system_contract_operation();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.system_contract != null)
                        message.system_contract = Boolean(object.system_contract);
                    return message;
                };
    
                /**
                 * Creates a plain object from a set_system_contract_operation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @static
                 * @param {koinos.protocol.set_system_contract_operation} message set_system_contract_operation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                set_system_contract_operation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        object.system_contract = false;
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.system_contract != null && message.hasOwnProperty("system_contract"))
                        object.system_contract = message.system_contract;
                    return object;
                };
    
                /**
                 * Converts this set_system_contract_operation to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.set_system_contract_operation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                set_system_contract_operation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return set_system_contract_operation;
            })();
    
            protocol.operation = (function() {
    
                /**
                 * Properties of an operation.
                 * @memberof koinos.protocol
                 * @interface Ioperation
                 * @property {koinos.protocol.Iupload_contract_operation|null} [upload_contract] operation upload_contract
                 * @property {koinos.protocol.Icall_contract_operation|null} [call_contract] operation call_contract
                 * @property {koinos.protocol.Iset_system_call_operation|null} [set_system_call] operation set_system_call
                 * @property {koinos.protocol.Iset_system_contract_operation|null} [set_system_contract] operation set_system_contract
                 */
    
                /**
                 * Constructs a new operation.
                 * @memberof koinos.protocol
                 * @classdesc Represents an operation.
                 * @implements Ioperation
                 * @constructor
                 * @param {koinos.protocol.Ioperation=} [properties] Properties to set
                 */
                function operation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * operation upload_contract.
                 * @member {koinos.protocol.Iupload_contract_operation|null|undefined} upload_contract
                 * @memberof koinos.protocol.operation
                 * @instance
                 */
                operation.prototype.upload_contract = null;
    
                /**
                 * operation call_contract.
                 * @member {koinos.protocol.Icall_contract_operation|null|undefined} call_contract
                 * @memberof koinos.protocol.operation
                 * @instance
                 */
                operation.prototype.call_contract = null;
    
                /**
                 * operation set_system_call.
                 * @member {koinos.protocol.Iset_system_call_operation|null|undefined} set_system_call
                 * @memberof koinos.protocol.operation
                 * @instance
                 */
                operation.prototype.set_system_call = null;
    
                /**
                 * operation set_system_contract.
                 * @member {koinos.protocol.Iset_system_contract_operation|null|undefined} set_system_contract
                 * @memberof koinos.protocol.operation
                 * @instance
                 */
                operation.prototype.set_system_contract = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * operation op.
                 * @member {"upload_contract"|"call_contract"|"set_system_call"|"set_system_contract"|undefined} op
                 * @memberof koinos.protocol.operation
                 * @instance
                 */
                Object.defineProperty(operation.prototype, "op", {
                    get: $util.oneOfGetter($oneOfFields = ["upload_contract", "call_contract", "set_system_call", "set_system_contract"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new operation instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {koinos.protocol.Ioperation=} [properties] Properties to set
                 * @returns {koinos.protocol.operation} operation instance
                 */
                operation.create = function create(properties) {
                    return new operation(properties);
                };
    
                /**
                 * Encodes the specified operation message. Does not implicitly {@link koinos.protocol.operation.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {koinos.protocol.Ioperation} message operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                operation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.upload_contract != null && Object.hasOwnProperty.call(message, "upload_contract"))
                        $root.koinos.protocol.upload_contract_operation.encode(message.upload_contract, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.call_contract != null && Object.hasOwnProperty.call(message, "call_contract"))
                        $root.koinos.protocol.call_contract_operation.encode(message.call_contract, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.set_system_call != null && Object.hasOwnProperty.call(message, "set_system_call"))
                        $root.koinos.protocol.set_system_call_operation.encode(message.set_system_call, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.set_system_contract != null && Object.hasOwnProperty.call(message, "set_system_contract"))
                        $root.koinos.protocol.set_system_contract_operation.encode(message.set_system_contract, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified operation message, length delimited. Does not implicitly {@link koinos.protocol.operation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {koinos.protocol.Ioperation} message operation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                operation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an operation message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.operation} operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                operation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.operation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.upload_contract = $root.koinos.protocol.upload_contract_operation.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.call_contract = $root.koinos.protocol.call_contract_operation.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.set_system_call = $root.koinos.protocol.set_system_call_operation.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.set_system_contract = $root.koinos.protocol.set_system_contract_operation.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an operation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.operation} operation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                operation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an operation message.
                 * @function verify
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                operation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.upload_contract != null && message.hasOwnProperty("upload_contract")) {
                        properties.op = 1;
                        {
                            var error = $root.koinos.protocol.upload_contract_operation.verify(message.upload_contract);
                            if (error)
                                return "upload_contract." + error;
                        }
                    }
                    if (message.call_contract != null && message.hasOwnProperty("call_contract")) {
                        if (properties.op === 1)
                            return "op: multiple values";
                        properties.op = 1;
                        {
                            var error = $root.koinos.protocol.call_contract_operation.verify(message.call_contract);
                            if (error)
                                return "call_contract." + error;
                        }
                    }
                    if (message.set_system_call != null && message.hasOwnProperty("set_system_call")) {
                        if (properties.op === 1)
                            return "op: multiple values";
                        properties.op = 1;
                        {
                            var error = $root.koinos.protocol.set_system_call_operation.verify(message.set_system_call);
                            if (error)
                                return "set_system_call." + error;
                        }
                    }
                    if (message.set_system_contract != null && message.hasOwnProperty("set_system_contract")) {
                        if (properties.op === 1)
                            return "op: multiple values";
                        properties.op = 1;
                        {
                            var error = $root.koinos.protocol.set_system_contract_operation.verify(message.set_system_contract);
                            if (error)
                                return "set_system_contract." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an operation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.operation} operation
                 */
                operation.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.operation)
                        return object;
                    var message = new $root.koinos.protocol.operation();
                    if (object.upload_contract != null) {
                        if (typeof object.upload_contract !== "object")
                            throw TypeError(".koinos.protocol.operation.upload_contract: object expected");
                        message.upload_contract = $root.koinos.protocol.upload_contract_operation.fromObject(object.upload_contract);
                    }
                    if (object.call_contract != null) {
                        if (typeof object.call_contract !== "object")
                            throw TypeError(".koinos.protocol.operation.call_contract: object expected");
                        message.call_contract = $root.koinos.protocol.call_contract_operation.fromObject(object.call_contract);
                    }
                    if (object.set_system_call != null) {
                        if (typeof object.set_system_call !== "object")
                            throw TypeError(".koinos.protocol.operation.set_system_call: object expected");
                        message.set_system_call = $root.koinos.protocol.set_system_call_operation.fromObject(object.set_system_call);
                    }
                    if (object.set_system_contract != null) {
                        if (typeof object.set_system_contract !== "object")
                            throw TypeError(".koinos.protocol.operation.set_system_contract: object expected");
                        message.set_system_contract = $root.koinos.protocol.set_system_contract_operation.fromObject(object.set_system_contract);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an operation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.operation
                 * @static
                 * @param {koinos.protocol.operation} message operation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                operation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.upload_contract != null && message.hasOwnProperty("upload_contract")) {
                        object.upload_contract = $root.koinos.protocol.upload_contract_operation.toObject(message.upload_contract, options);
                        if (options.oneofs)
                            object.op = "upload_contract";
                    }
                    if (message.call_contract != null && message.hasOwnProperty("call_contract")) {
                        object.call_contract = $root.koinos.protocol.call_contract_operation.toObject(message.call_contract, options);
                        if (options.oneofs)
                            object.op = "call_contract";
                    }
                    if (message.set_system_call != null && message.hasOwnProperty("set_system_call")) {
                        object.set_system_call = $root.koinos.protocol.set_system_call_operation.toObject(message.set_system_call, options);
                        if (options.oneofs)
                            object.op = "set_system_call";
                    }
                    if (message.set_system_contract != null && message.hasOwnProperty("set_system_contract")) {
                        object.set_system_contract = $root.koinos.protocol.set_system_contract_operation.toObject(message.set_system_contract, options);
                        if (options.oneofs)
                            object.op = "set_system_contract";
                    }
                    return object;
                };
    
                /**
                 * Converts this operation to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.operation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                operation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return operation;
            })();
    
            protocol.transaction_header = (function() {
    
                /**
                 * Properties of a transaction_header.
                 * @memberof koinos.protocol
                 * @interface Itransaction_header
                 * @property {Uint8Array|null} [chain_id] transaction_header chain_id
                 * @property {number|Long|null} [rc_limit] transaction_header rc_limit
                 * @property {Uint8Array|null} [nonce] transaction_header nonce
                 * @property {Uint8Array|null} [operation_merkle_root] transaction_header operation_merkle_root
                 * @property {Uint8Array|null} [payer] transaction_header payer
                 * @property {Uint8Array|null} [payee] transaction_header payee
                 */
    
                /**
                 * Constructs a new transaction_header.
                 * @memberof koinos.protocol
                 * @classdesc Represents a transaction_header.
                 * @implements Itransaction_header
                 * @constructor
                 * @param {koinos.protocol.Itransaction_header=} [properties] Properties to set
                 */
                function transaction_header(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * transaction_header chain_id.
                 * @member {Uint8Array} chain_id
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 */
                transaction_header.prototype.chain_id = $util.newBuffer([]);
    
                /**
                 * transaction_header rc_limit.
                 * @member {number|Long} rc_limit
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 */
                transaction_header.prototype.rc_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_header nonce.
                 * @member {Uint8Array} nonce
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 */
                transaction_header.prototype.nonce = $util.newBuffer([]);
    
                /**
                 * transaction_header operation_merkle_root.
                 * @member {Uint8Array} operation_merkle_root
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 */
                transaction_header.prototype.operation_merkle_root = $util.newBuffer([]);
    
                /**
                 * transaction_header payer.
                 * @member {Uint8Array} payer
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 */
                transaction_header.prototype.payer = $util.newBuffer([]);
    
                /**
                 * transaction_header payee.
                 * @member {Uint8Array} payee
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 */
                transaction_header.prototype.payee = $util.newBuffer([]);
    
                /**
                 * Creates a new transaction_header instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {koinos.protocol.Itransaction_header=} [properties] Properties to set
                 * @returns {koinos.protocol.transaction_header} transaction_header instance
                 */
                transaction_header.create = function create(properties) {
                    return new transaction_header(properties);
                };
    
                /**
                 * Encodes the specified transaction_header message. Does not implicitly {@link koinos.protocol.transaction_header.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {koinos.protocol.Itransaction_header} message transaction_header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_header.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.chain_id != null && Object.hasOwnProperty.call(message, "chain_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.chain_id);
                    if (message.rc_limit != null && Object.hasOwnProperty.call(message, "rc_limit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rc_limit);
                    if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nonce);
                    if (message.operation_merkle_root != null && Object.hasOwnProperty.call(message, "operation_merkle_root"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.operation_merkle_root);
                    if (message.payer != null && Object.hasOwnProperty.call(message, "payer"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.payer);
                    if (message.payee != null && Object.hasOwnProperty.call(message, "payee"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payee);
                    return writer;
                };
    
                /**
                 * Encodes the specified transaction_header message, length delimited. Does not implicitly {@link koinos.protocol.transaction_header.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {koinos.protocol.Itransaction_header} message transaction_header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_header.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a transaction_header message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.transaction_header} transaction_header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_header.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.transaction_header();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.chain_id = reader.bytes();
                            break;
                        case 2:
                            message.rc_limit = reader.uint64();
                            break;
                        case 3:
                            message.nonce = reader.bytes();
                            break;
                        case 4:
                            message.operation_merkle_root = reader.bytes();
                            break;
                        case 5:
                            message.payer = reader.bytes();
                            break;
                        case 6:
                            message.payee = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a transaction_header message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.transaction_header} transaction_header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_header.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a transaction_header message.
                 * @function verify
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                transaction_header.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.chain_id != null && message.hasOwnProperty("chain_id"))
                        if (!(message.chain_id && typeof message.chain_id.length === "number" || $util.isString(message.chain_id)))
                            return "chain_id: buffer expected";
                    if (message.rc_limit != null && message.hasOwnProperty("rc_limit"))
                        if (!$util.isInteger(message.rc_limit) && !(message.rc_limit && $util.isInteger(message.rc_limit.low) && $util.isInteger(message.rc_limit.high)))
                            return "rc_limit: integer|Long expected";
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                            return "nonce: buffer expected";
                    if (message.operation_merkle_root != null && message.hasOwnProperty("operation_merkle_root"))
                        if (!(message.operation_merkle_root && typeof message.operation_merkle_root.length === "number" || $util.isString(message.operation_merkle_root)))
                            return "operation_merkle_root: buffer expected";
                    if (message.payer != null && message.hasOwnProperty("payer"))
                        if (!(message.payer && typeof message.payer.length === "number" || $util.isString(message.payer)))
                            return "payer: buffer expected";
                    if (message.payee != null && message.hasOwnProperty("payee"))
                        if (!(message.payee && typeof message.payee.length === "number" || $util.isString(message.payee)))
                            return "payee: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a transaction_header message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.transaction_header} transaction_header
                 */
                transaction_header.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.transaction_header)
                        return object;
                    var message = new $root.koinos.protocol.transaction_header();
                    if (object.chain_id != null)
                        if (typeof object.chain_id === "string")
                            $util.base64.decode(object.chain_id, message.chain_id = $util.newBuffer($util.base64.length(object.chain_id)), 0);
                        else if (object.chain_id.length)
                            message.chain_id = object.chain_id;
                    if (object.rc_limit != null)
                        if ($util.Long)
                            (message.rc_limit = $util.Long.fromValue(object.rc_limit)).unsigned = true;
                        else if (typeof object.rc_limit === "string")
                            message.rc_limit = parseInt(object.rc_limit, 10);
                        else if (typeof object.rc_limit === "number")
                            message.rc_limit = object.rc_limit;
                        else if (typeof object.rc_limit === "object")
                            message.rc_limit = new $util.LongBits(object.rc_limit.low >>> 0, object.rc_limit.high >>> 0).toNumber(true);
                    if (object.nonce != null)
                        if (typeof object.nonce === "string")
                            $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                        else if (object.nonce.length)
                            message.nonce = object.nonce;
                    if (object.operation_merkle_root != null)
                        if (typeof object.operation_merkle_root === "string")
                            $util.base64.decode(object.operation_merkle_root, message.operation_merkle_root = $util.newBuffer($util.base64.length(object.operation_merkle_root)), 0);
                        else if (object.operation_merkle_root.length)
                            message.operation_merkle_root = object.operation_merkle_root;
                    if (object.payer != null)
                        if (typeof object.payer === "string")
                            $util.base64.decode(object.payer, message.payer = $util.newBuffer($util.base64.length(object.payer)), 0);
                        else if (object.payer.length)
                            message.payer = object.payer;
                    if (object.payee != null)
                        if (typeof object.payee === "string")
                            $util.base64.decode(object.payee, message.payee = $util.newBuffer($util.base64.length(object.payee)), 0);
                        else if (object.payee.length)
                            message.payee = object.payee;
                    return message;
                };
    
                /**
                 * Creates a plain object from a transaction_header message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.transaction_header
                 * @static
                 * @param {koinos.protocol.transaction_header} message transaction_header
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                transaction_header.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.chain_id = "";
                        else {
                            object.chain_id = [];
                            if (options.bytes !== Array)
                                object.chain_id = $util.newBuffer(object.chain_id);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rc_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rc_limit = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.nonce = "";
                        else {
                            object.nonce = [];
                            if (options.bytes !== Array)
                                object.nonce = $util.newBuffer(object.nonce);
                        }
                        if (options.bytes === String)
                            object.operation_merkle_root = "";
                        else {
                            object.operation_merkle_root = [];
                            if (options.bytes !== Array)
                                object.operation_merkle_root = $util.newBuffer(object.operation_merkle_root);
                        }
                        if (options.bytes === String)
                            object.payer = "";
                        else {
                            object.payer = [];
                            if (options.bytes !== Array)
                                object.payer = $util.newBuffer(object.payer);
                        }
                        if (options.bytes === String)
                            object.payee = "";
                        else {
                            object.payee = [];
                            if (options.bytes !== Array)
                                object.payee = $util.newBuffer(object.payee);
                        }
                    }
                    if (message.chain_id != null && message.hasOwnProperty("chain_id"))
                        object.chain_id = options.bytes === String ? $util.base64.encode(message.chain_id, 0, message.chain_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.chain_id) : message.chain_id;
                    if (message.rc_limit != null && message.hasOwnProperty("rc_limit"))
                        if (typeof message.rc_limit === "number")
                            object.rc_limit = options.longs === String ? String(message.rc_limit) : message.rc_limit;
                        else
                            object.rc_limit = options.longs === String ? $util.Long.prototype.toString.call(message.rc_limit) : options.longs === Number ? new $util.LongBits(message.rc_limit.low >>> 0, message.rc_limit.high >>> 0).toNumber(true) : message.rc_limit;
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                    if (message.operation_merkle_root != null && message.hasOwnProperty("operation_merkle_root"))
                        object.operation_merkle_root = options.bytes === String ? $util.base64.encode(message.operation_merkle_root, 0, message.operation_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.operation_merkle_root) : message.operation_merkle_root;
                    if (message.payer != null && message.hasOwnProperty("payer"))
                        object.payer = options.bytes === String ? $util.base64.encode(message.payer, 0, message.payer.length) : options.bytes === Array ? Array.prototype.slice.call(message.payer) : message.payer;
                    if (message.payee != null && message.hasOwnProperty("payee"))
                        object.payee = options.bytes === String ? $util.base64.encode(message.payee, 0, message.payee.length) : options.bytes === Array ? Array.prototype.slice.call(message.payee) : message.payee;
                    return object;
                };
    
                /**
                 * Converts this transaction_header to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.transaction_header
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                transaction_header.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return transaction_header;
            })();
    
            protocol.transaction = (function() {
    
                /**
                 * Properties of a transaction.
                 * @memberof koinos.protocol
                 * @interface Itransaction
                 * @property {Uint8Array|null} [id] transaction id
                 * @property {koinos.protocol.Itransaction_header|null} [header] transaction header
                 * @property {Array.<koinos.protocol.Ioperation>|null} [operations] transaction operations
                 * @property {Array.<Uint8Array>|null} [signatures] transaction signatures
                 */
    
                /**
                 * Constructs a new transaction.
                 * @memberof koinos.protocol
                 * @classdesc Represents a transaction.
                 * @implements Itransaction
                 * @constructor
                 * @param {koinos.protocol.Itransaction=} [properties] Properties to set
                 */
                function transaction(properties) {
                    this.operations = [];
                    this.signatures = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * transaction id.
                 * @member {Uint8Array} id
                 * @memberof koinos.protocol.transaction
                 * @instance
                 */
                transaction.prototype.id = $util.newBuffer([]);
    
                /**
                 * transaction header.
                 * @member {koinos.protocol.Itransaction_header|null|undefined} header
                 * @memberof koinos.protocol.transaction
                 * @instance
                 */
                transaction.prototype.header = null;
    
                /**
                 * transaction operations.
                 * @member {Array.<koinos.protocol.Ioperation>} operations
                 * @memberof koinos.protocol.transaction
                 * @instance
                 */
                transaction.prototype.operations = $util.emptyArray;
    
                /**
                 * transaction signatures.
                 * @member {Array.<Uint8Array>} signatures
                 * @memberof koinos.protocol.transaction
                 * @instance
                 */
                transaction.prototype.signatures = $util.emptyArray;
    
                /**
                 * Creates a new transaction instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {koinos.protocol.Itransaction=} [properties] Properties to set
                 * @returns {koinos.protocol.transaction} transaction instance
                 */
                transaction.create = function create(properties) {
                    return new transaction(properties);
                };
    
                /**
                 * Encodes the specified transaction message. Does not implicitly {@link koinos.protocol.transaction.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {koinos.protocol.Itransaction} message transaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                        $root.koinos.protocol.transaction_header.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.operations != null && message.operations.length)
                        for (var i = 0; i < message.operations.length; ++i)
                            $root.koinos.protocol.operation.encode(message.operations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.signatures != null && message.signatures.length)
                        for (var i = 0; i < message.signatures.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signatures[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified transaction message, length delimited. Does not implicitly {@link koinos.protocol.transaction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {koinos.protocol.Itransaction} message transaction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a transaction message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.transaction} transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.transaction();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        case 2:
                            message.header = $root.koinos.protocol.transaction_header.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.operations && message.operations.length))
                                message.operations = [];
                            message.operations.push($root.koinos.protocol.operation.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.signatures && message.signatures.length))
                                message.signatures = [];
                            message.signatures.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a transaction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.transaction} transaction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a transaction message.
                 * @function verify
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                transaction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    if (message.header != null && message.hasOwnProperty("header")) {
                        var error = $root.koinos.protocol.transaction_header.verify(message.header);
                        if (error)
                            return "header." + error;
                    }
                    if (message.operations != null && message.hasOwnProperty("operations")) {
                        if (!Array.isArray(message.operations))
                            return "operations: array expected";
                        for (var i = 0; i < message.operations.length; ++i) {
                            var error = $root.koinos.protocol.operation.verify(message.operations[i]);
                            if (error)
                                return "operations." + error;
                        }
                    }
                    if (message.signatures != null && message.hasOwnProperty("signatures")) {
                        if (!Array.isArray(message.signatures))
                            return "signatures: array expected";
                        for (var i = 0; i < message.signatures.length; ++i)
                            if (!(message.signatures[i] && typeof message.signatures[i].length === "number" || $util.isString(message.signatures[i])))
                                return "signatures: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a transaction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.transaction} transaction
                 */
                transaction.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.transaction)
                        return object;
                    var message = new $root.koinos.protocol.transaction();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    if (object.header != null) {
                        if (typeof object.header !== "object")
                            throw TypeError(".koinos.protocol.transaction.header: object expected");
                        message.header = $root.koinos.protocol.transaction_header.fromObject(object.header);
                    }
                    if (object.operations) {
                        if (!Array.isArray(object.operations))
                            throw TypeError(".koinos.protocol.transaction.operations: array expected");
                        message.operations = [];
                        for (var i = 0; i < object.operations.length; ++i) {
                            if (typeof object.operations[i] !== "object")
                                throw TypeError(".koinos.protocol.transaction.operations: object expected");
                            message.operations[i] = $root.koinos.protocol.operation.fromObject(object.operations[i]);
                        }
                    }
                    if (object.signatures) {
                        if (!Array.isArray(object.signatures))
                            throw TypeError(".koinos.protocol.transaction.signatures: array expected");
                        message.signatures = [];
                        for (var i = 0; i < object.signatures.length; ++i)
                            if (typeof object.signatures[i] === "string")
                                $util.base64.decode(object.signatures[i], message.signatures[i] = $util.newBuffer($util.base64.length(object.signatures[i])), 0);
                            else if (object.signatures[i].length)
                                message.signatures[i] = object.signatures[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a transaction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.transaction
                 * @static
                 * @param {koinos.protocol.transaction} message transaction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                transaction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.operations = [];
                        object.signatures = [];
                    }
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                        object.header = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    if (message.header != null && message.hasOwnProperty("header"))
                        object.header = $root.koinos.protocol.transaction_header.toObject(message.header, options);
                    if (message.operations && message.operations.length) {
                        object.operations = [];
                        for (var j = 0; j < message.operations.length; ++j)
                            object.operations[j] = $root.koinos.protocol.operation.toObject(message.operations[j], options);
                    }
                    if (message.signatures && message.signatures.length) {
                        object.signatures = [];
                        for (var j = 0; j < message.signatures.length; ++j)
                            object.signatures[j] = options.bytes === String ? $util.base64.encode(message.signatures[j], 0, message.signatures[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signatures[j]) : message.signatures[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this transaction to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.transaction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                transaction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return transaction;
            })();
    
            protocol.transaction_receipt = (function() {
    
                /**
                 * Properties of a transaction_receipt.
                 * @memberof koinos.protocol
                 * @interface Itransaction_receipt
                 * @property {Uint8Array|null} [id] transaction_receipt id
                 * @property {Uint8Array|null} [payer] transaction_receipt payer
                 * @property {number|Long|null} [max_payer_rc] transaction_receipt max_payer_rc
                 * @property {number|Long|null} [rc_limit] transaction_receipt rc_limit
                 * @property {number|Long|null} [rc_used] transaction_receipt rc_used
                 * @property {number|Long|null} [disk_storage_used] transaction_receipt disk_storage_used
                 * @property {number|Long|null} [network_bandwidth_used] transaction_receipt network_bandwidth_used
                 * @property {number|Long|null} [compute_bandwidth_used] transaction_receipt compute_bandwidth_used
                 * @property {boolean|null} [reverted] transaction_receipt reverted
                 * @property {Array.<koinos.protocol.Ievent_data>|null} [events] transaction_receipt events
                 * @property {Array.<string>|null} [logs] transaction_receipt logs
                 */
    
                /**
                 * Constructs a new transaction_receipt.
                 * @memberof koinos.protocol
                 * @classdesc Represents a transaction_receipt.
                 * @implements Itransaction_receipt
                 * @constructor
                 * @param {koinos.protocol.Itransaction_receipt=} [properties] Properties to set
                 */
                function transaction_receipt(properties) {
                    this.events = [];
                    this.logs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * transaction_receipt id.
                 * @member {Uint8Array} id
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.id = $util.newBuffer([]);
    
                /**
                 * transaction_receipt payer.
                 * @member {Uint8Array} payer
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.payer = $util.newBuffer([]);
    
                /**
                 * transaction_receipt max_payer_rc.
                 * @member {number|Long} max_payer_rc
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.max_payer_rc = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_receipt rc_limit.
                 * @member {number|Long} rc_limit
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.rc_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_receipt rc_used.
                 * @member {number|Long} rc_used
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.rc_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_receipt disk_storage_used.
                 * @member {number|Long} disk_storage_used
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.disk_storage_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_receipt network_bandwidth_used.
                 * @member {number|Long} network_bandwidth_used
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.network_bandwidth_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_receipt compute_bandwidth_used.
                 * @member {number|Long} compute_bandwidth_used
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.compute_bandwidth_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * transaction_receipt reverted.
                 * @member {boolean} reverted
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.reverted = false;
    
                /**
                 * transaction_receipt events.
                 * @member {Array.<koinos.protocol.Ievent_data>} events
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.events = $util.emptyArray;
    
                /**
                 * transaction_receipt logs.
                 * @member {Array.<string>} logs
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 */
                transaction_receipt.prototype.logs = $util.emptyArray;
    
                /**
                 * Creates a new transaction_receipt instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {koinos.protocol.Itransaction_receipt=} [properties] Properties to set
                 * @returns {koinos.protocol.transaction_receipt} transaction_receipt instance
                 */
                transaction_receipt.create = function create(properties) {
                    return new transaction_receipt(properties);
                };
    
                /**
                 * Encodes the specified transaction_receipt message. Does not implicitly {@link koinos.protocol.transaction_receipt.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {koinos.protocol.Itransaction_receipt} message transaction_receipt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_receipt.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    if (message.payer != null && Object.hasOwnProperty.call(message, "payer"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payer);
                    if (message.max_payer_rc != null && Object.hasOwnProperty.call(message, "max_payer_rc"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.max_payer_rc);
                    if (message.rc_limit != null && Object.hasOwnProperty.call(message, "rc_limit"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.rc_limit);
                    if (message.rc_used != null && Object.hasOwnProperty.call(message, "rc_used"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.rc_used);
                    if (message.disk_storage_used != null && Object.hasOwnProperty.call(message, "disk_storage_used"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.disk_storage_used);
                    if (message.network_bandwidth_used != null && Object.hasOwnProperty.call(message, "network_bandwidth_used"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.network_bandwidth_used);
                    if (message.compute_bandwidth_used != null && Object.hasOwnProperty.call(message, "compute_bandwidth_used"))
                        writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.compute_bandwidth_used);
                    if (message.reverted != null && Object.hasOwnProperty.call(message, "reverted"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.reverted);
                    if (message.events != null && message.events.length)
                        for (var i = 0; i < message.events.length; ++i)
                            $root.koinos.protocol.event_data.encode(message.events[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.logs != null && message.logs.length)
                        for (var i = 0; i < message.logs.length; ++i)
                            writer.uint32(/* id 11, wireType 2 =*/90).string(message.logs[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified transaction_receipt message, length delimited. Does not implicitly {@link koinos.protocol.transaction_receipt.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {koinos.protocol.Itransaction_receipt} message transaction_receipt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_receipt.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a transaction_receipt message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.transaction_receipt} transaction_receipt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_receipt.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.transaction_receipt();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        case 2:
                            message.payer = reader.bytes();
                            break;
                        case 3:
                            message.max_payer_rc = reader.uint64();
                            break;
                        case 4:
                            message.rc_limit = reader.uint64();
                            break;
                        case 5:
                            message.rc_used = reader.uint64();
                            break;
                        case 6:
                            message.disk_storage_used = reader.uint64();
                            break;
                        case 7:
                            message.network_bandwidth_used = reader.uint64();
                            break;
                        case 8:
                            message.compute_bandwidth_used = reader.uint64();
                            break;
                        case 9:
                            message.reverted = reader.bool();
                            break;
                        case 10:
                            if (!(message.events && message.events.length))
                                message.events = [];
                            message.events.push($root.koinos.protocol.event_data.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            if (!(message.logs && message.logs.length))
                                message.logs = [];
                            message.logs.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a transaction_receipt message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.transaction_receipt} transaction_receipt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_receipt.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a transaction_receipt message.
                 * @function verify
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                transaction_receipt.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    if (message.payer != null && message.hasOwnProperty("payer"))
                        if (!(message.payer && typeof message.payer.length === "number" || $util.isString(message.payer)))
                            return "payer: buffer expected";
                    if (message.max_payer_rc != null && message.hasOwnProperty("max_payer_rc"))
                        if (!$util.isInteger(message.max_payer_rc) && !(message.max_payer_rc && $util.isInteger(message.max_payer_rc.low) && $util.isInteger(message.max_payer_rc.high)))
                            return "max_payer_rc: integer|Long expected";
                    if (message.rc_limit != null && message.hasOwnProperty("rc_limit"))
                        if (!$util.isInteger(message.rc_limit) && !(message.rc_limit && $util.isInteger(message.rc_limit.low) && $util.isInteger(message.rc_limit.high)))
                            return "rc_limit: integer|Long expected";
                    if (message.rc_used != null && message.hasOwnProperty("rc_used"))
                        if (!$util.isInteger(message.rc_used) && !(message.rc_used && $util.isInteger(message.rc_used.low) && $util.isInteger(message.rc_used.high)))
                            return "rc_used: integer|Long expected";
                    if (message.disk_storage_used != null && message.hasOwnProperty("disk_storage_used"))
                        if (!$util.isInteger(message.disk_storage_used) && !(message.disk_storage_used && $util.isInteger(message.disk_storage_used.low) && $util.isInteger(message.disk_storage_used.high)))
                            return "disk_storage_used: integer|Long expected";
                    if (message.network_bandwidth_used != null && message.hasOwnProperty("network_bandwidth_used"))
                        if (!$util.isInteger(message.network_bandwidth_used) && !(message.network_bandwidth_used && $util.isInteger(message.network_bandwidth_used.low) && $util.isInteger(message.network_bandwidth_used.high)))
                            return "network_bandwidth_used: integer|Long expected";
                    if (message.compute_bandwidth_used != null && message.hasOwnProperty("compute_bandwidth_used"))
                        if (!$util.isInteger(message.compute_bandwidth_used) && !(message.compute_bandwidth_used && $util.isInteger(message.compute_bandwidth_used.low) && $util.isInteger(message.compute_bandwidth_used.high)))
                            return "compute_bandwidth_used: integer|Long expected";
                    if (message.reverted != null && message.hasOwnProperty("reverted"))
                        if (typeof message.reverted !== "boolean")
                            return "reverted: boolean expected";
                    if (message.events != null && message.hasOwnProperty("events")) {
                        if (!Array.isArray(message.events))
                            return "events: array expected";
                        for (var i = 0; i < message.events.length; ++i) {
                            var error = $root.koinos.protocol.event_data.verify(message.events[i]);
                            if (error)
                                return "events." + error;
                        }
                    }
                    if (message.logs != null && message.hasOwnProperty("logs")) {
                        if (!Array.isArray(message.logs))
                            return "logs: array expected";
                        for (var i = 0; i < message.logs.length; ++i)
                            if (!$util.isString(message.logs[i]))
                                return "logs: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a transaction_receipt message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.transaction_receipt} transaction_receipt
                 */
                transaction_receipt.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.transaction_receipt)
                        return object;
                    var message = new $root.koinos.protocol.transaction_receipt();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    if (object.payer != null)
                        if (typeof object.payer === "string")
                            $util.base64.decode(object.payer, message.payer = $util.newBuffer($util.base64.length(object.payer)), 0);
                        else if (object.payer.length)
                            message.payer = object.payer;
                    if (object.max_payer_rc != null)
                        if ($util.Long)
                            (message.max_payer_rc = $util.Long.fromValue(object.max_payer_rc)).unsigned = true;
                        else if (typeof object.max_payer_rc === "string")
                            message.max_payer_rc = parseInt(object.max_payer_rc, 10);
                        else if (typeof object.max_payer_rc === "number")
                            message.max_payer_rc = object.max_payer_rc;
                        else if (typeof object.max_payer_rc === "object")
                            message.max_payer_rc = new $util.LongBits(object.max_payer_rc.low >>> 0, object.max_payer_rc.high >>> 0).toNumber(true);
                    if (object.rc_limit != null)
                        if ($util.Long)
                            (message.rc_limit = $util.Long.fromValue(object.rc_limit)).unsigned = true;
                        else if (typeof object.rc_limit === "string")
                            message.rc_limit = parseInt(object.rc_limit, 10);
                        else if (typeof object.rc_limit === "number")
                            message.rc_limit = object.rc_limit;
                        else if (typeof object.rc_limit === "object")
                            message.rc_limit = new $util.LongBits(object.rc_limit.low >>> 0, object.rc_limit.high >>> 0).toNumber(true);
                    if (object.rc_used != null)
                        if ($util.Long)
                            (message.rc_used = $util.Long.fromValue(object.rc_used)).unsigned = true;
                        else if (typeof object.rc_used === "string")
                            message.rc_used = parseInt(object.rc_used, 10);
                        else if (typeof object.rc_used === "number")
                            message.rc_used = object.rc_used;
                        else if (typeof object.rc_used === "object")
                            message.rc_used = new $util.LongBits(object.rc_used.low >>> 0, object.rc_used.high >>> 0).toNumber(true);
                    if (object.disk_storage_used != null)
                        if ($util.Long)
                            (message.disk_storage_used = $util.Long.fromValue(object.disk_storage_used)).unsigned = true;
                        else if (typeof object.disk_storage_used === "string")
                            message.disk_storage_used = parseInt(object.disk_storage_used, 10);
                        else if (typeof object.disk_storage_used === "number")
                            message.disk_storage_used = object.disk_storage_used;
                        else if (typeof object.disk_storage_used === "object")
                            message.disk_storage_used = new $util.LongBits(object.disk_storage_used.low >>> 0, object.disk_storage_used.high >>> 0).toNumber(true);
                    if (object.network_bandwidth_used != null)
                        if ($util.Long)
                            (message.network_bandwidth_used = $util.Long.fromValue(object.network_bandwidth_used)).unsigned = true;
                        else if (typeof object.network_bandwidth_used === "string")
                            message.network_bandwidth_used = parseInt(object.network_bandwidth_used, 10);
                        else if (typeof object.network_bandwidth_used === "number")
                            message.network_bandwidth_used = object.network_bandwidth_used;
                        else if (typeof object.network_bandwidth_used === "object")
                            message.network_bandwidth_used = new $util.LongBits(object.network_bandwidth_used.low >>> 0, object.network_bandwidth_used.high >>> 0).toNumber(true);
                    if (object.compute_bandwidth_used != null)
                        if ($util.Long)
                            (message.compute_bandwidth_used = $util.Long.fromValue(object.compute_bandwidth_used)).unsigned = true;
                        else if (typeof object.compute_bandwidth_used === "string")
                            message.compute_bandwidth_used = parseInt(object.compute_bandwidth_used, 10);
                        else if (typeof object.compute_bandwidth_used === "number")
                            message.compute_bandwidth_used = object.compute_bandwidth_used;
                        else if (typeof object.compute_bandwidth_used === "object")
                            message.compute_bandwidth_used = new $util.LongBits(object.compute_bandwidth_used.low >>> 0, object.compute_bandwidth_used.high >>> 0).toNumber(true);
                    if (object.reverted != null)
                        message.reverted = Boolean(object.reverted);
                    if (object.events) {
                        if (!Array.isArray(object.events))
                            throw TypeError(".koinos.protocol.transaction_receipt.events: array expected");
                        message.events = [];
                        for (var i = 0; i < object.events.length; ++i) {
                            if (typeof object.events[i] !== "object")
                                throw TypeError(".koinos.protocol.transaction_receipt.events: object expected");
                            message.events[i] = $root.koinos.protocol.event_data.fromObject(object.events[i]);
                        }
                    }
                    if (object.logs) {
                        if (!Array.isArray(object.logs))
                            throw TypeError(".koinos.protocol.transaction_receipt.logs: array expected");
                        message.logs = [];
                        for (var i = 0; i < object.logs.length; ++i)
                            message.logs[i] = String(object.logs[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a transaction_receipt message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.transaction_receipt
                 * @static
                 * @param {koinos.protocol.transaction_receipt} message transaction_receipt
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                transaction_receipt.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.events = [];
                        object.logs = [];
                    }
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                        if (options.bytes === String)
                            object.payer = "";
                        else {
                            object.payer = [];
                            if (options.bytes !== Array)
                                object.payer = $util.newBuffer(object.payer);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.max_payer_rc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.max_payer_rc = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rc_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rc_limit = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.rc_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.rc_used = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.disk_storage_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.disk_storage_used = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.network_bandwidth_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.network_bandwidth_used = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.compute_bandwidth_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.compute_bandwidth_used = options.longs === String ? "0" : 0;
                        object.reverted = false;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    if (message.payer != null && message.hasOwnProperty("payer"))
                        object.payer = options.bytes === String ? $util.base64.encode(message.payer, 0, message.payer.length) : options.bytes === Array ? Array.prototype.slice.call(message.payer) : message.payer;
                    if (message.max_payer_rc != null && message.hasOwnProperty("max_payer_rc"))
                        if (typeof message.max_payer_rc === "number")
                            object.max_payer_rc = options.longs === String ? String(message.max_payer_rc) : message.max_payer_rc;
                        else
                            object.max_payer_rc = options.longs === String ? $util.Long.prototype.toString.call(message.max_payer_rc) : options.longs === Number ? new $util.LongBits(message.max_payer_rc.low >>> 0, message.max_payer_rc.high >>> 0).toNumber(true) : message.max_payer_rc;
                    if (message.rc_limit != null && message.hasOwnProperty("rc_limit"))
                        if (typeof message.rc_limit === "number")
                            object.rc_limit = options.longs === String ? String(message.rc_limit) : message.rc_limit;
                        else
                            object.rc_limit = options.longs === String ? $util.Long.prototype.toString.call(message.rc_limit) : options.longs === Number ? new $util.LongBits(message.rc_limit.low >>> 0, message.rc_limit.high >>> 0).toNumber(true) : message.rc_limit;
                    if (message.rc_used != null && message.hasOwnProperty("rc_used"))
                        if (typeof message.rc_used === "number")
                            object.rc_used = options.longs === String ? String(message.rc_used) : message.rc_used;
                        else
                            object.rc_used = options.longs === String ? $util.Long.prototype.toString.call(message.rc_used) : options.longs === Number ? new $util.LongBits(message.rc_used.low >>> 0, message.rc_used.high >>> 0).toNumber(true) : message.rc_used;
                    if (message.disk_storage_used != null && message.hasOwnProperty("disk_storage_used"))
                        if (typeof message.disk_storage_used === "number")
                            object.disk_storage_used = options.longs === String ? String(message.disk_storage_used) : message.disk_storage_used;
                        else
                            object.disk_storage_used = options.longs === String ? $util.Long.prototype.toString.call(message.disk_storage_used) : options.longs === Number ? new $util.LongBits(message.disk_storage_used.low >>> 0, message.disk_storage_used.high >>> 0).toNumber(true) : message.disk_storage_used;
                    if (message.network_bandwidth_used != null && message.hasOwnProperty("network_bandwidth_used"))
                        if (typeof message.network_bandwidth_used === "number")
                            object.network_bandwidth_used = options.longs === String ? String(message.network_bandwidth_used) : message.network_bandwidth_used;
                        else
                            object.network_bandwidth_used = options.longs === String ? $util.Long.prototype.toString.call(message.network_bandwidth_used) : options.longs === Number ? new $util.LongBits(message.network_bandwidth_used.low >>> 0, message.network_bandwidth_used.high >>> 0).toNumber(true) : message.network_bandwidth_used;
                    if (message.compute_bandwidth_used != null && message.hasOwnProperty("compute_bandwidth_used"))
                        if (typeof message.compute_bandwidth_used === "number")
                            object.compute_bandwidth_used = options.longs === String ? String(message.compute_bandwidth_used) : message.compute_bandwidth_used;
                        else
                            object.compute_bandwidth_used = options.longs === String ? $util.Long.prototype.toString.call(message.compute_bandwidth_used) : options.longs === Number ? new $util.LongBits(message.compute_bandwidth_used.low >>> 0, message.compute_bandwidth_used.high >>> 0).toNumber(true) : message.compute_bandwidth_used;
                    if (message.reverted != null && message.hasOwnProperty("reverted"))
                        object.reverted = message.reverted;
                    if (message.events && message.events.length) {
                        object.events = [];
                        for (var j = 0; j < message.events.length; ++j)
                            object.events[j] = $root.koinos.protocol.event_data.toObject(message.events[j], options);
                    }
                    if (message.logs && message.logs.length) {
                        object.logs = [];
                        for (var j = 0; j < message.logs.length; ++j)
                            object.logs[j] = message.logs[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this transaction_receipt to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.transaction_receipt
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                transaction_receipt.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return transaction_receipt;
            })();
    
            protocol.block_header = (function() {
    
                /**
                 * Properties of a block_header.
                 * @memberof koinos.protocol
                 * @interface Iblock_header
                 * @property {Uint8Array|null} [previous] block_header previous
                 * @property {number|Long|null} [height] block_header height
                 * @property {number|Long|null} [timestamp] block_header timestamp
                 * @property {Uint8Array|null} [previous_state_merkle_root] block_header previous_state_merkle_root
                 * @property {Uint8Array|null} [transaction_merkle_root] block_header transaction_merkle_root
                 * @property {Uint8Array|null} [signer] block_header signer
                 * @property {Array.<Uint8Array>|null} [approved_proposals] block_header approved_proposals
                 */
    
                /**
                 * Constructs a new block_header.
                 * @memberof koinos.protocol
                 * @classdesc Represents a block_header.
                 * @implements Iblock_header
                 * @constructor
                 * @param {koinos.protocol.Iblock_header=} [properties] Properties to set
                 */
                function block_header(properties) {
                    this.approved_proposals = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block_header previous.
                 * @member {Uint8Array} previous
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.previous = $util.newBuffer([]);
    
                /**
                 * block_header height.
                 * @member {number|Long} height
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_header timestamp.
                 * @member {number|Long} timestamp
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_header previous_state_merkle_root.
                 * @member {Uint8Array} previous_state_merkle_root
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.previous_state_merkle_root = $util.newBuffer([]);
    
                /**
                 * block_header transaction_merkle_root.
                 * @member {Uint8Array} transaction_merkle_root
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.transaction_merkle_root = $util.newBuffer([]);
    
                /**
                 * block_header signer.
                 * @member {Uint8Array} signer
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.signer = $util.newBuffer([]);
    
                /**
                 * block_header approved_proposals.
                 * @member {Array.<Uint8Array>} approved_proposals
                 * @memberof koinos.protocol.block_header
                 * @instance
                 */
                block_header.prototype.approved_proposals = $util.emptyArray;
    
                /**
                 * Creates a new block_header instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {koinos.protocol.Iblock_header=} [properties] Properties to set
                 * @returns {koinos.protocol.block_header} block_header instance
                 */
                block_header.create = function create(properties) {
                    return new block_header(properties);
                };
    
                /**
                 * Encodes the specified block_header message. Does not implicitly {@link koinos.protocol.block_header.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {koinos.protocol.Iblock_header} message block_header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_header.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.previous != null && Object.hasOwnProperty.call(message, "previous"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.previous);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.height);
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.timestamp);
                    if (message.previous_state_merkle_root != null && Object.hasOwnProperty.call(message, "previous_state_merkle_root"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.previous_state_merkle_root);
                    if (message.transaction_merkle_root != null && Object.hasOwnProperty.call(message, "transaction_merkle_root"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.transaction_merkle_root);
                    if (message.signer != null && Object.hasOwnProperty.call(message, "signer"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.signer);
                    if (message.approved_proposals != null && message.approved_proposals.length)
                        for (var i = 0; i < message.approved_proposals.length; ++i)
                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.approved_proposals[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified block_header message, length delimited. Does not implicitly {@link koinos.protocol.block_header.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {koinos.protocol.Iblock_header} message block_header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_header.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block_header message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.block_header} block_header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_header.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.block_header();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.previous = reader.bytes();
                            break;
                        case 2:
                            message.height = reader.uint64();
                            break;
                        case 3:
                            message.timestamp = reader.uint64();
                            break;
                        case 4:
                            message.previous_state_merkle_root = reader.bytes();
                            break;
                        case 5:
                            message.transaction_merkle_root = reader.bytes();
                            break;
                        case 6:
                            message.signer = reader.bytes();
                            break;
                        case 7:
                            if (!(message.approved_proposals && message.approved_proposals.length))
                                message.approved_proposals = [];
                            message.approved_proposals.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block_header message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.block_header} block_header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_header.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block_header message.
                 * @function verify
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block_header.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.previous != null && message.hasOwnProperty("previous"))
                        if (!(message.previous && typeof message.previous.length === "number" || $util.isString(message.previous)))
                            return "previous: buffer expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                            return "timestamp: integer|Long expected";
                    if (message.previous_state_merkle_root != null && message.hasOwnProperty("previous_state_merkle_root"))
                        if (!(message.previous_state_merkle_root && typeof message.previous_state_merkle_root.length === "number" || $util.isString(message.previous_state_merkle_root)))
                            return "previous_state_merkle_root: buffer expected";
                    if (message.transaction_merkle_root != null && message.hasOwnProperty("transaction_merkle_root"))
                        if (!(message.transaction_merkle_root && typeof message.transaction_merkle_root.length === "number" || $util.isString(message.transaction_merkle_root)))
                            return "transaction_merkle_root: buffer expected";
                    if (message.signer != null && message.hasOwnProperty("signer"))
                        if (!(message.signer && typeof message.signer.length === "number" || $util.isString(message.signer)))
                            return "signer: buffer expected";
                    if (message.approved_proposals != null && message.hasOwnProperty("approved_proposals")) {
                        if (!Array.isArray(message.approved_proposals))
                            return "approved_proposals: array expected";
                        for (var i = 0; i < message.approved_proposals.length; ++i)
                            if (!(message.approved_proposals[i] && typeof message.approved_proposals[i].length === "number" || $util.isString(message.approved_proposals[i])))
                                return "approved_proposals: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a block_header message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.block_header} block_header
                 */
                block_header.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.block_header)
                        return object;
                    var message = new $root.koinos.protocol.block_header();
                    if (object.previous != null)
                        if (typeof object.previous === "string")
                            $util.base64.decode(object.previous, message.previous = $util.newBuffer($util.base64.length(object.previous)), 0);
                        else if (object.previous.length)
                            message.previous = object.previous;
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                    if (object.timestamp != null)
                        if ($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                        else if (typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if (typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if (typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                    if (object.previous_state_merkle_root != null)
                        if (typeof object.previous_state_merkle_root === "string")
                            $util.base64.decode(object.previous_state_merkle_root, message.previous_state_merkle_root = $util.newBuffer($util.base64.length(object.previous_state_merkle_root)), 0);
                        else if (object.previous_state_merkle_root.length)
                            message.previous_state_merkle_root = object.previous_state_merkle_root;
                    if (object.transaction_merkle_root != null)
                        if (typeof object.transaction_merkle_root === "string")
                            $util.base64.decode(object.transaction_merkle_root, message.transaction_merkle_root = $util.newBuffer($util.base64.length(object.transaction_merkle_root)), 0);
                        else if (object.transaction_merkle_root.length)
                            message.transaction_merkle_root = object.transaction_merkle_root;
                    if (object.signer != null)
                        if (typeof object.signer === "string")
                            $util.base64.decode(object.signer, message.signer = $util.newBuffer($util.base64.length(object.signer)), 0);
                        else if (object.signer.length)
                            message.signer = object.signer;
                    if (object.approved_proposals) {
                        if (!Array.isArray(object.approved_proposals))
                            throw TypeError(".koinos.protocol.block_header.approved_proposals: array expected");
                        message.approved_proposals = [];
                        for (var i = 0; i < object.approved_proposals.length; ++i)
                            if (typeof object.approved_proposals[i] === "string")
                                $util.base64.decode(object.approved_proposals[i], message.approved_proposals[i] = $util.newBuffer($util.base64.length(object.approved_proposals[i])), 0);
                            else if (object.approved_proposals[i].length)
                                message.approved_proposals[i] = object.approved_proposals[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a block_header message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.block_header
                 * @static
                 * @param {koinos.protocol.block_header} message block_header
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block_header.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.approved_proposals = [];
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.previous = "";
                        else {
                            object.previous = [];
                            if (options.bytes !== Array)
                                object.previous = $util.newBuffer(object.previous);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.previous_state_merkle_root = "";
                        else {
                            object.previous_state_merkle_root = [];
                            if (options.bytes !== Array)
                                object.previous_state_merkle_root = $util.newBuffer(object.previous_state_merkle_root);
                        }
                        if (options.bytes === String)
                            object.transaction_merkle_root = "";
                        else {
                            object.transaction_merkle_root = [];
                            if (options.bytes !== Array)
                                object.transaction_merkle_root = $util.newBuffer(object.transaction_merkle_root);
                        }
                        if (options.bytes === String)
                            object.signer = "";
                        else {
                            object.signer = [];
                            if (options.bytes !== Array)
                                object.signer = $util.newBuffer(object.signer);
                        }
                    }
                    if (message.previous != null && message.hasOwnProperty("previous"))
                        object.previous = options.bytes === String ? $util.base64.encode(message.previous, 0, message.previous.length) : options.bytes === Array ? Array.prototype.slice.call(message.previous) : message.previous;
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                    if (message.previous_state_merkle_root != null && message.hasOwnProperty("previous_state_merkle_root"))
                        object.previous_state_merkle_root = options.bytes === String ? $util.base64.encode(message.previous_state_merkle_root, 0, message.previous_state_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.previous_state_merkle_root) : message.previous_state_merkle_root;
                    if (message.transaction_merkle_root != null && message.hasOwnProperty("transaction_merkle_root"))
                        object.transaction_merkle_root = options.bytes === String ? $util.base64.encode(message.transaction_merkle_root, 0, message.transaction_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.transaction_merkle_root) : message.transaction_merkle_root;
                    if (message.signer != null && message.hasOwnProperty("signer"))
                        object.signer = options.bytes === String ? $util.base64.encode(message.signer, 0, message.signer.length) : options.bytes === Array ? Array.prototype.slice.call(message.signer) : message.signer;
                    if (message.approved_proposals && message.approved_proposals.length) {
                        object.approved_proposals = [];
                        for (var j = 0; j < message.approved_proposals.length; ++j)
                            object.approved_proposals[j] = options.bytes === String ? $util.base64.encode(message.approved_proposals[j], 0, message.approved_proposals[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.approved_proposals[j]) : message.approved_proposals[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this block_header to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.block_header
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block_header.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block_header;
            })();
    
            protocol.block = (function() {
    
                /**
                 * Properties of a block.
                 * @memberof koinos.protocol
                 * @interface Iblock
                 * @property {Uint8Array|null} [id] block id
                 * @property {koinos.protocol.Iblock_header|null} [header] block header
                 * @property {Array.<koinos.protocol.Itransaction>|null} [transactions] block transactions
                 * @property {Uint8Array|null} [signature] block signature
                 */
    
                /**
                 * Constructs a new block.
                 * @memberof koinos.protocol
                 * @classdesc Represents a block.
                 * @implements Iblock
                 * @constructor
                 * @param {koinos.protocol.Iblock=} [properties] Properties to set
                 */
                function block(properties) {
                    this.transactions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block id.
                 * @member {Uint8Array} id
                 * @memberof koinos.protocol.block
                 * @instance
                 */
                block.prototype.id = $util.newBuffer([]);
    
                /**
                 * block header.
                 * @member {koinos.protocol.Iblock_header|null|undefined} header
                 * @memberof koinos.protocol.block
                 * @instance
                 */
                block.prototype.header = null;
    
                /**
                 * block transactions.
                 * @member {Array.<koinos.protocol.Itransaction>} transactions
                 * @memberof koinos.protocol.block
                 * @instance
                 */
                block.prototype.transactions = $util.emptyArray;
    
                /**
                 * block signature.
                 * @member {Uint8Array} signature
                 * @memberof koinos.protocol.block
                 * @instance
                 */
                block.prototype.signature = $util.newBuffer([]);
    
                /**
                 * Creates a new block instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {koinos.protocol.Iblock=} [properties] Properties to set
                 * @returns {koinos.protocol.block} block instance
                 */
                block.create = function create(properties) {
                    return new block(properties);
                };
    
                /**
                 * Encodes the specified block message. Does not implicitly {@link koinos.protocol.block.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {koinos.protocol.Iblock} message block message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                        $root.koinos.protocol.block_header.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.transactions != null && message.transactions.length)
                        for (var i = 0; i < message.transactions.length; ++i)
                            $root.koinos.protocol.transaction.encode(message.transactions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
                    return writer;
                };
    
                /**
                 * Encodes the specified block message, length delimited. Does not implicitly {@link koinos.protocol.block.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {koinos.protocol.Iblock} message block message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.block} block
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.block();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        case 2:
                            message.header = $root.koinos.protocol.block_header.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.transactions && message.transactions.length))
                                message.transactions = [];
                            message.transactions.push($root.koinos.protocol.transaction.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.signature = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.block} block
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block message.
                 * @function verify
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    if (message.header != null && message.hasOwnProperty("header")) {
                        var error = $root.koinos.protocol.block_header.verify(message.header);
                        if (error)
                            return "header." + error;
                    }
                    if (message.transactions != null && message.hasOwnProperty("transactions")) {
                        if (!Array.isArray(message.transactions))
                            return "transactions: array expected";
                        for (var i = 0; i < message.transactions.length; ++i) {
                            var error = $root.koinos.protocol.transaction.verify(message.transactions[i]);
                            if (error)
                                return "transactions." + error;
                        }
                    }
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                            return "signature: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a block message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.block} block
                 */
                block.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.block)
                        return object;
                    var message = new $root.koinos.protocol.block();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    if (object.header != null) {
                        if (typeof object.header !== "object")
                            throw TypeError(".koinos.protocol.block.header: object expected");
                        message.header = $root.koinos.protocol.block_header.fromObject(object.header);
                    }
                    if (object.transactions) {
                        if (!Array.isArray(object.transactions))
                            throw TypeError(".koinos.protocol.block.transactions: array expected");
                        message.transactions = [];
                        for (var i = 0; i < object.transactions.length; ++i) {
                            if (typeof object.transactions[i] !== "object")
                                throw TypeError(".koinos.protocol.block.transactions: object expected");
                            message.transactions[i] = $root.koinos.protocol.transaction.fromObject(object.transactions[i]);
                        }
                    }
                    if (object.signature != null)
                        if (typeof object.signature === "string")
                            $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                        else if (object.signature.length)
                            message.signature = object.signature;
                    return message;
                };
    
                /**
                 * Creates a plain object from a block message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.block
                 * @static
                 * @param {koinos.protocol.block} message block
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.transactions = [];
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                        object.header = null;
                        if (options.bytes === String)
                            object.signature = "";
                        else {
                            object.signature = [];
                            if (options.bytes !== Array)
                                object.signature = $util.newBuffer(object.signature);
                        }
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    if (message.header != null && message.hasOwnProperty("header"))
                        object.header = $root.koinos.protocol.block_header.toObject(message.header, options);
                    if (message.transactions && message.transactions.length) {
                        object.transactions = [];
                        for (var j = 0; j < message.transactions.length; ++j)
                            object.transactions[j] = $root.koinos.protocol.transaction.toObject(message.transactions[j], options);
                    }
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                    return object;
                };
    
                /**
                 * Converts this block to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.block
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block;
            })();
    
            protocol.block_receipt = (function() {
    
                /**
                 * Properties of a block_receipt.
                 * @memberof koinos.protocol
                 * @interface Iblock_receipt
                 * @property {Uint8Array|null} [id] block_receipt id
                 * @property {number|Long|null} [height] block_receipt height
                 * @property {number|Long|null} [disk_storage_used] block_receipt disk_storage_used
                 * @property {number|Long|null} [network_bandwidth_used] block_receipt network_bandwidth_used
                 * @property {number|Long|null} [compute_bandwidth_used] block_receipt compute_bandwidth_used
                 * @property {Uint8Array|null} [state_merkle_root] block_receipt state_merkle_root
                 * @property {Array.<koinos.protocol.Ievent_data>|null} [events] block_receipt events
                 * @property {Array.<koinos.protocol.Itransaction_receipt>|null} [transaction_receipts] block_receipt transaction_receipts
                 * @property {Array.<string>|null} [logs] block_receipt logs
                 */
    
                /**
                 * Constructs a new block_receipt.
                 * @memberof koinos.protocol
                 * @classdesc Represents a block_receipt.
                 * @implements Iblock_receipt
                 * @constructor
                 * @param {koinos.protocol.Iblock_receipt=} [properties] Properties to set
                 */
                function block_receipt(properties) {
                    this.events = [];
                    this.transaction_receipts = [];
                    this.logs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block_receipt id.
                 * @member {Uint8Array} id
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.id = $util.newBuffer([]);
    
                /**
                 * block_receipt height.
                 * @member {number|Long} height
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_receipt disk_storage_used.
                 * @member {number|Long} disk_storage_used
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.disk_storage_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_receipt network_bandwidth_used.
                 * @member {number|Long} network_bandwidth_used
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.network_bandwidth_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_receipt compute_bandwidth_used.
                 * @member {number|Long} compute_bandwidth_used
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.compute_bandwidth_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * block_receipt state_merkle_root.
                 * @member {Uint8Array} state_merkle_root
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.state_merkle_root = $util.newBuffer([]);
    
                /**
                 * block_receipt events.
                 * @member {Array.<koinos.protocol.Ievent_data>} events
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.events = $util.emptyArray;
    
                /**
                 * block_receipt transaction_receipts.
                 * @member {Array.<koinos.protocol.Itransaction_receipt>} transaction_receipts
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.transaction_receipts = $util.emptyArray;
    
                /**
                 * block_receipt logs.
                 * @member {Array.<string>} logs
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 */
                block_receipt.prototype.logs = $util.emptyArray;
    
                /**
                 * Creates a new block_receipt instance using the specified properties.
                 * @function create
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {koinos.protocol.Iblock_receipt=} [properties] Properties to set
                 * @returns {koinos.protocol.block_receipt} block_receipt instance
                 */
                block_receipt.create = function create(properties) {
                    return new block_receipt(properties);
                };
    
                /**
                 * Encodes the specified block_receipt message. Does not implicitly {@link koinos.protocol.block_receipt.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {koinos.protocol.Iblock_receipt} message block_receipt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_receipt.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.height);
                    if (message.disk_storage_used != null && Object.hasOwnProperty.call(message, "disk_storage_used"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.disk_storage_used);
                    if (message.network_bandwidth_used != null && Object.hasOwnProperty.call(message, "network_bandwidth_used"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.network_bandwidth_used);
                    if (message.compute_bandwidth_used != null && Object.hasOwnProperty.call(message, "compute_bandwidth_used"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.compute_bandwidth_used);
                    if (message.state_merkle_root != null && Object.hasOwnProperty.call(message, "state_merkle_root"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.state_merkle_root);
                    if (message.events != null && message.events.length)
                        for (var i = 0; i < message.events.length; ++i)
                            $root.koinos.protocol.event_data.encode(message.events[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.transaction_receipts != null && message.transaction_receipts.length)
                        for (var i = 0; i < message.transaction_receipts.length; ++i)
                            $root.koinos.protocol.transaction_receipt.encode(message.transaction_receipts[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.logs != null && message.logs.length)
                        for (var i = 0; i < message.logs.length; ++i)
                            writer.uint32(/* id 9, wireType 2 =*/74).string(message.logs[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified block_receipt message, length delimited. Does not implicitly {@link koinos.protocol.block_receipt.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {koinos.protocol.Iblock_receipt} message block_receipt message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_receipt.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block_receipt message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.protocol.block_receipt} block_receipt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_receipt.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.protocol.block_receipt();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        case 2:
                            message.height = reader.uint64();
                            break;
                        case 3:
                            message.disk_storage_used = reader.uint64();
                            break;
                        case 4:
                            message.network_bandwidth_used = reader.uint64();
                            break;
                        case 5:
                            message.compute_bandwidth_used = reader.uint64();
                            break;
                        case 6:
                            message.state_merkle_root = reader.bytes();
                            break;
                        case 7:
                            if (!(message.events && message.events.length))
                                message.events = [];
                            message.events.push($root.koinos.protocol.event_data.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.transaction_receipts && message.transaction_receipts.length))
                                message.transaction_receipts = [];
                            message.transaction_receipts.push($root.koinos.protocol.transaction_receipt.decode(reader, reader.uint32()));
                            break;
                        case 9:
                            if (!(message.logs && message.logs.length))
                                message.logs = [];
                            message.logs.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block_receipt message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.protocol.block_receipt} block_receipt
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_receipt.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block_receipt message.
                 * @function verify
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block_receipt.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    if (message.disk_storage_used != null && message.hasOwnProperty("disk_storage_used"))
                        if (!$util.isInteger(message.disk_storage_used) && !(message.disk_storage_used && $util.isInteger(message.disk_storage_used.low) && $util.isInteger(message.disk_storage_used.high)))
                            return "disk_storage_used: integer|Long expected";
                    if (message.network_bandwidth_used != null && message.hasOwnProperty("network_bandwidth_used"))
                        if (!$util.isInteger(message.network_bandwidth_used) && !(message.network_bandwidth_used && $util.isInteger(message.network_bandwidth_used.low) && $util.isInteger(message.network_bandwidth_used.high)))
                            return "network_bandwidth_used: integer|Long expected";
                    if (message.compute_bandwidth_used != null && message.hasOwnProperty("compute_bandwidth_used"))
                        if (!$util.isInteger(message.compute_bandwidth_used) && !(message.compute_bandwidth_used && $util.isInteger(message.compute_bandwidth_used.low) && $util.isInteger(message.compute_bandwidth_used.high)))
                            return "compute_bandwidth_used: integer|Long expected";
                    if (message.state_merkle_root != null && message.hasOwnProperty("state_merkle_root"))
                        if (!(message.state_merkle_root && typeof message.state_merkle_root.length === "number" || $util.isString(message.state_merkle_root)))
                            return "state_merkle_root: buffer expected";
                    if (message.events != null && message.hasOwnProperty("events")) {
                        if (!Array.isArray(message.events))
                            return "events: array expected";
                        for (var i = 0; i < message.events.length; ++i) {
                            var error = $root.koinos.protocol.event_data.verify(message.events[i]);
                            if (error)
                                return "events." + error;
                        }
                    }
                    if (message.transaction_receipts != null && message.hasOwnProperty("transaction_receipts")) {
                        if (!Array.isArray(message.transaction_receipts))
                            return "transaction_receipts: array expected";
                        for (var i = 0; i < message.transaction_receipts.length; ++i) {
                            var error = $root.koinos.protocol.transaction_receipt.verify(message.transaction_receipts[i]);
                            if (error)
                                return "transaction_receipts." + error;
                        }
                    }
                    if (message.logs != null && message.hasOwnProperty("logs")) {
                        if (!Array.isArray(message.logs))
                            return "logs: array expected";
                        for (var i = 0; i < message.logs.length; ++i)
                            if (!$util.isString(message.logs[i]))
                                return "logs: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a block_receipt message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.protocol.block_receipt} block_receipt
                 */
                block_receipt.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.protocol.block_receipt)
                        return object;
                    var message = new $root.koinos.protocol.block_receipt();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                    if (object.disk_storage_used != null)
                        if ($util.Long)
                            (message.disk_storage_used = $util.Long.fromValue(object.disk_storage_used)).unsigned = true;
                        else if (typeof object.disk_storage_used === "string")
                            message.disk_storage_used = parseInt(object.disk_storage_used, 10);
                        else if (typeof object.disk_storage_used === "number")
                            message.disk_storage_used = object.disk_storage_used;
                        else if (typeof object.disk_storage_used === "object")
                            message.disk_storage_used = new $util.LongBits(object.disk_storage_used.low >>> 0, object.disk_storage_used.high >>> 0).toNumber(true);
                    if (object.network_bandwidth_used != null)
                        if ($util.Long)
                            (message.network_bandwidth_used = $util.Long.fromValue(object.network_bandwidth_used)).unsigned = true;
                        else if (typeof object.network_bandwidth_used === "string")
                            message.network_bandwidth_used = parseInt(object.network_bandwidth_used, 10);
                        else if (typeof object.network_bandwidth_used === "number")
                            message.network_bandwidth_used = object.network_bandwidth_used;
                        else if (typeof object.network_bandwidth_used === "object")
                            message.network_bandwidth_used = new $util.LongBits(object.network_bandwidth_used.low >>> 0, object.network_bandwidth_used.high >>> 0).toNumber(true);
                    if (object.compute_bandwidth_used != null)
                        if ($util.Long)
                            (message.compute_bandwidth_used = $util.Long.fromValue(object.compute_bandwidth_used)).unsigned = true;
                        else if (typeof object.compute_bandwidth_used === "string")
                            message.compute_bandwidth_used = parseInt(object.compute_bandwidth_used, 10);
                        else if (typeof object.compute_bandwidth_used === "number")
                            message.compute_bandwidth_used = object.compute_bandwidth_used;
                        else if (typeof object.compute_bandwidth_used === "object")
                            message.compute_bandwidth_used = new $util.LongBits(object.compute_bandwidth_used.low >>> 0, object.compute_bandwidth_used.high >>> 0).toNumber(true);
                    if (object.state_merkle_root != null)
                        if (typeof object.state_merkle_root === "string")
                            $util.base64.decode(object.state_merkle_root, message.state_merkle_root = $util.newBuffer($util.base64.length(object.state_merkle_root)), 0);
                        else if (object.state_merkle_root.length)
                            message.state_merkle_root = object.state_merkle_root;
                    if (object.events) {
                        if (!Array.isArray(object.events))
                            throw TypeError(".koinos.protocol.block_receipt.events: array expected");
                        message.events = [];
                        for (var i = 0; i < object.events.length; ++i) {
                            if (typeof object.events[i] !== "object")
                                throw TypeError(".koinos.protocol.block_receipt.events: object expected");
                            message.events[i] = $root.koinos.protocol.event_data.fromObject(object.events[i]);
                        }
                    }
                    if (object.transaction_receipts) {
                        if (!Array.isArray(object.transaction_receipts))
                            throw TypeError(".koinos.protocol.block_receipt.transaction_receipts: array expected");
                        message.transaction_receipts = [];
                        for (var i = 0; i < object.transaction_receipts.length; ++i) {
                            if (typeof object.transaction_receipts[i] !== "object")
                                throw TypeError(".koinos.protocol.block_receipt.transaction_receipts: object expected");
                            message.transaction_receipts[i] = $root.koinos.protocol.transaction_receipt.fromObject(object.transaction_receipts[i]);
                        }
                    }
                    if (object.logs) {
                        if (!Array.isArray(object.logs))
                            throw TypeError(".koinos.protocol.block_receipt.logs: array expected");
                        message.logs = [];
                        for (var i = 0; i < object.logs.length; ++i)
                            message.logs[i] = String(object.logs[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a block_receipt message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.protocol.block_receipt
                 * @static
                 * @param {koinos.protocol.block_receipt} message block_receipt
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block_receipt.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.events = [];
                        object.transaction_receipts = [];
                        object.logs = [];
                    }
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.disk_storage_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.disk_storage_used = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.network_bandwidth_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.network_bandwidth_used = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.compute_bandwidth_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.compute_bandwidth_used = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.state_merkle_root = "";
                        else {
                            object.state_merkle_root = [];
                            if (options.bytes !== Array)
                                object.state_merkle_root = $util.newBuffer(object.state_merkle_root);
                        }
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                    if (message.disk_storage_used != null && message.hasOwnProperty("disk_storage_used"))
                        if (typeof message.disk_storage_used === "number")
                            object.disk_storage_used = options.longs === String ? String(message.disk_storage_used) : message.disk_storage_used;
                        else
                            object.disk_storage_used = options.longs === String ? $util.Long.prototype.toString.call(message.disk_storage_used) : options.longs === Number ? new $util.LongBits(message.disk_storage_used.low >>> 0, message.disk_storage_used.high >>> 0).toNumber(true) : message.disk_storage_used;
                    if (message.network_bandwidth_used != null && message.hasOwnProperty("network_bandwidth_used"))
                        if (typeof message.network_bandwidth_used === "number")
                            object.network_bandwidth_used = options.longs === String ? String(message.network_bandwidth_used) : message.network_bandwidth_used;
                        else
                            object.network_bandwidth_used = options.longs === String ? $util.Long.prototype.toString.call(message.network_bandwidth_used) : options.longs === Number ? new $util.LongBits(message.network_bandwidth_used.low >>> 0, message.network_bandwidth_used.high >>> 0).toNumber(true) : message.network_bandwidth_used;
                    if (message.compute_bandwidth_used != null && message.hasOwnProperty("compute_bandwidth_used"))
                        if (typeof message.compute_bandwidth_used === "number")
                            object.compute_bandwidth_used = options.longs === String ? String(message.compute_bandwidth_used) : message.compute_bandwidth_used;
                        else
                            object.compute_bandwidth_used = options.longs === String ? $util.Long.prototype.toString.call(message.compute_bandwidth_used) : options.longs === Number ? new $util.LongBits(message.compute_bandwidth_used.low >>> 0, message.compute_bandwidth_used.high >>> 0).toNumber(true) : message.compute_bandwidth_used;
                    if (message.state_merkle_root != null && message.hasOwnProperty("state_merkle_root"))
                        object.state_merkle_root = options.bytes === String ? $util.base64.encode(message.state_merkle_root, 0, message.state_merkle_root.length) : options.bytes === Array ? Array.prototype.slice.call(message.state_merkle_root) : message.state_merkle_root;
                    if (message.events && message.events.length) {
                        object.events = [];
                        for (var j = 0; j < message.events.length; ++j)
                            object.events[j] = $root.koinos.protocol.event_data.toObject(message.events[j], options);
                    }
                    if (message.transaction_receipts && message.transaction_receipts.length) {
                        object.transaction_receipts = [];
                        for (var j = 0; j < message.transaction_receipts.length; ++j)
                            object.transaction_receipts[j] = $root.koinos.protocol.transaction_receipt.toObject(message.transaction_receipts[j], options);
                    }
                    if (message.logs && message.logs.length) {
                        object.logs = [];
                        for (var j = 0; j < message.logs.length; ++j)
                            object.logs[j] = message.logs[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this block_receipt to JSON.
                 * @function toJSON
                 * @memberof koinos.protocol.block_receipt
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block_receipt.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block_receipt;
            })();
    
            return protocol;
        })();
    
        koinos.transaction_store = (function() {
    
            /**
             * Namespace transaction_store.
             * @memberof koinos
             * @namespace
             */
            var transaction_store = {};
    
            transaction_store.transaction_item = (function() {
    
                /**
                 * Properties of a transaction_item.
                 * @memberof koinos.transaction_store
                 * @interface Itransaction_item
                 * @property {koinos.protocol.Itransaction|null} [transaction] transaction_item transaction
                 * @property {Array.<Uint8Array>|null} [containing_blocks] transaction_item containing_blocks
                 */
    
                /**
                 * Constructs a new transaction_item.
                 * @memberof koinos.transaction_store
                 * @classdesc Represents a transaction_item.
                 * @implements Itransaction_item
                 * @constructor
                 * @param {koinos.transaction_store.Itransaction_item=} [properties] Properties to set
                 */
                function transaction_item(properties) {
                    this.containing_blocks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * transaction_item transaction.
                 * @member {koinos.protocol.Itransaction|null|undefined} transaction
                 * @memberof koinos.transaction_store.transaction_item
                 * @instance
                 */
                transaction_item.prototype.transaction = null;
    
                /**
                 * transaction_item containing_blocks.
                 * @member {Array.<Uint8Array>} containing_blocks
                 * @memberof koinos.transaction_store.transaction_item
                 * @instance
                 */
                transaction_item.prototype.containing_blocks = $util.emptyArray;
    
                /**
                 * Creates a new transaction_item instance using the specified properties.
                 * @function create
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {koinos.transaction_store.Itransaction_item=} [properties] Properties to set
                 * @returns {koinos.transaction_store.transaction_item} transaction_item instance
                 */
                transaction_item.create = function create(properties) {
                    return new transaction_item(properties);
                };
    
                /**
                 * Encodes the specified transaction_item message. Does not implicitly {@link koinos.transaction_store.transaction_item.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {koinos.transaction_store.Itransaction_item} message transaction_item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_item.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                        $root.koinos.protocol.transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.containing_blocks != null && message.containing_blocks.length)
                        for (var i = 0; i < message.containing_blocks.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.containing_blocks[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified transaction_item message, length delimited. Does not implicitly {@link koinos.transaction_store.transaction_item.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {koinos.transaction_store.Itransaction_item} message transaction_item message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_item.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a transaction_item message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.transaction_store.transaction_item} transaction_item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_item.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.transaction_store.transaction_item();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transaction = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.containing_blocks && message.containing_blocks.length))
                                message.containing_blocks = [];
                            message.containing_blocks.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a transaction_item message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.transaction_store.transaction_item} transaction_item
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_item.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a transaction_item message.
                 * @function verify
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                transaction_item.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transaction != null && message.hasOwnProperty("transaction")) {
                        var error = $root.koinos.protocol.transaction.verify(message.transaction);
                        if (error)
                            return "transaction." + error;
                    }
                    if (message.containing_blocks != null && message.hasOwnProperty("containing_blocks")) {
                        if (!Array.isArray(message.containing_blocks))
                            return "containing_blocks: array expected";
                        for (var i = 0; i < message.containing_blocks.length; ++i)
                            if (!(message.containing_blocks[i] && typeof message.containing_blocks[i].length === "number" || $util.isString(message.containing_blocks[i])))
                                return "containing_blocks: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a transaction_item message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.transaction_store.transaction_item} transaction_item
                 */
                transaction_item.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.transaction_store.transaction_item)
                        return object;
                    var message = new $root.koinos.transaction_store.transaction_item();
                    if (object.transaction != null) {
                        if (typeof object.transaction !== "object")
                            throw TypeError(".koinos.transaction_store.transaction_item.transaction: object expected");
                        message.transaction = $root.koinos.protocol.transaction.fromObject(object.transaction);
                    }
                    if (object.containing_blocks) {
                        if (!Array.isArray(object.containing_blocks))
                            throw TypeError(".koinos.transaction_store.transaction_item.containing_blocks: array expected");
                        message.containing_blocks = [];
                        for (var i = 0; i < object.containing_blocks.length; ++i)
                            if (typeof object.containing_blocks[i] === "string")
                                $util.base64.decode(object.containing_blocks[i], message.containing_blocks[i] = $util.newBuffer($util.base64.length(object.containing_blocks[i])), 0);
                            else if (object.containing_blocks[i].length)
                                message.containing_blocks[i] = object.containing_blocks[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a transaction_item message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.transaction_store.transaction_item
                 * @static
                 * @param {koinos.transaction_store.transaction_item} message transaction_item
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                transaction_item.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.containing_blocks = [];
                    if (options.defaults)
                        object.transaction = null;
                    if (message.transaction != null && message.hasOwnProperty("transaction"))
                        object.transaction = $root.koinos.protocol.transaction.toObject(message.transaction, options);
                    if (message.containing_blocks && message.containing_blocks.length) {
                        object.containing_blocks = [];
                        for (var j = 0; j < message.containing_blocks.length; ++j)
                            object.containing_blocks[j] = options.bytes === String ? $util.base64.encode(message.containing_blocks[j], 0, message.containing_blocks[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.containing_blocks[j]) : message.containing_blocks[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this transaction_item to JSON.
                 * @function toJSON
                 * @memberof koinos.transaction_store.transaction_item
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                transaction_item.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return transaction_item;
            })();
    
            return transaction_store;
        })();
    
        koinos.broadcast = (function() {
    
            /**
             * Namespace broadcast.
             * @memberof koinos
             * @namespace
             */
            var broadcast = {};
    
            broadcast.transaction_accepted = (function() {
    
                /**
                 * Properties of a transaction_accepted.
                 * @memberof koinos.broadcast
                 * @interface Itransaction_accepted
                 * @property {koinos.protocol.Itransaction|null} [transaction] transaction_accepted transaction
                 * @property {koinos.protocol.Itransaction_receipt|null} [receipt] transaction_accepted receipt
                 * @property {number|Long|null} [height] transaction_accepted height
                 */
    
                /**
                 * Constructs a new transaction_accepted.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a transaction_accepted.
                 * @implements Itransaction_accepted
                 * @constructor
                 * @param {koinos.broadcast.Itransaction_accepted=} [properties] Properties to set
                 */
                function transaction_accepted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * transaction_accepted transaction.
                 * @member {koinos.protocol.Itransaction|null|undefined} transaction
                 * @memberof koinos.broadcast.transaction_accepted
                 * @instance
                 */
                transaction_accepted.prototype.transaction = null;
    
                /**
                 * transaction_accepted receipt.
                 * @member {koinos.protocol.Itransaction_receipt|null|undefined} receipt
                 * @memberof koinos.broadcast.transaction_accepted
                 * @instance
                 */
                transaction_accepted.prototype.receipt = null;
    
                /**
                 * transaction_accepted height.
                 * @member {number|Long} height
                 * @memberof koinos.broadcast.transaction_accepted
                 * @instance
                 */
                transaction_accepted.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new transaction_accepted instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {koinos.broadcast.Itransaction_accepted=} [properties] Properties to set
                 * @returns {koinos.broadcast.transaction_accepted} transaction_accepted instance
                 */
                transaction_accepted.create = function create(properties) {
                    return new transaction_accepted(properties);
                };
    
                /**
                 * Encodes the specified transaction_accepted message. Does not implicitly {@link koinos.broadcast.transaction_accepted.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {koinos.broadcast.Itransaction_accepted} message transaction_accepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_accepted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                        $root.koinos.protocol.transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                        $root.koinos.protocol.transaction_receipt.encode(message.receipt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.height);
                    return writer;
                };
    
                /**
                 * Encodes the specified transaction_accepted message, length delimited. Does not implicitly {@link koinos.broadcast.transaction_accepted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {koinos.broadcast.Itransaction_accepted} message transaction_accepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_accepted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a transaction_accepted message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.transaction_accepted} transaction_accepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_accepted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.transaction_accepted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transaction = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.receipt = $root.koinos.protocol.transaction_receipt.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.height = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a transaction_accepted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.transaction_accepted} transaction_accepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_accepted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a transaction_accepted message.
                 * @function verify
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                transaction_accepted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transaction != null && message.hasOwnProperty("transaction")) {
                        var error = $root.koinos.protocol.transaction.verify(message.transaction);
                        if (error)
                            return "transaction." + error;
                    }
                    if (message.receipt != null && message.hasOwnProperty("receipt")) {
                        var error = $root.koinos.protocol.transaction_receipt.verify(message.receipt);
                        if (error)
                            return "receipt." + error;
                    }
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a transaction_accepted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.transaction_accepted} transaction_accepted
                 */
                transaction_accepted.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.transaction_accepted)
                        return object;
                    var message = new $root.koinos.broadcast.transaction_accepted();
                    if (object.transaction != null) {
                        if (typeof object.transaction !== "object")
                            throw TypeError(".koinos.broadcast.transaction_accepted.transaction: object expected");
                        message.transaction = $root.koinos.protocol.transaction.fromObject(object.transaction);
                    }
                    if (object.receipt != null) {
                        if (typeof object.receipt !== "object")
                            throw TypeError(".koinos.broadcast.transaction_accepted.receipt: object expected");
                        message.receipt = $root.koinos.protocol.transaction_receipt.fromObject(object.receipt);
                    }
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a transaction_accepted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.transaction_accepted
                 * @static
                 * @param {koinos.broadcast.transaction_accepted} message transaction_accepted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                transaction_accepted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.transaction = null;
                        object.receipt = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                    }
                    if (message.transaction != null && message.hasOwnProperty("transaction"))
                        object.transaction = $root.koinos.protocol.transaction.toObject(message.transaction, options);
                    if (message.receipt != null && message.hasOwnProperty("receipt"))
                        object.receipt = $root.koinos.protocol.transaction_receipt.toObject(message.receipt, options);
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                    return object;
                };
    
                /**
                 * Converts this transaction_accepted to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.transaction_accepted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                transaction_accepted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return transaction_accepted;
            })();
    
            broadcast.transaction_failed = (function() {
    
                /**
                 * Properties of a transaction_failed.
                 * @memberof koinos.broadcast
                 * @interface Itransaction_failed
                 * @property {Uint8Array|null} [id] transaction_failed id
                 */
    
                /**
                 * Constructs a new transaction_failed.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a transaction_failed.
                 * @implements Itransaction_failed
                 * @constructor
                 * @param {koinos.broadcast.Itransaction_failed=} [properties] Properties to set
                 */
                function transaction_failed(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * transaction_failed id.
                 * @member {Uint8Array} id
                 * @memberof koinos.broadcast.transaction_failed
                 * @instance
                 */
                transaction_failed.prototype.id = $util.newBuffer([]);
    
                /**
                 * Creates a new transaction_failed instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {koinos.broadcast.Itransaction_failed=} [properties] Properties to set
                 * @returns {koinos.broadcast.transaction_failed} transaction_failed instance
                 */
                transaction_failed.create = function create(properties) {
                    return new transaction_failed(properties);
                };
    
                /**
                 * Encodes the specified transaction_failed message. Does not implicitly {@link koinos.broadcast.transaction_failed.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {koinos.broadcast.Itransaction_failed} message transaction_failed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_failed.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified transaction_failed message, length delimited. Does not implicitly {@link koinos.broadcast.transaction_failed.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {koinos.broadcast.Itransaction_failed} message transaction_failed message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                transaction_failed.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a transaction_failed message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.transaction_failed} transaction_failed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_failed.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.transaction_failed();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a transaction_failed message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.transaction_failed} transaction_failed
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                transaction_failed.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a transaction_failed message.
                 * @function verify
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                transaction_failed.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a transaction_failed message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.transaction_failed} transaction_failed
                 */
                transaction_failed.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.transaction_failed)
                        return object;
                    var message = new $root.koinos.broadcast.transaction_failed();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    return message;
                };
    
                /**
                 * Creates a plain object from a transaction_failed message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.transaction_failed
                 * @static
                 * @param {koinos.broadcast.transaction_failed} message transaction_failed
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                transaction_failed.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    return object;
                };
    
                /**
                 * Converts this transaction_failed to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.transaction_failed
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                transaction_failed.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return transaction_failed;
            })();
    
            broadcast.mempool_accepted = (function() {
    
                /**
                 * Properties of a mempool_accepted.
                 * @memberof koinos.broadcast
                 * @interface Imempool_accepted
                 * @property {koinos.protocol.Itransaction|null} [transaction] mempool_accepted transaction
                 * @property {koinos.protocol.Itransaction_receipt|null} [receipt] mempool_accepted receipt
                 * @property {number|Long|null} [height] mempool_accepted height
                 * @property {number|Long|null} [pending_rc_used] mempool_accepted pending_rc_used
                 */
    
                /**
                 * Constructs a new mempool_accepted.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a mempool_accepted.
                 * @implements Imempool_accepted
                 * @constructor
                 * @param {koinos.broadcast.Imempool_accepted=} [properties] Properties to set
                 */
                function mempool_accepted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * mempool_accepted transaction.
                 * @member {koinos.protocol.Itransaction|null|undefined} transaction
                 * @memberof koinos.broadcast.mempool_accepted
                 * @instance
                 */
                mempool_accepted.prototype.transaction = null;
    
                /**
                 * mempool_accepted receipt.
                 * @member {koinos.protocol.Itransaction_receipt|null|undefined} receipt
                 * @memberof koinos.broadcast.mempool_accepted
                 * @instance
                 */
                mempool_accepted.prototype.receipt = null;
    
                /**
                 * mempool_accepted height.
                 * @member {number|Long} height
                 * @memberof koinos.broadcast.mempool_accepted
                 * @instance
                 */
                mempool_accepted.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * mempool_accepted pending_rc_used.
                 * @member {number|Long} pending_rc_used
                 * @memberof koinos.broadcast.mempool_accepted
                 * @instance
                 */
                mempool_accepted.prototype.pending_rc_used = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new mempool_accepted instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {koinos.broadcast.Imempool_accepted=} [properties] Properties to set
                 * @returns {koinos.broadcast.mempool_accepted} mempool_accepted instance
                 */
                mempool_accepted.create = function create(properties) {
                    return new mempool_accepted(properties);
                };
    
                /**
                 * Encodes the specified mempool_accepted message. Does not implicitly {@link koinos.broadcast.mempool_accepted.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {koinos.broadcast.Imempool_accepted} message mempool_accepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                mempool_accepted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                        $root.koinos.protocol.transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                        $root.koinos.protocol.transaction_receipt.encode(message.receipt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.height);
                    if (message.pending_rc_used != null && Object.hasOwnProperty.call(message, "pending_rc_used"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.pending_rc_used);
                    return writer;
                };
    
                /**
                 * Encodes the specified mempool_accepted message, length delimited. Does not implicitly {@link koinos.broadcast.mempool_accepted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {koinos.broadcast.Imempool_accepted} message mempool_accepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                mempool_accepted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a mempool_accepted message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.mempool_accepted} mempool_accepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                mempool_accepted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.mempool_accepted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transaction = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.receipt = $root.koinos.protocol.transaction_receipt.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.height = reader.uint64();
                            break;
                        case 4:
                            message.pending_rc_used = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a mempool_accepted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.mempool_accepted} mempool_accepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                mempool_accepted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a mempool_accepted message.
                 * @function verify
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                mempool_accepted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transaction != null && message.hasOwnProperty("transaction")) {
                        var error = $root.koinos.protocol.transaction.verify(message.transaction);
                        if (error)
                            return "transaction." + error;
                    }
                    if (message.receipt != null && message.hasOwnProperty("receipt")) {
                        var error = $root.koinos.protocol.transaction_receipt.verify(message.receipt);
                        if (error)
                            return "receipt." + error;
                    }
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    if (message.pending_rc_used != null && message.hasOwnProperty("pending_rc_used"))
                        if (!$util.isInteger(message.pending_rc_used) && !(message.pending_rc_used && $util.isInteger(message.pending_rc_used.low) && $util.isInteger(message.pending_rc_used.high)))
                            return "pending_rc_used: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a mempool_accepted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.mempool_accepted} mempool_accepted
                 */
                mempool_accepted.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.mempool_accepted)
                        return object;
                    var message = new $root.koinos.broadcast.mempool_accepted();
                    if (object.transaction != null) {
                        if (typeof object.transaction !== "object")
                            throw TypeError(".koinos.broadcast.mempool_accepted.transaction: object expected");
                        message.transaction = $root.koinos.protocol.transaction.fromObject(object.transaction);
                    }
                    if (object.receipt != null) {
                        if (typeof object.receipt !== "object")
                            throw TypeError(".koinos.broadcast.mempool_accepted.receipt: object expected");
                        message.receipt = $root.koinos.protocol.transaction_receipt.fromObject(object.receipt);
                    }
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                    if (object.pending_rc_used != null)
                        if ($util.Long)
                            (message.pending_rc_used = $util.Long.fromValue(object.pending_rc_used)).unsigned = true;
                        else if (typeof object.pending_rc_used === "string")
                            message.pending_rc_used = parseInt(object.pending_rc_used, 10);
                        else if (typeof object.pending_rc_used === "number")
                            message.pending_rc_used = object.pending_rc_used;
                        else if (typeof object.pending_rc_used === "object")
                            message.pending_rc_used = new $util.LongBits(object.pending_rc_used.low >>> 0, object.pending_rc_used.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a mempool_accepted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.mempool_accepted
                 * @static
                 * @param {koinos.broadcast.mempool_accepted} message mempool_accepted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                mempool_accepted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.transaction = null;
                        object.receipt = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.pending_rc_used = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.pending_rc_used = options.longs === String ? "0" : 0;
                    }
                    if (message.transaction != null && message.hasOwnProperty("transaction"))
                        object.transaction = $root.koinos.protocol.transaction.toObject(message.transaction, options);
                    if (message.receipt != null && message.hasOwnProperty("receipt"))
                        object.receipt = $root.koinos.protocol.transaction_receipt.toObject(message.receipt, options);
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                    if (message.pending_rc_used != null && message.hasOwnProperty("pending_rc_used"))
                        if (typeof message.pending_rc_used === "number")
                            object.pending_rc_used = options.longs === String ? String(message.pending_rc_used) : message.pending_rc_used;
                        else
                            object.pending_rc_used = options.longs === String ? $util.Long.prototype.toString.call(message.pending_rc_used) : options.longs === Number ? new $util.LongBits(message.pending_rc_used.low >>> 0, message.pending_rc_used.high >>> 0).toNumber(true) : message.pending_rc_used;
                    return object;
                };
    
                /**
                 * Converts this mempool_accepted to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.mempool_accepted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                mempool_accepted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return mempool_accepted;
            })();
    
            broadcast.block_accepted = (function() {
    
                /**
                 * Properties of a block_accepted.
                 * @memberof koinos.broadcast
                 * @interface Iblock_accepted
                 * @property {koinos.protocol.Iblock|null} [block] block_accepted block
                 * @property {koinos.protocol.Iblock_receipt|null} [receipt] block_accepted receipt
                 * @property {boolean|null} [live] block_accepted live
                 * @property {boolean|null} [head] block_accepted head
                 */
    
                /**
                 * Constructs a new block_accepted.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a block_accepted.
                 * @implements Iblock_accepted
                 * @constructor
                 * @param {koinos.broadcast.Iblock_accepted=} [properties] Properties to set
                 */
                function block_accepted(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block_accepted block.
                 * @member {koinos.protocol.Iblock|null|undefined} block
                 * @memberof koinos.broadcast.block_accepted
                 * @instance
                 */
                block_accepted.prototype.block = null;
    
                /**
                 * block_accepted receipt.
                 * @member {koinos.protocol.Iblock_receipt|null|undefined} receipt
                 * @memberof koinos.broadcast.block_accepted
                 * @instance
                 */
                block_accepted.prototype.receipt = null;
    
                /**
                 * block_accepted live.
                 * @member {boolean} live
                 * @memberof koinos.broadcast.block_accepted
                 * @instance
                 */
                block_accepted.prototype.live = false;
    
                /**
                 * block_accepted head.
                 * @member {boolean} head
                 * @memberof koinos.broadcast.block_accepted
                 * @instance
                 */
                block_accepted.prototype.head = false;
    
                /**
                 * Creates a new block_accepted instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {koinos.broadcast.Iblock_accepted=} [properties] Properties to set
                 * @returns {koinos.broadcast.block_accepted} block_accepted instance
                 */
                block_accepted.create = function create(properties) {
                    return new block_accepted(properties);
                };
    
                /**
                 * Encodes the specified block_accepted message. Does not implicitly {@link koinos.broadcast.block_accepted.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {koinos.broadcast.Iblock_accepted} message block_accepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_accepted.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                        $root.koinos.protocol.block.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.receipt != null && Object.hasOwnProperty.call(message, "receipt"))
                        $root.koinos.protocol.block_receipt.encode(message.receipt, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.live != null && Object.hasOwnProperty.call(message, "live"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.live);
                    if (message.head != null && Object.hasOwnProperty.call(message, "head"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.head);
                    return writer;
                };
    
                /**
                 * Encodes the specified block_accepted message, length delimited. Does not implicitly {@link koinos.broadcast.block_accepted.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {koinos.broadcast.Iblock_accepted} message block_accepted message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_accepted.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block_accepted message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.block_accepted} block_accepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_accepted.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.block_accepted();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block = $root.koinos.protocol.block.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.receipt = $root.koinos.protocol.block_receipt.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.live = reader.bool();
                            break;
                        case 4:
                            message.head = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block_accepted message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.block_accepted} block_accepted
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_accepted.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block_accepted message.
                 * @function verify
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block_accepted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.block != null && message.hasOwnProperty("block")) {
                        var error = $root.koinos.protocol.block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                    if (message.receipt != null && message.hasOwnProperty("receipt")) {
                        var error = $root.koinos.protocol.block_receipt.verify(message.receipt);
                        if (error)
                            return "receipt." + error;
                    }
                    if (message.live != null && message.hasOwnProperty("live"))
                        if (typeof message.live !== "boolean")
                            return "live: boolean expected";
                    if (message.head != null && message.hasOwnProperty("head"))
                        if (typeof message.head !== "boolean")
                            return "head: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a block_accepted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.block_accepted} block_accepted
                 */
                block_accepted.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.block_accepted)
                        return object;
                    var message = new $root.koinos.broadcast.block_accepted();
                    if (object.block != null) {
                        if (typeof object.block !== "object")
                            throw TypeError(".koinos.broadcast.block_accepted.block: object expected");
                        message.block = $root.koinos.protocol.block.fromObject(object.block);
                    }
                    if (object.receipt != null) {
                        if (typeof object.receipt !== "object")
                            throw TypeError(".koinos.broadcast.block_accepted.receipt: object expected");
                        message.receipt = $root.koinos.protocol.block_receipt.fromObject(object.receipt);
                    }
                    if (object.live != null)
                        message.live = Boolean(object.live);
                    if (object.head != null)
                        message.head = Boolean(object.head);
                    return message;
                };
    
                /**
                 * Creates a plain object from a block_accepted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.block_accepted
                 * @static
                 * @param {koinos.broadcast.block_accepted} message block_accepted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block_accepted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.block = null;
                        object.receipt = null;
                        object.live = false;
                        object.head = false;
                    }
                    if (message.block != null && message.hasOwnProperty("block"))
                        object.block = $root.koinos.protocol.block.toObject(message.block, options);
                    if (message.receipt != null && message.hasOwnProperty("receipt"))
                        object.receipt = $root.koinos.protocol.block_receipt.toObject(message.receipt, options);
                    if (message.live != null && message.hasOwnProperty("live"))
                        object.live = message.live;
                    if (message.head != null && message.hasOwnProperty("head"))
                        object.head = message.head;
                    return object;
                };
    
                /**
                 * Converts this block_accepted to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.block_accepted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block_accepted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block_accepted;
            })();
    
            broadcast.block_irreversible = (function() {
    
                /**
                 * Properties of a block_irreversible.
                 * @memberof koinos.broadcast
                 * @interface Iblock_irreversible
                 * @property {koinos.Iblock_topology|null} [topology] block_irreversible topology
                 */
    
                /**
                 * Constructs a new block_irreversible.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a block_irreversible.
                 * @implements Iblock_irreversible
                 * @constructor
                 * @param {koinos.broadcast.Iblock_irreversible=} [properties] Properties to set
                 */
                function block_irreversible(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * block_irreversible topology.
                 * @member {koinos.Iblock_topology|null|undefined} topology
                 * @memberof koinos.broadcast.block_irreversible
                 * @instance
                 */
                block_irreversible.prototype.topology = null;
    
                /**
                 * Creates a new block_irreversible instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {koinos.broadcast.Iblock_irreversible=} [properties] Properties to set
                 * @returns {koinos.broadcast.block_irreversible} block_irreversible instance
                 */
                block_irreversible.create = function create(properties) {
                    return new block_irreversible(properties);
                };
    
                /**
                 * Encodes the specified block_irreversible message. Does not implicitly {@link koinos.broadcast.block_irreversible.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {koinos.broadcast.Iblock_irreversible} message block_irreversible message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_irreversible.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.topology != null && Object.hasOwnProperty.call(message, "topology"))
                        $root.koinos.block_topology.encode(message.topology, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified block_irreversible message, length delimited. Does not implicitly {@link koinos.broadcast.block_irreversible.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {koinos.broadcast.Iblock_irreversible} message block_irreversible message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                block_irreversible.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a block_irreversible message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.block_irreversible} block_irreversible
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_irreversible.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.block_irreversible();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.topology = $root.koinos.block_topology.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a block_irreversible message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.block_irreversible} block_irreversible
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                block_irreversible.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a block_irreversible message.
                 * @function verify
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                block_irreversible.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.topology != null && message.hasOwnProperty("topology")) {
                        var error = $root.koinos.block_topology.verify(message.topology);
                        if (error)
                            return "topology." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a block_irreversible message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.block_irreversible} block_irreversible
                 */
                block_irreversible.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.block_irreversible)
                        return object;
                    var message = new $root.koinos.broadcast.block_irreversible();
                    if (object.topology != null) {
                        if (typeof object.topology !== "object")
                            throw TypeError(".koinos.broadcast.block_irreversible.topology: object expected");
                        message.topology = $root.koinos.block_topology.fromObject(object.topology);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a block_irreversible message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.block_irreversible
                 * @static
                 * @param {koinos.broadcast.block_irreversible} message block_irreversible
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                block_irreversible.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.topology = null;
                    if (message.topology != null && message.hasOwnProperty("topology"))
                        object.topology = $root.koinos.block_topology.toObject(message.topology, options);
                    return object;
                };
    
                /**
                 * Converts this block_irreversible to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.block_irreversible
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                block_irreversible.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return block_irreversible;
            })();
    
            broadcast.fork_heads = (function() {
    
                /**
                 * Properties of a fork_heads.
                 * @memberof koinos.broadcast
                 * @interface Ifork_heads
                 * @property {koinos.Iblock_topology|null} [last_irreversible_block] fork_heads last_irreversible_block
                 * @property {Array.<koinos.Iblock_topology>|null} [heads] fork_heads heads
                 */
    
                /**
                 * Constructs a new fork_heads.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a fork_heads.
                 * @implements Ifork_heads
                 * @constructor
                 * @param {koinos.broadcast.Ifork_heads=} [properties] Properties to set
                 */
                function fork_heads(properties) {
                    this.heads = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * fork_heads last_irreversible_block.
                 * @member {koinos.Iblock_topology|null|undefined} last_irreversible_block
                 * @memberof koinos.broadcast.fork_heads
                 * @instance
                 */
                fork_heads.prototype.last_irreversible_block = null;
    
                /**
                 * fork_heads heads.
                 * @member {Array.<koinos.Iblock_topology>} heads
                 * @memberof koinos.broadcast.fork_heads
                 * @instance
                 */
                fork_heads.prototype.heads = $util.emptyArray;
    
                /**
                 * Creates a new fork_heads instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {koinos.broadcast.Ifork_heads=} [properties] Properties to set
                 * @returns {koinos.broadcast.fork_heads} fork_heads instance
                 */
                fork_heads.create = function create(properties) {
                    return new fork_heads(properties);
                };
    
                /**
                 * Encodes the specified fork_heads message. Does not implicitly {@link koinos.broadcast.fork_heads.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {koinos.broadcast.Ifork_heads} message fork_heads message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                fork_heads.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.last_irreversible_block != null && Object.hasOwnProperty.call(message, "last_irreversible_block"))
                        $root.koinos.block_topology.encode(message.last_irreversible_block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.heads != null && message.heads.length)
                        for (var i = 0; i < message.heads.length; ++i)
                            $root.koinos.block_topology.encode(message.heads[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified fork_heads message, length delimited. Does not implicitly {@link koinos.broadcast.fork_heads.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {koinos.broadcast.Ifork_heads} message fork_heads message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                fork_heads.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a fork_heads message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.fork_heads} fork_heads
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                fork_heads.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.fork_heads();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.last_irreversible_block = $root.koinos.block_topology.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.heads && message.heads.length))
                                message.heads = [];
                            message.heads.push($root.koinos.block_topology.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a fork_heads message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.fork_heads} fork_heads
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                fork_heads.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a fork_heads message.
                 * @function verify
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                fork_heads.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block")) {
                        var error = $root.koinos.block_topology.verify(message.last_irreversible_block);
                        if (error)
                            return "last_irreversible_block." + error;
                    }
                    if (message.heads != null && message.hasOwnProperty("heads")) {
                        if (!Array.isArray(message.heads))
                            return "heads: array expected";
                        for (var i = 0; i < message.heads.length; ++i) {
                            var error = $root.koinos.block_topology.verify(message.heads[i]);
                            if (error)
                                return "heads." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a fork_heads message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.fork_heads} fork_heads
                 */
                fork_heads.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.fork_heads)
                        return object;
                    var message = new $root.koinos.broadcast.fork_heads();
                    if (object.last_irreversible_block != null) {
                        if (typeof object.last_irreversible_block !== "object")
                            throw TypeError(".koinos.broadcast.fork_heads.last_irreversible_block: object expected");
                        message.last_irreversible_block = $root.koinos.block_topology.fromObject(object.last_irreversible_block);
                    }
                    if (object.heads) {
                        if (!Array.isArray(object.heads))
                            throw TypeError(".koinos.broadcast.fork_heads.heads: array expected");
                        message.heads = [];
                        for (var i = 0; i < object.heads.length; ++i) {
                            if (typeof object.heads[i] !== "object")
                                throw TypeError(".koinos.broadcast.fork_heads.heads: object expected");
                            message.heads[i] = $root.koinos.block_topology.fromObject(object.heads[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a fork_heads message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.fork_heads
                 * @static
                 * @param {koinos.broadcast.fork_heads} message fork_heads
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                fork_heads.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.heads = [];
                    if (options.defaults)
                        object.last_irreversible_block = null;
                    if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block"))
                        object.last_irreversible_block = $root.koinos.block_topology.toObject(message.last_irreversible_block, options);
                    if (message.heads && message.heads.length) {
                        object.heads = [];
                        for (var j = 0; j < message.heads.length; ++j)
                            object.heads[j] = $root.koinos.block_topology.toObject(message.heads[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this fork_heads to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.fork_heads
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                fork_heads.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return fork_heads;
            })();
    
            broadcast.gossip_status = (function() {
    
                /**
                 * Properties of a gossip_status.
                 * @memberof koinos.broadcast
                 * @interface Igossip_status
                 * @property {boolean|null} [enabled] gossip_status enabled
                 */
    
                /**
                 * Constructs a new gossip_status.
                 * @memberof koinos.broadcast
                 * @classdesc Represents a gossip_status.
                 * @implements Igossip_status
                 * @constructor
                 * @param {koinos.broadcast.Igossip_status=} [properties] Properties to set
                 */
                function gossip_status(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * gossip_status enabled.
                 * @member {boolean} enabled
                 * @memberof koinos.broadcast.gossip_status
                 * @instance
                 */
                gossip_status.prototype.enabled = false;
    
                /**
                 * Creates a new gossip_status instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {koinos.broadcast.Igossip_status=} [properties] Properties to set
                 * @returns {koinos.broadcast.gossip_status} gossip_status instance
                 */
                gossip_status.create = function create(properties) {
                    return new gossip_status(properties);
                };
    
                /**
                 * Encodes the specified gossip_status message. Does not implicitly {@link koinos.broadcast.gossip_status.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {koinos.broadcast.Igossip_status} message gossip_status message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                gossip_status.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.enabled != null && Object.hasOwnProperty.call(message, "enabled"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);
                    return writer;
                };
    
                /**
                 * Encodes the specified gossip_status message, length delimited. Does not implicitly {@link koinos.broadcast.gossip_status.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {koinos.broadcast.Igossip_status} message gossip_status message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                gossip_status.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a gossip_status message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.gossip_status} gossip_status
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                gossip_status.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.gossip_status();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.enabled = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a gossip_status message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.gossip_status} gossip_status
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                gossip_status.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a gossip_status message.
                 * @function verify
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                gossip_status.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        if (typeof message.enabled !== "boolean")
                            return "enabled: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a gossip_status message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.gossip_status} gossip_status
                 */
                gossip_status.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.gossip_status)
                        return object;
                    var message = new $root.koinos.broadcast.gossip_status();
                    if (object.enabled != null)
                        message.enabled = Boolean(object.enabled);
                    return message;
                };
    
                /**
                 * Creates a plain object from a gossip_status message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.gossip_status
                 * @static
                 * @param {koinos.broadcast.gossip_status} message gossip_status
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                gossip_status.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.enabled = false;
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        object.enabled = message.enabled;
                    return object;
                };
    
                /**
                 * Converts this gossip_status to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.gossip_status
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                gossip_status.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return gossip_status;
            })();
    
            broadcast.event_parcel = (function() {
    
                /**
                 * Properties of an event_parcel.
                 * @memberof koinos.broadcast
                 * @interface Ievent_parcel
                 * @property {Uint8Array|null} [block_id] event_parcel block_id
                 * @property {number|Long|null} [height] event_parcel height
                 * @property {Uint8Array|null} [transaction_id] event_parcel transaction_id
                 * @property {koinos.protocol.Ievent_data|null} [event] event_parcel event
                 */
    
                /**
                 * Constructs a new event_parcel.
                 * @memberof koinos.broadcast
                 * @classdesc Represents an event_parcel.
                 * @implements Ievent_parcel
                 * @constructor
                 * @param {koinos.broadcast.Ievent_parcel=} [properties] Properties to set
                 */
                function event_parcel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * event_parcel block_id.
                 * @member {Uint8Array} block_id
                 * @memberof koinos.broadcast.event_parcel
                 * @instance
                 */
                event_parcel.prototype.block_id = $util.newBuffer([]);
    
                /**
                 * event_parcel height.
                 * @member {number|Long} height
                 * @memberof koinos.broadcast.event_parcel
                 * @instance
                 */
                event_parcel.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * event_parcel transaction_id.
                 * @member {Uint8Array|null|undefined} transaction_id
                 * @memberof koinos.broadcast.event_parcel
                 * @instance
                 */
                event_parcel.prototype.transaction_id = null;
    
                /**
                 * event_parcel event.
                 * @member {koinos.protocol.Ievent_data|null|undefined} event
                 * @memberof koinos.broadcast.event_parcel
                 * @instance
                 */
                event_parcel.prototype.event = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * event_parcel _transaction_id.
                 * @member {"transaction_id"|undefined} _transaction_id
                 * @memberof koinos.broadcast.event_parcel
                 * @instance
                 */
                Object.defineProperty(event_parcel.prototype, "_transaction_id", {
                    get: $util.oneOfGetter($oneOfFields = ["transaction_id"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new event_parcel instance using the specified properties.
                 * @function create
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {koinos.broadcast.Ievent_parcel=} [properties] Properties to set
                 * @returns {koinos.broadcast.event_parcel} event_parcel instance
                 */
                event_parcel.create = function create(properties) {
                    return new event_parcel(properties);
                };
    
                /**
                 * Encodes the specified event_parcel message. Does not implicitly {@link koinos.broadcast.event_parcel.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {koinos.broadcast.Ievent_parcel} message event_parcel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_parcel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block_id != null && Object.hasOwnProperty.call(message, "block_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.block_id);
                    if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.height);
                    if (message.transaction_id != null && Object.hasOwnProperty.call(message, "transaction_id"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.transaction_id);
                    if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                        $root.koinos.protocol.event_data.encode(message.event, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified event_parcel message, length delimited. Does not implicitly {@link koinos.broadcast.event_parcel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {koinos.broadcast.Ievent_parcel} message event_parcel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_parcel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an event_parcel message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.broadcast.event_parcel} event_parcel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_parcel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.broadcast.event_parcel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block_id = reader.bytes();
                            break;
                        case 2:
                            message.height = reader.uint64();
                            break;
                        case 3:
                            message.transaction_id = reader.bytes();
                            break;
                        case 4:
                            message.event = $root.koinos.protocol.event_data.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an event_parcel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.broadcast.event_parcel} event_parcel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_parcel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an event_parcel message.
                 * @function verify
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                event_parcel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.block_id != null && message.hasOwnProperty("block_id"))
                        if (!(message.block_id && typeof message.block_id.length === "number" || $util.isString(message.block_id)))
                            return "block_id: buffer expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    if (message.transaction_id != null && message.hasOwnProperty("transaction_id")) {
                        properties._transaction_id = 1;
                        if (!(message.transaction_id && typeof message.transaction_id.length === "number" || $util.isString(message.transaction_id)))
                            return "transaction_id: buffer expected";
                    }
                    if (message.event != null && message.hasOwnProperty("event")) {
                        var error = $root.koinos.protocol.event_data.verify(message.event);
                        if (error)
                            return "event." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an event_parcel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.broadcast.event_parcel} event_parcel
                 */
                event_parcel.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.broadcast.event_parcel)
                        return object;
                    var message = new $root.koinos.broadcast.event_parcel();
                    if (object.block_id != null)
                        if (typeof object.block_id === "string")
                            $util.base64.decode(object.block_id, message.block_id = $util.newBuffer($util.base64.length(object.block_id)), 0);
                        else if (object.block_id.length)
                            message.block_id = object.block_id;
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                    if (object.transaction_id != null)
                        if (typeof object.transaction_id === "string")
                            $util.base64.decode(object.transaction_id, message.transaction_id = $util.newBuffer($util.base64.length(object.transaction_id)), 0);
                        else if (object.transaction_id.length)
                            message.transaction_id = object.transaction_id;
                    if (object.event != null) {
                        if (typeof object.event !== "object")
                            throw TypeError(".koinos.broadcast.event_parcel.event: object expected");
                        message.event = $root.koinos.protocol.event_data.fromObject(object.event);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an event_parcel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.broadcast.event_parcel
                 * @static
                 * @param {koinos.broadcast.event_parcel} message event_parcel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                event_parcel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.block_id = "";
                        else {
                            object.block_id = [];
                            if (options.bytes !== Array)
                                object.block_id = $util.newBuffer(object.block_id);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                        object.event = null;
                    }
                    if (message.block_id != null && message.hasOwnProperty("block_id"))
                        object.block_id = options.bytes === String ? $util.base64.encode(message.block_id, 0, message.block_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.block_id) : message.block_id;
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                    if (message.transaction_id != null && message.hasOwnProperty("transaction_id")) {
                        object.transaction_id = options.bytes === String ? $util.base64.encode(message.transaction_id, 0, message.transaction_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.transaction_id) : message.transaction_id;
                        if (options.oneofs)
                            object._transaction_id = "transaction_id";
                    }
                    if (message.event != null && message.hasOwnProperty("event"))
                        object.event = $root.koinos.protocol.event_data.toObject(message.event, options);
                    return object;
                };
    
                /**
                 * Converts this event_parcel to JSON.
                 * @function toJSON
                 * @memberof koinos.broadcast.event_parcel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                event_parcel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return event_parcel;
            })();
    
            return broadcast;
        })();
    
        koinos.chain = (function() {
    
            /**
             * Namespace chain.
             * @memberof koinos
             * @namespace
             */
            var chain = {};
    
            chain.set_system_call_event = (function() {
    
                /**
                 * Properties of a set_system_call_event.
                 * @memberof koinos.chain
                 * @interface Iset_system_call_event
                 * @property {number|null} [call_id] set_system_call_event call_id
                 * @property {koinos.protocol.Isystem_call_target|null} [target] set_system_call_event target
                 */
    
                /**
                 * Constructs a new set_system_call_event.
                 * @memberof koinos.chain
                 * @classdesc Represents a set_system_call_event.
                 * @implements Iset_system_call_event
                 * @constructor
                 * @param {koinos.chain.Iset_system_call_event=} [properties] Properties to set
                 */
                function set_system_call_event(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * set_system_call_event call_id.
                 * @member {number} call_id
                 * @memberof koinos.chain.set_system_call_event
                 * @instance
                 */
                set_system_call_event.prototype.call_id = 0;
    
                /**
                 * set_system_call_event target.
                 * @member {koinos.protocol.Isystem_call_target|null|undefined} target
                 * @memberof koinos.chain.set_system_call_event
                 * @instance
                 */
                set_system_call_event.prototype.target = null;
    
                /**
                 * Creates a new set_system_call_event instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {koinos.chain.Iset_system_call_event=} [properties] Properties to set
                 * @returns {koinos.chain.set_system_call_event} set_system_call_event instance
                 */
                set_system_call_event.create = function create(properties) {
                    return new set_system_call_event(properties);
                };
    
                /**
                 * Encodes the specified set_system_call_event message. Does not implicitly {@link koinos.chain.set_system_call_event.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {koinos.chain.Iset_system_call_event} message set_system_call_event message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_call_event.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.call_id != null && Object.hasOwnProperty.call(message, "call_id"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.call_id);
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.koinos.protocol.system_call_target.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified set_system_call_event message, length delimited. Does not implicitly {@link koinos.chain.set_system_call_event.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {koinos.chain.Iset_system_call_event} message set_system_call_event message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_call_event.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a set_system_call_event message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.set_system_call_event} set_system_call_event
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_call_event.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.set_system_call_event();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.call_id = reader.uint32();
                            break;
                        case 2:
                            message.target = $root.koinos.protocol.system_call_target.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a set_system_call_event message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.set_system_call_event} set_system_call_event
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_call_event.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a set_system_call_event message.
                 * @function verify
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                set_system_call_event.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.call_id != null && message.hasOwnProperty("call_id"))
                        if (!$util.isInteger(message.call_id))
                            return "call_id: integer expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        var error = $root.koinos.protocol.system_call_target.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a set_system_call_event message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.set_system_call_event} set_system_call_event
                 */
                set_system_call_event.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.set_system_call_event)
                        return object;
                    var message = new $root.koinos.chain.set_system_call_event();
                    if (object.call_id != null)
                        message.call_id = object.call_id >>> 0;
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".koinos.chain.set_system_call_event.target: object expected");
                        message.target = $root.koinos.protocol.system_call_target.fromObject(object.target);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a set_system_call_event message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.set_system_call_event
                 * @static
                 * @param {koinos.chain.set_system_call_event} message set_system_call_event
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                set_system_call_event.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.call_id = 0;
                        object.target = null;
                    }
                    if (message.call_id != null && message.hasOwnProperty("call_id"))
                        object.call_id = message.call_id;
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.koinos.protocol.system_call_target.toObject(message.target, options);
                    return object;
                };
    
                /**
                 * Converts this set_system_call_event to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.set_system_call_event
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                set_system_call_event.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return set_system_call_event;
            })();
    
            chain.set_system_contract_event = (function() {
    
                /**
                 * Properties of a set_system_contract_event.
                 * @memberof koinos.chain
                 * @interface Iset_system_contract_event
                 * @property {Uint8Array|null} [contract_id] set_system_contract_event contract_id
                 * @property {boolean|null} [system_contract] set_system_contract_event system_contract
                 */
    
                /**
                 * Constructs a new set_system_contract_event.
                 * @memberof koinos.chain
                 * @classdesc Represents a set_system_contract_event.
                 * @implements Iset_system_contract_event
                 * @constructor
                 * @param {koinos.chain.Iset_system_contract_event=} [properties] Properties to set
                 */
                function set_system_contract_event(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * set_system_contract_event contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.chain.set_system_contract_event
                 * @instance
                 */
                set_system_contract_event.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * set_system_contract_event system_contract.
                 * @member {boolean} system_contract
                 * @memberof koinos.chain.set_system_contract_event
                 * @instance
                 */
                set_system_contract_event.prototype.system_contract = false;
    
                /**
                 * Creates a new set_system_contract_event instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {koinos.chain.Iset_system_contract_event=} [properties] Properties to set
                 * @returns {koinos.chain.set_system_contract_event} set_system_contract_event instance
                 */
                set_system_contract_event.create = function create(properties) {
                    return new set_system_contract_event(properties);
                };
    
                /**
                 * Encodes the specified set_system_contract_event message. Does not implicitly {@link koinos.chain.set_system_contract_event.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {koinos.chain.Iset_system_contract_event} message set_system_contract_event message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_contract_event.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.system_contract != null && Object.hasOwnProperty.call(message, "system_contract"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.system_contract);
                    return writer;
                };
    
                /**
                 * Encodes the specified set_system_contract_event message, length delimited. Does not implicitly {@link koinos.chain.set_system_contract_event.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {koinos.chain.Iset_system_contract_event} message set_system_contract_event message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_system_contract_event.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a set_system_contract_event message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.set_system_contract_event} set_system_contract_event
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_contract_event.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.set_system_contract_event();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.system_contract = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a set_system_contract_event message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.set_system_contract_event} set_system_contract_event
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_system_contract_event.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a set_system_contract_event message.
                 * @function verify
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                set_system_contract_event.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.system_contract != null && message.hasOwnProperty("system_contract"))
                        if (typeof message.system_contract !== "boolean")
                            return "system_contract: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a set_system_contract_event message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.set_system_contract_event} set_system_contract_event
                 */
                set_system_contract_event.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.set_system_contract_event)
                        return object;
                    var message = new $root.koinos.chain.set_system_contract_event();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.system_contract != null)
                        message.system_contract = Boolean(object.system_contract);
                    return message;
                };
    
                /**
                 * Creates a plain object from a set_system_contract_event message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.set_system_contract_event
                 * @static
                 * @param {koinos.chain.set_system_contract_event} message set_system_contract_event
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                set_system_contract_event.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        object.system_contract = false;
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.system_contract != null && message.hasOwnProperty("system_contract"))
                        object.system_contract = message.system_contract;
                    return object;
                };
    
                /**
                 * Converts this set_system_contract_event to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.set_system_contract_event
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                set_system_contract_event.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return set_system_contract_event;
            })();
    
            chain.error_data = (function() {
    
                /**
                 * Properties of an error_data.
                 * @memberof koinos.chain
                 * @interface Ierror_data
                 * @property {string|null} [message] error_data message
                 */
    
                /**
                 * Constructs a new error_data.
                 * @memberof koinos.chain
                 * @classdesc Represents an error_data.
                 * @implements Ierror_data
                 * @constructor
                 * @param {koinos.chain.Ierror_data=} [properties] Properties to set
                 */
                function error_data(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * error_data message.
                 * @member {string} message
                 * @memberof koinos.chain.error_data
                 * @instance
                 */
                error_data.prototype.message = "";
    
                /**
                 * Creates a new error_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {koinos.chain.Ierror_data=} [properties] Properties to set
                 * @returns {koinos.chain.error_data} error_data instance
                 */
                error_data.create = function create(properties) {
                    return new error_data(properties);
                };
    
                /**
                 * Encodes the specified error_data message. Does not implicitly {@link koinos.chain.error_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {koinos.chain.Ierror_data} message error_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                error_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                    return writer;
                };
    
                /**
                 * Encodes the specified error_data message, length delimited. Does not implicitly {@link koinos.chain.error_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {koinos.chain.Ierror_data} message error_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                error_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an error_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.error_data} error_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                error_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.error_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an error_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.error_data} error_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                error_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an error_data message.
                 * @function verify
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                error_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };
    
                /**
                 * Creates an error_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.error_data} error_data
                 */
                error_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.error_data)
                        return object;
                    var message = new $root.koinos.chain.error_data();
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };
    
                /**
                 * Creates a plain object from an error_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.error_data
                 * @static
                 * @param {koinos.chain.error_data} message error_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                error_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.message = "";
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };
    
                /**
                 * Converts this error_data to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.error_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                error_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return error_data;
            })();
    
            chain.result = (function() {
    
                /**
                 * Properties of a result.
                 * @memberof koinos.chain
                 * @interface Iresult
                 * @property {Uint8Array|null} [object] result object
                 * @property {koinos.chain.Ierror_data|null} [error] result error
                 */
    
                /**
                 * Constructs a new result.
                 * @memberof koinos.chain
                 * @classdesc Represents a result.
                 * @implements Iresult
                 * @constructor
                 * @param {koinos.chain.Iresult=} [properties] Properties to set
                 */
                function result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * result object.
                 * @member {Uint8Array|null|undefined} object
                 * @memberof koinos.chain.result
                 * @instance
                 */
                result.prototype.object = null;
    
                /**
                 * result error.
                 * @member {koinos.chain.Ierror_data|null|undefined} error
                 * @memberof koinos.chain.result
                 * @instance
                 */
                result.prototype.error = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * result value.
                 * @member {"object"|"error"|undefined} value
                 * @memberof koinos.chain.result
                 * @instance
                 */
                Object.defineProperty(result.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["object", "error"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.result
                 * @static
                 * @param {koinos.chain.Iresult=} [properties] Properties to set
                 * @returns {koinos.chain.result} result instance
                 */
                result.create = function create(properties) {
                    return new result(properties);
                };
    
                /**
                 * Encodes the specified result message. Does not implicitly {@link koinos.chain.result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.result
                 * @static
                 * @param {koinos.chain.Iresult} message result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.object != null && Object.hasOwnProperty.call(message, "object"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.object);
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.koinos.chain.error_data.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified result message, length delimited. Does not implicitly {@link koinos.chain.result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.result
                 * @static
                 * @param {koinos.chain.Iresult} message result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.result} result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.object = reader.bytes();
                            break;
                        case 2:
                            message.error = $root.koinos.chain.error_data.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.result} result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a result message.
                 * @function verify
                 * @memberof koinos.chain.result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.object != null && message.hasOwnProperty("object")) {
                        properties.value = 1;
                        if (!(message.object && typeof message.object.length === "number" || $util.isString(message.object)))
                            return "object: buffer expected";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        if (properties.value === 1)
                            return "value: multiple values";
                        properties.value = 1;
                        {
                            var error = $root.koinos.chain.error_data.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.result} result
                 */
                result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.result)
                        return object;
                    var message = new $root.koinos.chain.result();
                    if (object.object != null)
                        if (typeof object.object === "string")
                            $util.base64.decode(object.object, message.object = $util.newBuffer($util.base64.length(object.object)), 0);
                        else if (object.object.length)
                            message.object = object.object;
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".koinos.chain.result.error: object expected");
                        message.error = $root.koinos.chain.error_data.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.result
                 * @static
                 * @param {koinos.chain.result} message result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.object != null && message.hasOwnProperty("object")) {
                        object.object = options.bytes === String ? $util.base64.encode(message.object, 0, message.object.length) : options.bytes === Array ? Array.prototype.slice.call(message.object) : message.object;
                        if (options.oneofs)
                            object.value = "object";
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        object.error = $root.koinos.chain.error_data.toObject(message.error, options);
                        if (options.oneofs)
                            object.value = "error";
                    }
                    return object;
                };
    
                /**
                 * Converts this result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return result;
            })();
    
            chain.object_space = (function() {
    
                /**
                 * Properties of an object_space.
                 * @memberof koinos.chain
                 * @interface Iobject_space
                 * @property {boolean|null} [system] object_space system
                 * @property {Uint8Array|null} [zone] object_space zone
                 * @property {number|null} [id] object_space id
                 */
    
                /**
                 * Constructs a new object_space.
                 * @memberof koinos.chain
                 * @classdesc Represents an object_space.
                 * @implements Iobject_space
                 * @constructor
                 * @param {koinos.chain.Iobject_space=} [properties] Properties to set
                 */
                function object_space(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * object_space system.
                 * @member {boolean} system
                 * @memberof koinos.chain.object_space
                 * @instance
                 */
                object_space.prototype.system = false;
    
                /**
                 * object_space zone.
                 * @member {Uint8Array} zone
                 * @memberof koinos.chain.object_space
                 * @instance
                 */
                object_space.prototype.zone = $util.newBuffer([]);
    
                /**
                 * object_space id.
                 * @member {number} id
                 * @memberof koinos.chain.object_space
                 * @instance
                 */
                object_space.prototype.id = 0;
    
                /**
                 * Creates a new object_space instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {koinos.chain.Iobject_space=} [properties] Properties to set
                 * @returns {koinos.chain.object_space} object_space instance
                 */
                object_space.create = function create(properties) {
                    return new object_space(properties);
                };
    
                /**
                 * Encodes the specified object_space message. Does not implicitly {@link koinos.chain.object_space.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {koinos.chain.Iobject_space} message object_space message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                object_space.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.system != null && Object.hasOwnProperty.call(message, "system"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.system);
                    if (message.zone != null && Object.hasOwnProperty.call(message, "zone"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.zone);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.id);
                    return writer;
                };
    
                /**
                 * Encodes the specified object_space message, length delimited. Does not implicitly {@link koinos.chain.object_space.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {koinos.chain.Iobject_space} message object_space message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                object_space.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an object_space message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.object_space} object_space
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                object_space.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.object_space();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.system = reader.bool();
                            break;
                        case 2:
                            message.zone = reader.bytes();
                            break;
                        case 3:
                            message.id = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an object_space message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.object_space} object_space
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                object_space.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an object_space message.
                 * @function verify
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                object_space.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.system != null && message.hasOwnProperty("system"))
                        if (typeof message.system !== "boolean")
                            return "system: boolean expected";
                    if (message.zone != null && message.hasOwnProperty("zone"))
                        if (!(message.zone && typeof message.zone.length === "number" || $util.isString(message.zone)))
                            return "zone: buffer expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isInteger(message.id))
                            return "id: integer expected";
                    return null;
                };
    
                /**
                 * Creates an object_space message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.object_space} object_space
                 */
                object_space.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.object_space)
                        return object;
                    var message = new $root.koinos.chain.object_space();
                    if (object.system != null)
                        message.system = Boolean(object.system);
                    if (object.zone != null)
                        if (typeof object.zone === "string")
                            $util.base64.decode(object.zone, message.zone = $util.newBuffer($util.base64.length(object.zone)), 0);
                        else if (object.zone.length)
                            message.zone = object.zone;
                    if (object.id != null)
                        message.id = object.id >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from an object_space message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.object_space
                 * @static
                 * @param {koinos.chain.object_space} message object_space
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                object_space.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.system = false;
                        if (options.bytes === String)
                            object.zone = "";
                        else {
                            object.zone = [];
                            if (options.bytes !== Array)
                                object.zone = $util.newBuffer(object.zone);
                        }
                        object.id = 0;
                    }
                    if (message.system != null && message.hasOwnProperty("system"))
                        object.system = message.system;
                    if (message.zone != null && message.hasOwnProperty("zone"))
                        object.zone = options.bytes === String ? $util.base64.encode(message.zone, 0, message.zone.length) : options.bytes === Array ? Array.prototype.slice.call(message.zone) : message.zone;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };
    
                /**
                 * Converts this object_space to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.object_space
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                object_space.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return object_space;
            })();
    
            chain.database_key = (function() {
    
                /**
                 * Properties of a database_key.
                 * @memberof koinos.chain
                 * @interface Idatabase_key
                 * @property {koinos.chain.Iobject_space|null} [space] database_key space
                 * @property {Uint8Array|null} [key] database_key key
                 */
    
                /**
                 * Constructs a new database_key.
                 * @memberof koinos.chain
                 * @classdesc Represents a database_key.
                 * @implements Idatabase_key
                 * @constructor
                 * @param {koinos.chain.Idatabase_key=} [properties] Properties to set
                 */
                function database_key(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * database_key space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.database_key
                 * @instance
                 */
                database_key.prototype.space = null;
    
                /**
                 * database_key key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.database_key
                 * @instance
                 */
                database_key.prototype.key = $util.newBuffer([]);
    
                /**
                 * Creates a new database_key instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {koinos.chain.Idatabase_key=} [properties] Properties to set
                 * @returns {koinos.chain.database_key} database_key instance
                 */
                database_key.create = function create(properties) {
                    return new database_key(properties);
                };
    
                /**
                 * Encodes the specified database_key message. Does not implicitly {@link koinos.chain.database_key.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {koinos.chain.Idatabase_key} message database_key message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                database_key.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified database_key message, length delimited. Does not implicitly {@link koinos.chain.database_key.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {koinos.chain.Idatabase_key} message database_key message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                database_key.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a database_key message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.database_key} database_key
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                database_key.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.database_key();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a database_key message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.database_key} database_key
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                database_key.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a database_key message.
                 * @function verify
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                database_key.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a database_key message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.database_key} database_key
                 */
                database_key.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.database_key)
                        return object;
                    var message = new $root.koinos.chain.database_key();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.database_key.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };
    
                /**
                 * Creates a plain object from a database_key message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.database_key
                 * @static
                 * @param {koinos.chain.database_key} message database_key
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                database_key.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };
    
                /**
                 * Converts this database_key to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.database_key
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                database_key.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return database_key;
            })();
    
            chain.max_account_resources = (function() {
    
                /**
                 * Properties of a max_account_resources.
                 * @memberof koinos.chain
                 * @interface Imax_account_resources
                 * @property {number|Long|null} [value] max_account_resources value
                 */
    
                /**
                 * Constructs a new max_account_resources.
                 * @memberof koinos.chain
                 * @classdesc Represents a max_account_resources.
                 * @implements Imax_account_resources
                 * @constructor
                 * @param {koinos.chain.Imax_account_resources=} [properties] Properties to set
                 */
                function max_account_resources(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * max_account_resources value.
                 * @member {number|Long} value
                 * @memberof koinos.chain.max_account_resources
                 * @instance
                 */
                max_account_resources.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new max_account_resources instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {koinos.chain.Imax_account_resources=} [properties] Properties to set
                 * @returns {koinos.chain.max_account_resources} max_account_resources instance
                 */
                max_account_resources.create = function create(properties) {
                    return new max_account_resources(properties);
                };
    
                /**
                 * Encodes the specified max_account_resources message. Does not implicitly {@link koinos.chain.max_account_resources.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {koinos.chain.Imax_account_resources} message max_account_resources message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                max_account_resources.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified max_account_resources message, length delimited. Does not implicitly {@link koinos.chain.max_account_resources.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {koinos.chain.Imax_account_resources} message max_account_resources message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                max_account_resources.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a max_account_resources message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.max_account_resources} max_account_resources
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                max_account_resources.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.max_account_resources();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a max_account_resources message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.max_account_resources} max_account_resources
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                max_account_resources.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a max_account_resources message.
                 * @function verify
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                max_account_resources.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                            return "value: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a max_account_resources message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.max_account_resources} max_account_resources
                 */
                max_account_resources.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.max_account_resources)
                        return object;
                    var message = new $root.koinos.chain.max_account_resources();
                    if (object.value != null)
                        if ($util.Long)
                            (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                        else if (typeof object.value === "string")
                            message.value = parseInt(object.value, 10);
                        else if (typeof object.value === "number")
                            message.value = object.value;
                        else if (typeof object.value === "object")
                            message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a max_account_resources message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.max_account_resources
                 * @static
                 * @param {koinos.chain.max_account_resources} message max_account_resources
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                max_account_resources.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.value = options.longs === String ? "0" : 0;
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value === "number")
                            object.value = options.longs === String ? String(message.value) : message.value;
                        else
                            object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                    return object;
                };
    
                /**
                 * Converts this max_account_resources to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.max_account_resources
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                max_account_resources.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return max_account_resources;
            })();
    
            /**
             * privilege enum.
             * @name koinos.chain.privilege
             * @enum {number}
             * @property {number} kernel_mode=0 kernel_mode value
             * @property {number} user_mode=1 user_mode value
             */
            chain.privilege = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "kernel_mode"] = 0;
                values[valuesById[1] = "user_mode"] = 1;
                return values;
            })();
    
            chain.head_info = (function() {
    
                /**
                 * Properties of a head_info.
                 * @memberof koinos.chain
                 * @interface Ihead_info
                 * @property {koinos.Iblock_topology|null} [head_topology] head_info head_topology
                 * @property {number|Long|null} [head_block_time] head_info head_block_time
                 * @property {number|Long|null} [last_irreversible_block] head_info last_irreversible_block
                 */
    
                /**
                 * Constructs a new head_info.
                 * @memberof koinos.chain
                 * @classdesc Represents a head_info.
                 * @implements Ihead_info
                 * @constructor
                 * @param {koinos.chain.Ihead_info=} [properties] Properties to set
                 */
                function head_info(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * head_info head_topology.
                 * @member {koinos.Iblock_topology|null|undefined} head_topology
                 * @memberof koinos.chain.head_info
                 * @instance
                 */
                head_info.prototype.head_topology = null;
    
                /**
                 * head_info head_block_time.
                 * @member {number|Long} head_block_time
                 * @memberof koinos.chain.head_info
                 * @instance
                 */
                head_info.prototype.head_block_time = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * head_info last_irreversible_block.
                 * @member {number|Long} last_irreversible_block
                 * @memberof koinos.chain.head_info
                 * @instance
                 */
                head_info.prototype.last_irreversible_block = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new head_info instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {koinos.chain.Ihead_info=} [properties] Properties to set
                 * @returns {koinos.chain.head_info} head_info instance
                 */
                head_info.create = function create(properties) {
                    return new head_info(properties);
                };
    
                /**
                 * Encodes the specified head_info message. Does not implicitly {@link koinos.chain.head_info.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {koinos.chain.Ihead_info} message head_info message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                head_info.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.head_topology != null && Object.hasOwnProperty.call(message, "head_topology"))
                        $root.koinos.block_topology.encode(message.head_topology, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.head_block_time != null && Object.hasOwnProperty.call(message, "head_block_time"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.head_block_time);
                    if (message.last_irreversible_block != null && Object.hasOwnProperty.call(message, "last_irreversible_block"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.last_irreversible_block);
                    return writer;
                };
    
                /**
                 * Encodes the specified head_info message, length delimited. Does not implicitly {@link koinos.chain.head_info.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {koinos.chain.Ihead_info} message head_info message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                head_info.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a head_info message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.head_info} head_info
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                head_info.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.head_info();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.head_topology = $root.koinos.block_topology.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.head_block_time = reader.uint64();
                            break;
                        case 3:
                            message.last_irreversible_block = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a head_info message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.head_info} head_info
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                head_info.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a head_info message.
                 * @function verify
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                head_info.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.head_topology != null && message.hasOwnProperty("head_topology")) {
                        var error = $root.koinos.block_topology.verify(message.head_topology);
                        if (error)
                            return "head_topology." + error;
                    }
                    if (message.head_block_time != null && message.hasOwnProperty("head_block_time"))
                        if (!$util.isInteger(message.head_block_time) && !(message.head_block_time && $util.isInteger(message.head_block_time.low) && $util.isInteger(message.head_block_time.high)))
                            return "head_block_time: integer|Long expected";
                    if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block"))
                        if (!$util.isInteger(message.last_irreversible_block) && !(message.last_irreversible_block && $util.isInteger(message.last_irreversible_block.low) && $util.isInteger(message.last_irreversible_block.high)))
                            return "last_irreversible_block: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a head_info message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.head_info} head_info
                 */
                head_info.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.head_info)
                        return object;
                    var message = new $root.koinos.chain.head_info();
                    if (object.head_topology != null) {
                        if (typeof object.head_topology !== "object")
                            throw TypeError(".koinos.chain.head_info.head_topology: object expected");
                        message.head_topology = $root.koinos.block_topology.fromObject(object.head_topology);
                    }
                    if (object.head_block_time != null)
                        if ($util.Long)
                            (message.head_block_time = $util.Long.fromValue(object.head_block_time)).unsigned = true;
                        else if (typeof object.head_block_time === "string")
                            message.head_block_time = parseInt(object.head_block_time, 10);
                        else if (typeof object.head_block_time === "number")
                            message.head_block_time = object.head_block_time;
                        else if (typeof object.head_block_time === "object")
                            message.head_block_time = new $util.LongBits(object.head_block_time.low >>> 0, object.head_block_time.high >>> 0).toNumber(true);
                    if (object.last_irreversible_block != null)
                        if ($util.Long)
                            (message.last_irreversible_block = $util.Long.fromValue(object.last_irreversible_block)).unsigned = true;
                        else if (typeof object.last_irreversible_block === "string")
                            message.last_irreversible_block = parseInt(object.last_irreversible_block, 10);
                        else if (typeof object.last_irreversible_block === "number")
                            message.last_irreversible_block = object.last_irreversible_block;
                        else if (typeof object.last_irreversible_block === "object")
                            message.last_irreversible_block = new $util.LongBits(object.last_irreversible_block.low >>> 0, object.last_irreversible_block.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a head_info message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.head_info
                 * @static
                 * @param {koinos.chain.head_info} message head_info
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                head_info.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.head_topology = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.head_block_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.head_block_time = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.last_irreversible_block = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.last_irreversible_block = options.longs === String ? "0" : 0;
                    }
                    if (message.head_topology != null && message.hasOwnProperty("head_topology"))
                        object.head_topology = $root.koinos.block_topology.toObject(message.head_topology, options);
                    if (message.head_block_time != null && message.hasOwnProperty("head_block_time"))
                        if (typeof message.head_block_time === "number")
                            object.head_block_time = options.longs === String ? String(message.head_block_time) : message.head_block_time;
                        else
                            object.head_block_time = options.longs === String ? $util.Long.prototype.toString.call(message.head_block_time) : options.longs === Number ? new $util.LongBits(message.head_block_time.low >>> 0, message.head_block_time.high >>> 0).toNumber(true) : message.head_block_time;
                    if (message.last_irreversible_block != null && message.hasOwnProperty("last_irreversible_block"))
                        if (typeof message.last_irreversible_block === "number")
                            object.last_irreversible_block = options.longs === String ? String(message.last_irreversible_block) : message.last_irreversible_block;
                        else
                            object.last_irreversible_block = options.longs === String ? $util.Long.prototype.toString.call(message.last_irreversible_block) : options.longs === Number ? new $util.LongBits(message.last_irreversible_block.low >>> 0, message.last_irreversible_block.high >>> 0).toNumber(true) : message.last_irreversible_block;
                    return object;
                };
    
                /**
                 * Converts this head_info to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.head_info
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                head_info.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return head_info;
            })();
    
            chain.caller_data = (function() {
    
                /**
                 * Properties of a caller_data.
                 * @memberof koinos.chain
                 * @interface Icaller_data
                 * @property {Uint8Array|null} [caller] caller_data caller
                 * @property {koinos.chain.privilege|null} [caller_privilege] caller_data caller_privilege
                 */
    
                /**
                 * Constructs a new caller_data.
                 * @memberof koinos.chain
                 * @classdesc Represents a caller_data.
                 * @implements Icaller_data
                 * @constructor
                 * @param {koinos.chain.Icaller_data=} [properties] Properties to set
                 */
                function caller_data(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * caller_data caller.
                 * @member {Uint8Array} caller
                 * @memberof koinos.chain.caller_data
                 * @instance
                 */
                caller_data.prototype.caller = $util.newBuffer([]);
    
                /**
                 * caller_data caller_privilege.
                 * @member {koinos.chain.privilege} caller_privilege
                 * @memberof koinos.chain.caller_data
                 * @instance
                 */
                caller_data.prototype.caller_privilege = 0;
    
                /**
                 * Creates a new caller_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {koinos.chain.Icaller_data=} [properties] Properties to set
                 * @returns {koinos.chain.caller_data} caller_data instance
                 */
                caller_data.create = function create(properties) {
                    return new caller_data(properties);
                };
    
                /**
                 * Encodes the specified caller_data message. Does not implicitly {@link koinos.chain.caller_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {koinos.chain.Icaller_data} message caller_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                caller_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.caller != null && Object.hasOwnProperty.call(message, "caller"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.caller);
                    if (message.caller_privilege != null && Object.hasOwnProperty.call(message, "caller_privilege"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.caller_privilege);
                    return writer;
                };
    
                /**
                 * Encodes the specified caller_data message, length delimited. Does not implicitly {@link koinos.chain.caller_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {koinos.chain.Icaller_data} message caller_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                caller_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a caller_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.caller_data} caller_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                caller_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.caller_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.caller = reader.bytes();
                            break;
                        case 2:
                            message.caller_privilege = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a caller_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.caller_data} caller_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                caller_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a caller_data message.
                 * @function verify
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                caller_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.caller != null && message.hasOwnProperty("caller"))
                        if (!(message.caller && typeof message.caller.length === "number" || $util.isString(message.caller)))
                            return "caller: buffer expected";
                    if (message.caller_privilege != null && message.hasOwnProperty("caller_privilege"))
                        switch (message.caller_privilege) {
                        default:
                            return "caller_privilege: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a caller_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.caller_data} caller_data
                 */
                caller_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.caller_data)
                        return object;
                    var message = new $root.koinos.chain.caller_data();
                    if (object.caller != null)
                        if (typeof object.caller === "string")
                            $util.base64.decode(object.caller, message.caller = $util.newBuffer($util.base64.length(object.caller)), 0);
                        else if (object.caller.length)
                            message.caller = object.caller;
                    switch (object.caller_privilege) {
                    case "kernel_mode":
                    case 0:
                        message.caller_privilege = 0;
                        break;
                    case "user_mode":
                    case 1:
                        message.caller_privilege = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a caller_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.caller_data
                 * @static
                 * @param {koinos.chain.caller_data} message caller_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                caller_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.caller = "";
                        else {
                            object.caller = [];
                            if (options.bytes !== Array)
                                object.caller = $util.newBuffer(object.caller);
                        }
                        object.caller_privilege = options.enums === String ? "kernel_mode" : 0;
                    }
                    if (message.caller != null && message.hasOwnProperty("caller"))
                        object.caller = options.bytes === String ? $util.base64.encode(message.caller, 0, message.caller.length) : options.bytes === Array ? Array.prototype.slice.call(message.caller) : message.caller;
                    if (message.caller_privilege != null && message.hasOwnProperty("caller_privilege"))
                        object.caller_privilege = options.enums === String ? $root.koinos.chain.privilege[message.caller_privilege] : message.caller_privilege;
                    return object;
                };
    
                /**
                 * Converts this caller_data to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.caller_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                caller_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return caller_data;
            })();
    
            chain.argument_data = (function() {
    
                /**
                 * Properties of an argument_data.
                 * @memberof koinos.chain
                 * @interface Iargument_data
                 * @property {number|null} [entry_point] argument_data entry_point
                 * @property {Uint8Array|null} ["arguments"] argument_data arguments
                 */
    
                /**
                 * Constructs a new argument_data.
                 * @memberof koinos.chain
                 * @classdesc Represents an argument_data.
                 * @implements Iargument_data
                 * @constructor
                 * @param {koinos.chain.Iargument_data=} [properties] Properties to set
                 */
                function argument_data(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * argument_data entry_point.
                 * @member {number} entry_point
                 * @memberof koinos.chain.argument_data
                 * @instance
                 */
                argument_data.prototype.entry_point = 0;
    
                /**
                 * argument_data arguments.
                 * @member {Uint8Array} arguments
                 * @memberof koinos.chain.argument_data
                 * @instance
                 */
                argument_data.prototype["arguments"] = $util.newBuffer([]);
    
                /**
                 * Creates a new argument_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {koinos.chain.Iargument_data=} [properties] Properties to set
                 * @returns {koinos.chain.argument_data} argument_data instance
                 */
                argument_data.create = function create(properties) {
                    return new argument_data(properties);
                };
    
                /**
                 * Encodes the specified argument_data message. Does not implicitly {@link koinos.chain.argument_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {koinos.chain.Iargument_data} message argument_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                argument_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entry_point != null && Object.hasOwnProperty.call(message, "entry_point"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.entry_point);
                    if (message["arguments"] != null && Object.hasOwnProperty.call(message, "arguments"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message["arguments"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified argument_data message, length delimited. Does not implicitly {@link koinos.chain.argument_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {koinos.chain.Iargument_data} message argument_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                argument_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an argument_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.argument_data} argument_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                argument_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.argument_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.entry_point = reader.uint32();
                            break;
                        case 2:
                            message["arguments"] = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an argument_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.argument_data} argument_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                argument_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an argument_data message.
                 * @function verify
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                argument_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        if (!$util.isInteger(message.entry_point))
                            return "entry_point: integer expected";
                    if (message["arguments"] != null && message.hasOwnProperty("arguments"))
                        if (!(message["arguments"] && typeof message["arguments"].length === "number" || $util.isString(message["arguments"])))
                            return "arguments: buffer expected";
                    return null;
                };
    
                /**
                 * Creates an argument_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.argument_data} argument_data
                 */
                argument_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.argument_data)
                        return object;
                    var message = new $root.koinos.chain.argument_data();
                    if (object.entry_point != null)
                        message.entry_point = object.entry_point >>> 0;
                    if (object["arguments"] != null)
                        if (typeof object["arguments"] === "string")
                            $util.base64.decode(object["arguments"], message["arguments"] = $util.newBuffer($util.base64.length(object["arguments"])), 0);
                        else if (object["arguments"].length)
                            message["arguments"] = object["arguments"];
                    return message;
                };
    
                /**
                 * Creates a plain object from an argument_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.argument_data
                 * @static
                 * @param {koinos.chain.argument_data} message argument_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                argument_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.entry_point = 0;
                        if (options.bytes === String)
                            object["arguments"] = "";
                        else {
                            object["arguments"] = [];
                            if (options.bytes !== Array)
                                object["arguments"] = $util.newBuffer(object["arguments"]);
                        }
                    }
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        object.entry_point = message.entry_point;
                    if (message["arguments"] != null && message.hasOwnProperty("arguments"))
                        object["arguments"] = options.bytes === String ? $util.base64.encode(message["arguments"], 0, message["arguments"].length) : options.bytes === Array ? Array.prototype.slice.call(message["arguments"]) : message["arguments"];
                    return object;
                };
    
                /**
                 * Converts this argument_data to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.argument_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                argument_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return argument_data;
            })();
    
            chain.resource_limit_data = (function() {
    
                /**
                 * Properties of a resource_limit_data.
                 * @memberof koinos.chain
                 * @interface Iresource_limit_data
                 * @property {number|Long|null} [disk_storage_limit] resource_limit_data disk_storage_limit
                 * @property {number|Long|null} [disk_storage_cost] resource_limit_data disk_storage_cost
                 * @property {number|Long|null} [network_bandwidth_limit] resource_limit_data network_bandwidth_limit
                 * @property {number|Long|null} [network_bandwidth_cost] resource_limit_data network_bandwidth_cost
                 * @property {number|Long|null} [compute_bandwidth_limit] resource_limit_data compute_bandwidth_limit
                 * @property {number|Long|null} [compute_bandwidth_cost] resource_limit_data compute_bandwidth_cost
                 */
    
                /**
                 * Constructs a new resource_limit_data.
                 * @memberof koinos.chain
                 * @classdesc Represents a resource_limit_data.
                 * @implements Iresource_limit_data
                 * @constructor
                 * @param {koinos.chain.Iresource_limit_data=} [properties] Properties to set
                 */
                function resource_limit_data(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * resource_limit_data disk_storage_limit.
                 * @member {number|Long} disk_storage_limit
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 */
                resource_limit_data.prototype.disk_storage_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * resource_limit_data disk_storage_cost.
                 * @member {number|Long} disk_storage_cost
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 */
                resource_limit_data.prototype.disk_storage_cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * resource_limit_data network_bandwidth_limit.
                 * @member {number|Long} network_bandwidth_limit
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 */
                resource_limit_data.prototype.network_bandwidth_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * resource_limit_data network_bandwidth_cost.
                 * @member {number|Long} network_bandwidth_cost
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 */
                resource_limit_data.prototype.network_bandwidth_cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * resource_limit_data compute_bandwidth_limit.
                 * @member {number|Long} compute_bandwidth_limit
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 */
                resource_limit_data.prototype.compute_bandwidth_limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * resource_limit_data compute_bandwidth_cost.
                 * @member {number|Long} compute_bandwidth_cost
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 */
                resource_limit_data.prototype.compute_bandwidth_cost = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new resource_limit_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {koinos.chain.Iresource_limit_data=} [properties] Properties to set
                 * @returns {koinos.chain.resource_limit_data} resource_limit_data instance
                 */
                resource_limit_data.create = function create(properties) {
                    return new resource_limit_data(properties);
                };
    
                /**
                 * Encodes the specified resource_limit_data message. Does not implicitly {@link koinos.chain.resource_limit_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {koinos.chain.Iresource_limit_data} message resource_limit_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                resource_limit_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.disk_storage_limit != null && Object.hasOwnProperty.call(message, "disk_storage_limit"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.disk_storage_limit);
                    if (message.disk_storage_cost != null && Object.hasOwnProperty.call(message, "disk_storage_cost"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.disk_storage_cost);
                    if (message.network_bandwidth_limit != null && Object.hasOwnProperty.call(message, "network_bandwidth_limit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.network_bandwidth_limit);
                    if (message.network_bandwidth_cost != null && Object.hasOwnProperty.call(message, "network_bandwidth_cost"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.network_bandwidth_cost);
                    if (message.compute_bandwidth_limit != null && Object.hasOwnProperty.call(message, "compute_bandwidth_limit"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.compute_bandwidth_limit);
                    if (message.compute_bandwidth_cost != null && Object.hasOwnProperty.call(message, "compute_bandwidth_cost"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.compute_bandwidth_cost);
                    return writer;
                };
    
                /**
                 * Encodes the specified resource_limit_data message, length delimited. Does not implicitly {@link koinos.chain.resource_limit_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {koinos.chain.Iresource_limit_data} message resource_limit_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                resource_limit_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a resource_limit_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.resource_limit_data} resource_limit_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                resource_limit_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.resource_limit_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.disk_storage_limit = reader.uint64();
                            break;
                        case 2:
                            message.disk_storage_cost = reader.uint64();
                            break;
                        case 3:
                            message.network_bandwidth_limit = reader.uint64();
                            break;
                        case 4:
                            message.network_bandwidth_cost = reader.uint64();
                            break;
                        case 5:
                            message.compute_bandwidth_limit = reader.uint64();
                            break;
                        case 6:
                            message.compute_bandwidth_cost = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a resource_limit_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.resource_limit_data} resource_limit_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                resource_limit_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a resource_limit_data message.
                 * @function verify
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                resource_limit_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.disk_storage_limit != null && message.hasOwnProperty("disk_storage_limit"))
                        if (!$util.isInteger(message.disk_storage_limit) && !(message.disk_storage_limit && $util.isInteger(message.disk_storage_limit.low) && $util.isInteger(message.disk_storage_limit.high)))
                            return "disk_storage_limit: integer|Long expected";
                    if (message.disk_storage_cost != null && message.hasOwnProperty("disk_storage_cost"))
                        if (!$util.isInteger(message.disk_storage_cost) && !(message.disk_storage_cost && $util.isInteger(message.disk_storage_cost.low) && $util.isInteger(message.disk_storage_cost.high)))
                            return "disk_storage_cost: integer|Long expected";
                    if (message.network_bandwidth_limit != null && message.hasOwnProperty("network_bandwidth_limit"))
                        if (!$util.isInteger(message.network_bandwidth_limit) && !(message.network_bandwidth_limit && $util.isInteger(message.network_bandwidth_limit.low) && $util.isInteger(message.network_bandwidth_limit.high)))
                            return "network_bandwidth_limit: integer|Long expected";
                    if (message.network_bandwidth_cost != null && message.hasOwnProperty("network_bandwidth_cost"))
                        if (!$util.isInteger(message.network_bandwidth_cost) && !(message.network_bandwidth_cost && $util.isInteger(message.network_bandwidth_cost.low) && $util.isInteger(message.network_bandwidth_cost.high)))
                            return "network_bandwidth_cost: integer|Long expected";
                    if (message.compute_bandwidth_limit != null && message.hasOwnProperty("compute_bandwidth_limit"))
                        if (!$util.isInteger(message.compute_bandwidth_limit) && !(message.compute_bandwidth_limit && $util.isInteger(message.compute_bandwidth_limit.low) && $util.isInteger(message.compute_bandwidth_limit.high)))
                            return "compute_bandwidth_limit: integer|Long expected";
                    if (message.compute_bandwidth_cost != null && message.hasOwnProperty("compute_bandwidth_cost"))
                        if (!$util.isInteger(message.compute_bandwidth_cost) && !(message.compute_bandwidth_cost && $util.isInteger(message.compute_bandwidth_cost.low) && $util.isInteger(message.compute_bandwidth_cost.high)))
                            return "compute_bandwidth_cost: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a resource_limit_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.resource_limit_data} resource_limit_data
                 */
                resource_limit_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.resource_limit_data)
                        return object;
                    var message = new $root.koinos.chain.resource_limit_data();
                    if (object.disk_storage_limit != null)
                        if ($util.Long)
                            (message.disk_storage_limit = $util.Long.fromValue(object.disk_storage_limit)).unsigned = true;
                        else if (typeof object.disk_storage_limit === "string")
                            message.disk_storage_limit = parseInt(object.disk_storage_limit, 10);
                        else if (typeof object.disk_storage_limit === "number")
                            message.disk_storage_limit = object.disk_storage_limit;
                        else if (typeof object.disk_storage_limit === "object")
                            message.disk_storage_limit = new $util.LongBits(object.disk_storage_limit.low >>> 0, object.disk_storage_limit.high >>> 0).toNumber(true);
                    if (object.disk_storage_cost != null)
                        if ($util.Long)
                            (message.disk_storage_cost = $util.Long.fromValue(object.disk_storage_cost)).unsigned = true;
                        else if (typeof object.disk_storage_cost === "string")
                            message.disk_storage_cost = parseInt(object.disk_storage_cost, 10);
                        else if (typeof object.disk_storage_cost === "number")
                            message.disk_storage_cost = object.disk_storage_cost;
                        else if (typeof object.disk_storage_cost === "object")
                            message.disk_storage_cost = new $util.LongBits(object.disk_storage_cost.low >>> 0, object.disk_storage_cost.high >>> 0).toNumber(true);
                    if (object.network_bandwidth_limit != null)
                        if ($util.Long)
                            (message.network_bandwidth_limit = $util.Long.fromValue(object.network_bandwidth_limit)).unsigned = true;
                        else if (typeof object.network_bandwidth_limit === "string")
                            message.network_bandwidth_limit = parseInt(object.network_bandwidth_limit, 10);
                        else if (typeof object.network_bandwidth_limit === "number")
                            message.network_bandwidth_limit = object.network_bandwidth_limit;
                        else if (typeof object.network_bandwidth_limit === "object")
                            message.network_bandwidth_limit = new $util.LongBits(object.network_bandwidth_limit.low >>> 0, object.network_bandwidth_limit.high >>> 0).toNumber(true);
                    if (object.network_bandwidth_cost != null)
                        if ($util.Long)
                            (message.network_bandwidth_cost = $util.Long.fromValue(object.network_bandwidth_cost)).unsigned = true;
                        else if (typeof object.network_bandwidth_cost === "string")
                            message.network_bandwidth_cost = parseInt(object.network_bandwidth_cost, 10);
                        else if (typeof object.network_bandwidth_cost === "number")
                            message.network_bandwidth_cost = object.network_bandwidth_cost;
                        else if (typeof object.network_bandwidth_cost === "object")
                            message.network_bandwidth_cost = new $util.LongBits(object.network_bandwidth_cost.low >>> 0, object.network_bandwidth_cost.high >>> 0).toNumber(true);
                    if (object.compute_bandwidth_limit != null)
                        if ($util.Long)
                            (message.compute_bandwidth_limit = $util.Long.fromValue(object.compute_bandwidth_limit)).unsigned = true;
                        else if (typeof object.compute_bandwidth_limit === "string")
                            message.compute_bandwidth_limit = parseInt(object.compute_bandwidth_limit, 10);
                        else if (typeof object.compute_bandwidth_limit === "number")
                            message.compute_bandwidth_limit = object.compute_bandwidth_limit;
                        else if (typeof object.compute_bandwidth_limit === "object")
                            message.compute_bandwidth_limit = new $util.LongBits(object.compute_bandwidth_limit.low >>> 0, object.compute_bandwidth_limit.high >>> 0).toNumber(true);
                    if (object.compute_bandwidth_cost != null)
                        if ($util.Long)
                            (message.compute_bandwidth_cost = $util.Long.fromValue(object.compute_bandwidth_cost)).unsigned = true;
                        else if (typeof object.compute_bandwidth_cost === "string")
                            message.compute_bandwidth_cost = parseInt(object.compute_bandwidth_cost, 10);
                        else if (typeof object.compute_bandwidth_cost === "number")
                            message.compute_bandwidth_cost = object.compute_bandwidth_cost;
                        else if (typeof object.compute_bandwidth_cost === "object")
                            message.compute_bandwidth_cost = new $util.LongBits(object.compute_bandwidth_cost.low >>> 0, object.compute_bandwidth_cost.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a resource_limit_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.resource_limit_data
                 * @static
                 * @param {koinos.chain.resource_limit_data} message resource_limit_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                resource_limit_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.disk_storage_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.disk_storage_limit = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.disk_storage_cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.disk_storage_cost = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.network_bandwidth_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.network_bandwidth_limit = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.network_bandwidth_cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.network_bandwidth_cost = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.compute_bandwidth_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.compute_bandwidth_limit = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.compute_bandwidth_cost = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.compute_bandwidth_cost = options.longs === String ? "0" : 0;
                    }
                    if (message.disk_storage_limit != null && message.hasOwnProperty("disk_storage_limit"))
                        if (typeof message.disk_storage_limit === "number")
                            object.disk_storage_limit = options.longs === String ? String(message.disk_storage_limit) : message.disk_storage_limit;
                        else
                            object.disk_storage_limit = options.longs === String ? $util.Long.prototype.toString.call(message.disk_storage_limit) : options.longs === Number ? new $util.LongBits(message.disk_storage_limit.low >>> 0, message.disk_storage_limit.high >>> 0).toNumber(true) : message.disk_storage_limit;
                    if (message.disk_storage_cost != null && message.hasOwnProperty("disk_storage_cost"))
                        if (typeof message.disk_storage_cost === "number")
                            object.disk_storage_cost = options.longs === String ? String(message.disk_storage_cost) : message.disk_storage_cost;
                        else
                            object.disk_storage_cost = options.longs === String ? $util.Long.prototype.toString.call(message.disk_storage_cost) : options.longs === Number ? new $util.LongBits(message.disk_storage_cost.low >>> 0, message.disk_storage_cost.high >>> 0).toNumber(true) : message.disk_storage_cost;
                    if (message.network_bandwidth_limit != null && message.hasOwnProperty("network_bandwidth_limit"))
                        if (typeof message.network_bandwidth_limit === "number")
                            object.network_bandwidth_limit = options.longs === String ? String(message.network_bandwidth_limit) : message.network_bandwidth_limit;
                        else
                            object.network_bandwidth_limit = options.longs === String ? $util.Long.prototype.toString.call(message.network_bandwidth_limit) : options.longs === Number ? new $util.LongBits(message.network_bandwidth_limit.low >>> 0, message.network_bandwidth_limit.high >>> 0).toNumber(true) : message.network_bandwidth_limit;
                    if (message.network_bandwidth_cost != null && message.hasOwnProperty("network_bandwidth_cost"))
                        if (typeof message.network_bandwidth_cost === "number")
                            object.network_bandwidth_cost = options.longs === String ? String(message.network_bandwidth_cost) : message.network_bandwidth_cost;
                        else
                            object.network_bandwidth_cost = options.longs === String ? $util.Long.prototype.toString.call(message.network_bandwidth_cost) : options.longs === Number ? new $util.LongBits(message.network_bandwidth_cost.low >>> 0, message.network_bandwidth_cost.high >>> 0).toNumber(true) : message.network_bandwidth_cost;
                    if (message.compute_bandwidth_limit != null && message.hasOwnProperty("compute_bandwidth_limit"))
                        if (typeof message.compute_bandwidth_limit === "number")
                            object.compute_bandwidth_limit = options.longs === String ? String(message.compute_bandwidth_limit) : message.compute_bandwidth_limit;
                        else
                            object.compute_bandwidth_limit = options.longs === String ? $util.Long.prototype.toString.call(message.compute_bandwidth_limit) : options.longs === Number ? new $util.LongBits(message.compute_bandwidth_limit.low >>> 0, message.compute_bandwidth_limit.high >>> 0).toNumber(true) : message.compute_bandwidth_limit;
                    if (message.compute_bandwidth_cost != null && message.hasOwnProperty("compute_bandwidth_cost"))
                        if (typeof message.compute_bandwidth_cost === "number")
                            object.compute_bandwidth_cost = options.longs === String ? String(message.compute_bandwidth_cost) : message.compute_bandwidth_cost;
                        else
                            object.compute_bandwidth_cost = options.longs === String ? $util.Long.prototype.toString.call(message.compute_bandwidth_cost) : options.longs === Number ? new $util.LongBits(message.compute_bandwidth_cost.low >>> 0, message.compute_bandwidth_cost.high >>> 0).toNumber(true) : message.compute_bandwidth_cost;
                    return object;
                };
    
                /**
                 * Converts this resource_limit_data to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.resource_limit_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                resource_limit_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return resource_limit_data;
            })();
    
            chain.contract_metadata_object = (function() {
    
                /**
                 * Properties of a contract_metadata_object.
                 * @memberof koinos.chain
                 * @interface Icontract_metadata_object
                 * @property {Uint8Array|null} [hash] contract_metadata_object hash
                 * @property {boolean|null} [system] contract_metadata_object system
                 * @property {boolean|null} [authorizes_call_contract] contract_metadata_object authorizes_call_contract
                 * @property {boolean|null} [authorizes_transaction_application] contract_metadata_object authorizes_transaction_application
                 * @property {boolean|null} [authorizes_upload_contract] contract_metadata_object authorizes_upload_contract
                 */
    
                /**
                 * Constructs a new contract_metadata_object.
                 * @memberof koinos.chain
                 * @classdesc Represents a contract_metadata_object.
                 * @implements Icontract_metadata_object
                 * @constructor
                 * @param {koinos.chain.Icontract_metadata_object=} [properties] Properties to set
                 */
                function contract_metadata_object(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * contract_metadata_object hash.
                 * @member {Uint8Array} hash
                 * @memberof koinos.chain.contract_metadata_object
                 * @instance
                 */
                contract_metadata_object.prototype.hash = $util.newBuffer([]);
    
                /**
                 * contract_metadata_object system.
                 * @member {boolean} system
                 * @memberof koinos.chain.contract_metadata_object
                 * @instance
                 */
                contract_metadata_object.prototype.system = false;
    
                /**
                 * contract_metadata_object authorizes_call_contract.
                 * @member {boolean} authorizes_call_contract
                 * @memberof koinos.chain.contract_metadata_object
                 * @instance
                 */
                contract_metadata_object.prototype.authorizes_call_contract = false;
    
                /**
                 * contract_metadata_object authorizes_transaction_application.
                 * @member {boolean} authorizes_transaction_application
                 * @memberof koinos.chain.contract_metadata_object
                 * @instance
                 */
                contract_metadata_object.prototype.authorizes_transaction_application = false;
    
                /**
                 * contract_metadata_object authorizes_upload_contract.
                 * @member {boolean} authorizes_upload_contract
                 * @memberof koinos.chain.contract_metadata_object
                 * @instance
                 */
                contract_metadata_object.prototype.authorizes_upload_contract = false;
    
                /**
                 * Creates a new contract_metadata_object instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {koinos.chain.Icontract_metadata_object=} [properties] Properties to set
                 * @returns {koinos.chain.contract_metadata_object} contract_metadata_object instance
                 */
                contract_metadata_object.create = function create(properties) {
                    return new contract_metadata_object(properties);
                };
    
                /**
                 * Encodes the specified contract_metadata_object message. Does not implicitly {@link koinos.chain.contract_metadata_object.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {koinos.chain.Icontract_metadata_object} message contract_metadata_object message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                contract_metadata_object.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                    if (message.system != null && Object.hasOwnProperty.call(message, "system"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.system);
                    if (message.authorizes_call_contract != null && Object.hasOwnProperty.call(message, "authorizes_call_contract"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.authorizes_call_contract);
                    if (message.authorizes_transaction_application != null && Object.hasOwnProperty.call(message, "authorizes_transaction_application"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.authorizes_transaction_application);
                    if (message.authorizes_upload_contract != null && Object.hasOwnProperty.call(message, "authorizes_upload_contract"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.authorizes_upload_contract);
                    return writer;
                };
    
                /**
                 * Encodes the specified contract_metadata_object message, length delimited. Does not implicitly {@link koinos.chain.contract_metadata_object.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {koinos.chain.Icontract_metadata_object} message contract_metadata_object message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                contract_metadata_object.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a contract_metadata_object message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.contract_metadata_object} contract_metadata_object
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                contract_metadata_object.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.contract_metadata_object();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.hash = reader.bytes();
                            break;
                        case 2:
                            message.system = reader.bool();
                            break;
                        case 3:
                            message.authorizes_call_contract = reader.bool();
                            break;
                        case 4:
                            message.authorizes_transaction_application = reader.bool();
                            break;
                        case 5:
                            message.authorizes_upload_contract = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a contract_metadata_object message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.contract_metadata_object} contract_metadata_object
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                contract_metadata_object.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a contract_metadata_object message.
                 * @function verify
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                contract_metadata_object.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                            return "hash: buffer expected";
                    if (message.system != null && message.hasOwnProperty("system"))
                        if (typeof message.system !== "boolean")
                            return "system: boolean expected";
                    if (message.authorizes_call_contract != null && message.hasOwnProperty("authorizes_call_contract"))
                        if (typeof message.authorizes_call_contract !== "boolean")
                            return "authorizes_call_contract: boolean expected";
                    if (message.authorizes_transaction_application != null && message.hasOwnProperty("authorizes_transaction_application"))
                        if (typeof message.authorizes_transaction_application !== "boolean")
                            return "authorizes_transaction_application: boolean expected";
                    if (message.authorizes_upload_contract != null && message.hasOwnProperty("authorizes_upload_contract"))
                        if (typeof message.authorizes_upload_contract !== "boolean")
                            return "authorizes_upload_contract: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a contract_metadata_object message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.contract_metadata_object} contract_metadata_object
                 */
                contract_metadata_object.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.contract_metadata_object)
                        return object;
                    var message = new $root.koinos.chain.contract_metadata_object();
                    if (object.hash != null)
                        if (typeof object.hash === "string")
                            $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                        else if (object.hash.length)
                            message.hash = object.hash;
                    if (object.system != null)
                        message.system = Boolean(object.system);
                    if (object.authorizes_call_contract != null)
                        message.authorizes_call_contract = Boolean(object.authorizes_call_contract);
                    if (object.authorizes_transaction_application != null)
                        message.authorizes_transaction_application = Boolean(object.authorizes_transaction_application);
                    if (object.authorizes_upload_contract != null)
                        message.authorizes_upload_contract = Boolean(object.authorizes_upload_contract);
                    return message;
                };
    
                /**
                 * Creates a plain object from a contract_metadata_object message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.contract_metadata_object
                 * @static
                 * @param {koinos.chain.contract_metadata_object} message contract_metadata_object
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                contract_metadata_object.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.hash = "";
                        else {
                            object.hash = [];
                            if (options.bytes !== Array)
                                object.hash = $util.newBuffer(object.hash);
                        }
                        object.system = false;
                        object.authorizes_call_contract = false;
                        object.authorizes_transaction_application = false;
                        object.authorizes_upload_contract = false;
                    }
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                    if (message.system != null && message.hasOwnProperty("system"))
                        object.system = message.system;
                    if (message.authorizes_call_contract != null && message.hasOwnProperty("authorizes_call_contract"))
                        object.authorizes_call_contract = message.authorizes_call_contract;
                    if (message.authorizes_transaction_application != null && message.hasOwnProperty("authorizes_transaction_application"))
                        object.authorizes_transaction_application = message.authorizes_transaction_application;
                    if (message.authorizes_upload_contract != null && message.hasOwnProperty("authorizes_upload_contract"))
                        object.authorizes_upload_contract = message.authorizes_upload_contract;
                    return object;
                };
    
                /**
                 * Converts this contract_metadata_object to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.contract_metadata_object
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                contract_metadata_object.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return contract_metadata_object;
            })();
    
            chain.compute_bandwidth_entry = (function() {
    
                /**
                 * Properties of a compute_bandwidth_entry.
                 * @memberof koinos.chain
                 * @interface Icompute_bandwidth_entry
                 * @property {string|null} [name] compute_bandwidth_entry name
                 * @property {number|Long|null} [compute] compute_bandwidth_entry compute
                 */
    
                /**
                 * Constructs a new compute_bandwidth_entry.
                 * @memberof koinos.chain
                 * @classdesc Represents a compute_bandwidth_entry.
                 * @implements Icompute_bandwidth_entry
                 * @constructor
                 * @param {koinos.chain.Icompute_bandwidth_entry=} [properties] Properties to set
                 */
                function compute_bandwidth_entry(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * compute_bandwidth_entry name.
                 * @member {string} name
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @instance
                 */
                compute_bandwidth_entry.prototype.name = "";
    
                /**
                 * compute_bandwidth_entry compute.
                 * @member {number|Long} compute
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @instance
                 */
                compute_bandwidth_entry.prototype.compute = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new compute_bandwidth_entry instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {koinos.chain.Icompute_bandwidth_entry=} [properties] Properties to set
                 * @returns {koinos.chain.compute_bandwidth_entry} compute_bandwidth_entry instance
                 */
                compute_bandwidth_entry.create = function create(properties) {
                    return new compute_bandwidth_entry(properties);
                };
    
                /**
                 * Encodes the specified compute_bandwidth_entry message. Does not implicitly {@link koinos.chain.compute_bandwidth_entry.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {koinos.chain.Icompute_bandwidth_entry} message compute_bandwidth_entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                compute_bandwidth_entry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.compute != null && Object.hasOwnProperty.call(message, "compute"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.compute);
                    return writer;
                };
    
                /**
                 * Encodes the specified compute_bandwidth_entry message, length delimited. Does not implicitly {@link koinos.chain.compute_bandwidth_entry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {koinos.chain.Icompute_bandwidth_entry} message compute_bandwidth_entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                compute_bandwidth_entry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a compute_bandwidth_entry message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.compute_bandwidth_entry} compute_bandwidth_entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                compute_bandwidth_entry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.compute_bandwidth_entry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.compute = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a compute_bandwidth_entry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.compute_bandwidth_entry} compute_bandwidth_entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                compute_bandwidth_entry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a compute_bandwidth_entry message.
                 * @function verify
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                compute_bandwidth_entry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.compute != null && message.hasOwnProperty("compute"))
                        if (!$util.isInteger(message.compute) && !(message.compute && $util.isInteger(message.compute.low) && $util.isInteger(message.compute.high)))
                            return "compute: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a compute_bandwidth_entry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.compute_bandwidth_entry} compute_bandwidth_entry
                 */
                compute_bandwidth_entry.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.compute_bandwidth_entry)
                        return object;
                    var message = new $root.koinos.chain.compute_bandwidth_entry();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.compute != null)
                        if ($util.Long)
                            (message.compute = $util.Long.fromValue(object.compute)).unsigned = true;
                        else if (typeof object.compute === "string")
                            message.compute = parseInt(object.compute, 10);
                        else if (typeof object.compute === "number")
                            message.compute = object.compute;
                        else if (typeof object.compute === "object")
                            message.compute = new $util.LongBits(object.compute.low >>> 0, object.compute.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a compute_bandwidth_entry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @static
                 * @param {koinos.chain.compute_bandwidth_entry} message compute_bandwidth_entry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                compute_bandwidth_entry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.compute = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.compute = options.longs === String ? "0" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.compute != null && message.hasOwnProperty("compute"))
                        if (typeof message.compute === "number")
                            object.compute = options.longs === String ? String(message.compute) : message.compute;
                        else
                            object.compute = options.longs === String ? $util.Long.prototype.toString.call(message.compute) : options.longs === Number ? new $util.LongBits(message.compute.low >>> 0, message.compute.high >>> 0).toNumber(true) : message.compute;
                    return object;
                };
    
                /**
                 * Converts this compute_bandwidth_entry to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.compute_bandwidth_entry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                compute_bandwidth_entry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return compute_bandwidth_entry;
            })();
    
            chain.compute_bandwidth_registry = (function() {
    
                /**
                 * Properties of a compute_bandwidth_registry.
                 * @memberof koinos.chain
                 * @interface Icompute_bandwidth_registry
                 * @property {Array.<koinos.chain.Icompute_bandwidth_entry>|null} [entries] compute_bandwidth_registry entries
                 */
    
                /**
                 * Constructs a new compute_bandwidth_registry.
                 * @memberof koinos.chain
                 * @classdesc Represents a compute_bandwidth_registry.
                 * @implements Icompute_bandwidth_registry
                 * @constructor
                 * @param {koinos.chain.Icompute_bandwidth_registry=} [properties] Properties to set
                 */
                function compute_bandwidth_registry(properties) {
                    this.entries = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * compute_bandwidth_registry entries.
                 * @member {Array.<koinos.chain.Icompute_bandwidth_entry>} entries
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @instance
                 */
                compute_bandwidth_registry.prototype.entries = $util.emptyArray;
    
                /**
                 * Creates a new compute_bandwidth_registry instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {koinos.chain.Icompute_bandwidth_registry=} [properties] Properties to set
                 * @returns {koinos.chain.compute_bandwidth_registry} compute_bandwidth_registry instance
                 */
                compute_bandwidth_registry.create = function create(properties) {
                    return new compute_bandwidth_registry(properties);
                };
    
                /**
                 * Encodes the specified compute_bandwidth_registry message. Does not implicitly {@link koinos.chain.compute_bandwidth_registry.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {koinos.chain.Icompute_bandwidth_registry} message compute_bandwidth_registry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                compute_bandwidth_registry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entries != null && message.entries.length)
                        for (var i = 0; i < message.entries.length; ++i)
                            $root.koinos.chain.compute_bandwidth_entry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified compute_bandwidth_registry message, length delimited. Does not implicitly {@link koinos.chain.compute_bandwidth_registry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {koinos.chain.Icompute_bandwidth_registry} message compute_bandwidth_registry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                compute_bandwidth_registry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a compute_bandwidth_registry message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.compute_bandwidth_registry} compute_bandwidth_registry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                compute_bandwidth_registry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.compute_bandwidth_registry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.koinos.chain.compute_bandwidth_entry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a compute_bandwidth_registry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.compute_bandwidth_registry} compute_bandwidth_registry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                compute_bandwidth_registry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a compute_bandwidth_registry message.
                 * @function verify
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                compute_bandwidth_registry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (var i = 0; i < message.entries.length; ++i) {
                            var error = $root.koinos.chain.compute_bandwidth_entry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a compute_bandwidth_registry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.compute_bandwidth_registry} compute_bandwidth_registry
                 */
                compute_bandwidth_registry.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.compute_bandwidth_registry)
                        return object;
                    var message = new $root.koinos.chain.compute_bandwidth_registry();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".koinos.chain.compute_bandwidth_registry.entries: array expected");
                        message.entries = [];
                        for (var i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".koinos.chain.compute_bandwidth_registry.entries: object expected");
                            message.entries[i] = $root.koinos.chain.compute_bandwidth_entry.fromObject(object.entries[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a compute_bandwidth_registry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @static
                 * @param {koinos.chain.compute_bandwidth_registry} message compute_bandwidth_registry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                compute_bandwidth_registry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (var j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.koinos.chain.compute_bandwidth_entry.toObject(message.entries[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this compute_bandwidth_registry to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.compute_bandwidth_registry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                compute_bandwidth_registry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return compute_bandwidth_registry;
            })();
    
            chain.genesis_entry = (function() {
    
                /**
                 * Properties of a genesis_entry.
                 * @memberof koinos.chain
                 * @interface Igenesis_entry
                 * @property {koinos.chain.Iobject_space|null} [space] genesis_entry space
                 * @property {Uint8Array|null} [key] genesis_entry key
                 * @property {Uint8Array|null} [value] genesis_entry value
                 */
    
                /**
                 * Constructs a new genesis_entry.
                 * @memberof koinos.chain
                 * @classdesc Represents a genesis_entry.
                 * @implements Igenesis_entry
                 * @constructor
                 * @param {koinos.chain.Igenesis_entry=} [properties] Properties to set
                 */
                function genesis_entry(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * genesis_entry space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.genesis_entry
                 * @instance
                 */
                genesis_entry.prototype.space = null;
    
                /**
                 * genesis_entry key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.genesis_entry
                 * @instance
                 */
                genesis_entry.prototype.key = $util.newBuffer([]);
    
                /**
                 * genesis_entry value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.genesis_entry
                 * @instance
                 */
                genesis_entry.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new genesis_entry instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {koinos.chain.Igenesis_entry=} [properties] Properties to set
                 * @returns {koinos.chain.genesis_entry} genesis_entry instance
                 */
                genesis_entry.create = function create(properties) {
                    return new genesis_entry(properties);
                };
    
                /**
                 * Encodes the specified genesis_entry message. Does not implicitly {@link koinos.chain.genesis_entry.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {koinos.chain.Igenesis_entry} message genesis_entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                genesis_entry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified genesis_entry message, length delimited. Does not implicitly {@link koinos.chain.genesis_entry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {koinos.chain.Igenesis_entry} message genesis_entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                genesis_entry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a genesis_entry message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.genesis_entry} genesis_entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                genesis_entry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.genesis_entry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        case 3:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a genesis_entry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.genesis_entry} genesis_entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                genesis_entry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a genesis_entry message.
                 * @function verify
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                genesis_entry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a genesis_entry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.genesis_entry} genesis_entry
                 */
                genesis_entry.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.genesis_entry)
                        return object;
                    var message = new $root.koinos.chain.genesis_entry();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.genesis_entry.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a genesis_entry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.genesis_entry
                 * @static
                 * @param {koinos.chain.genesis_entry} message genesis_entry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                genesis_entry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this genesis_entry to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.genesis_entry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                genesis_entry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return genesis_entry;
            })();
    
            chain.genesis_data = (function() {
    
                /**
                 * Properties of a genesis_data.
                 * @memberof koinos.chain
                 * @interface Igenesis_data
                 * @property {Array.<koinos.chain.Igenesis_entry>|null} [entries] genesis_data entries
                 */
    
                /**
                 * Constructs a new genesis_data.
                 * @memberof koinos.chain
                 * @classdesc Represents a genesis_data.
                 * @implements Igenesis_data
                 * @constructor
                 * @param {koinos.chain.Igenesis_data=} [properties] Properties to set
                 */
                function genesis_data(properties) {
                    this.entries = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * genesis_data entries.
                 * @member {Array.<koinos.chain.Igenesis_entry>} entries
                 * @memberof koinos.chain.genesis_data
                 * @instance
                 */
                genesis_data.prototype.entries = $util.emptyArray;
    
                /**
                 * Creates a new genesis_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {koinos.chain.Igenesis_data=} [properties] Properties to set
                 * @returns {koinos.chain.genesis_data} genesis_data instance
                 */
                genesis_data.create = function create(properties) {
                    return new genesis_data(properties);
                };
    
                /**
                 * Encodes the specified genesis_data message. Does not implicitly {@link koinos.chain.genesis_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {koinos.chain.Igenesis_data} message genesis_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                genesis_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entries != null && message.entries.length)
                        for (var i = 0; i < message.entries.length; ++i)
                            $root.koinos.chain.genesis_entry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified genesis_data message, length delimited. Does not implicitly {@link koinos.chain.genesis_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {koinos.chain.Igenesis_data} message genesis_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                genesis_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a genesis_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.genesis_data} genesis_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                genesis_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.genesis_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entries && message.entries.length))
                                message.entries = [];
                            message.entries.push($root.koinos.chain.genesis_entry.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a genesis_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.genesis_data} genesis_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                genesis_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a genesis_data message.
                 * @function verify
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                genesis_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (var i = 0; i < message.entries.length; ++i) {
                            var error = $root.koinos.chain.genesis_entry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a genesis_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.genesis_data} genesis_data
                 */
                genesis_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.genesis_data)
                        return object;
                    var message = new $root.koinos.chain.genesis_data();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".koinos.chain.genesis_data.entries: array expected");
                        message.entries = [];
                        for (var i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".koinos.chain.genesis_data.entries: object expected");
                            message.entries[i] = $root.koinos.chain.genesis_entry.fromObject(object.entries[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a genesis_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.genesis_data
                 * @static
                 * @param {koinos.chain.genesis_data} message genesis_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                genesis_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (var j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.koinos.chain.genesis_entry.toObject(message.entries[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this genesis_data to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.genesis_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                genesis_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return genesis_data;
            })();
    
            /**
             * dsa enum.
             * @name koinos.chain.dsa
             * @enum {number}
             * @property {number} ecdsa_secp256k1=0 ecdsa_secp256k1 value
             */
            chain.dsa = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ecdsa_secp256k1"] = 0;
                return values;
            })();
    
            /**
             * system_call_id enum.
             * @name koinos.chain.system_call_id
             * @enum {number}
             * @property {number} nop=0 nop value
             * @property {number} get_head_info=1 get_head_info value
             * @property {number} apply_block=2 apply_block value
             * @property {number} apply_transaction=3 apply_transaction value
             * @property {number} apply_upload_contract_operation=4 apply_upload_contract_operation value
             * @property {number} apply_call_contract_operation=5 apply_call_contract_operation value
             * @property {number} apply_set_system_call_operation=6 apply_set_system_call_operation value
             * @property {number} apply_set_system_contract_operation=7 apply_set_system_contract_operation value
             * @property {number} pre_block_callback=8 pre_block_callback value
             * @property {number} post_block_callback=9 post_block_callback value
             * @property {number} pre_transaction_callback=10 pre_transaction_callback value
             * @property {number} post_transaction_callback=11 post_transaction_callback value
             * @property {number} get_chain_id=12 get_chain_id value
             * @property {number} process_block_signature=101 process_block_signature value
             * @property {number} get_transaction=102 get_transaction value
             * @property {number} get_transaction_field=103 get_transaction_field value
             * @property {number} get_block=104 get_block value
             * @property {number} get_block_field=105 get_block_field value
             * @property {number} get_last_irreversible_block=106 get_last_irreversible_block value
             * @property {number} get_account_nonce=107 get_account_nonce value
             * @property {number} verify_account_nonce=108 verify_account_nonce value
             * @property {number} set_account_nonce=109 set_account_nonce value
             * @property {number} check_system_authority=110 check_system_authority value
             * @property {number} get_operation=111 get_operation value
             * @property {number} get_account_rc=201 get_account_rc value
             * @property {number} consume_account_rc=202 consume_account_rc value
             * @property {number} get_resource_limits=203 get_resource_limits value
             * @property {number} consume_block_resources=204 consume_block_resources value
             * @property {number} put_object=301 put_object value
             * @property {number} remove_object=302 remove_object value
             * @property {number} get_object=303 get_object value
             * @property {number} get_next_object=304 get_next_object value
             * @property {number} get_prev_object=305 get_prev_object value
             * @property {number} log=401 log value
             * @property {number} event=402 event value
             * @property {number} hash=501 hash value
             * @property {number} recover_public_key=502 recover_public_key value
             * @property {number} verify_merkle_root=503 verify_merkle_root value
             * @property {number} verify_signature=504 verify_signature value
             * @property {number} verify_vrf_proof=505 verify_vrf_proof value
             * @property {number} call=601 call value
             * @property {number} exit=602 exit value
             * @property {number} get_arguments=603 get_arguments value
             * @property {number} get_contract_id=604 get_contract_id value
             * @property {number} get_caller=605 get_caller value
             * @property {number} check_authority=606 check_authority value
             */
            chain.system_call_id = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "nop"] = 0;
                values[valuesById[1] = "get_head_info"] = 1;
                values[valuesById[2] = "apply_block"] = 2;
                values[valuesById[3] = "apply_transaction"] = 3;
                values[valuesById[4] = "apply_upload_contract_operation"] = 4;
                values[valuesById[5] = "apply_call_contract_operation"] = 5;
                values[valuesById[6] = "apply_set_system_call_operation"] = 6;
                values[valuesById[7] = "apply_set_system_contract_operation"] = 7;
                values[valuesById[8] = "pre_block_callback"] = 8;
                values[valuesById[9] = "post_block_callback"] = 9;
                values[valuesById[10] = "pre_transaction_callback"] = 10;
                values[valuesById[11] = "post_transaction_callback"] = 11;
                values[valuesById[12] = "get_chain_id"] = 12;
                values[valuesById[101] = "process_block_signature"] = 101;
                values[valuesById[102] = "get_transaction"] = 102;
                values[valuesById[103] = "get_transaction_field"] = 103;
                values[valuesById[104] = "get_block"] = 104;
                values[valuesById[105] = "get_block_field"] = 105;
                values[valuesById[106] = "get_last_irreversible_block"] = 106;
                values[valuesById[107] = "get_account_nonce"] = 107;
                values[valuesById[108] = "verify_account_nonce"] = 108;
                values[valuesById[109] = "set_account_nonce"] = 109;
                values[valuesById[110] = "check_system_authority"] = 110;
                values[valuesById[111] = "get_operation"] = 111;
                values[valuesById[201] = "get_account_rc"] = 201;
                values[valuesById[202] = "consume_account_rc"] = 202;
                values[valuesById[203] = "get_resource_limits"] = 203;
                values[valuesById[204] = "consume_block_resources"] = 204;
                values[valuesById[301] = "put_object"] = 301;
                values[valuesById[302] = "remove_object"] = 302;
                values[valuesById[303] = "get_object"] = 303;
                values[valuesById[304] = "get_next_object"] = 304;
                values[valuesById[305] = "get_prev_object"] = 305;
                values[valuesById[401] = "log"] = 401;
                values[valuesById[402] = "event"] = 402;
                values[valuesById[501] = "hash"] = 501;
                values[valuesById[502] = "recover_public_key"] = 502;
                values[valuesById[503] = "verify_merkle_root"] = 503;
                values[valuesById[504] = "verify_signature"] = 504;
                values[valuesById[505] = "verify_vrf_proof"] = 505;
                values[valuesById[601] = "call"] = 601;
                values[valuesById[602] = "exit"] = 602;
                values[valuesById[603] = "get_arguments"] = 603;
                values[valuesById[604] = "get_contract_id"] = 604;
                values[valuesById[605] = "get_caller"] = 605;
                values[valuesById[606] = "check_authority"] = 606;
                return values;
            })();
    
            /**
             * error_code enum.
             * @name koinos.chain.error_code
             * @enum {number}
             * @property {number} success=0 success value
             * @property {number} reversion=1 reversion value
             * @property {number} internal_error=100 internal_error value
             * @property {number} system_authorization_failure=101 system_authorization_failure value
             * @property {number} invalid_contract=102 invalid_contract value
             * @property {number} insufficient_privileges=103 insufficient_privileges value
             * @property {number} insufficient_rc=104 insufficient_rc value
             * @property {number} insufficient_return_buffer=105 insufficient_return_buffer value
             * @property {number} unknown_thunk=106 unknown_thunk value
             * @property {number} unknown_operation=107 unknown_operation value
             * @property {number} read_only_context=108 read_only_context value
             * @property {number} failure=-1 failure value
             * @property {number} field_not_found=-100 field_not_found value
             * @property {number} unknown_hash_code=-101 unknown_hash_code value
             * @property {number} unknown_dsa=-102 unknown_dsa value
             * @property {number} unknown_system_call=-103 unknown_system_call value
             * @property {number} operation_not_found=-104 operation_not_found value
             * @property {number} authorization_failure=-200 authorization_failure value
             * @property {number} invalid_nonce=-201 invalid_nonce value
             * @property {number} invalid_signature=-202 invalid_signature value
             * @property {number} malformed_block=-203 malformed_block value
             * @property {number} malformed_transaction=-204 malformed_transaction value
             * @property {number} block_resource_failure=-205 block_resource_failure value
             * @property {number} unknown_backend=-1000 unknown_backend value
             * @property {number} unexpected_state=-1001 unexpected_state value
             * @property {number} missing_required_arguments=-1002 missing_required_arguments value
             * @property {number} unknown_previous_block=-1003 unknown_previous_block value
             * @property {number} unexpected_height=-1004 unexpected_height value
             * @property {number} block_state_error=-1005 block_state_error value
             * @property {number} state_merkle_mismatch=-1006 state_merkle_mismatch value
             * @property {number} unexpected_receipt=-1007 unexpected_receipt value
             * @property {number} rpc_failure=-1008 rpc_failure value
             * @property {number} pending_state_error=-1009 pending_state_error value
             * @property {number} timestamp_out_of_bounds=-1010 timestamp_out_of_bounds value
             * @property {number} indexer_failure=-1011 indexer_failure value
             * @property {number} network_bandwidth_limit_exceeded=-1012 network_bandwidth_limit_exceeded value
             * @property {number} compute_bandwidth_limit_exceeded=-1013 compute_bandwidth_limit_exceeded value
             * @property {number} disk_storage_limit_exceeded=-1014 disk_storage_limit_exceeded value
             */
            chain.error_code = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "success"] = 0;
                values[valuesById[1] = "reversion"] = 1;
                values[valuesById[100] = "internal_error"] = 100;
                values[valuesById[101] = "system_authorization_failure"] = 101;
                values[valuesById[102] = "invalid_contract"] = 102;
                values[valuesById[103] = "insufficient_privileges"] = 103;
                values[valuesById[104] = "insufficient_rc"] = 104;
                values[valuesById[105] = "insufficient_return_buffer"] = 105;
                values[valuesById[106] = "unknown_thunk"] = 106;
                values[valuesById[107] = "unknown_operation"] = 107;
                values[valuesById[108] = "read_only_context"] = 108;
                values[valuesById[-1] = "failure"] = -1;
                values[valuesById[-100] = "field_not_found"] = -100;
                values[valuesById[-101] = "unknown_hash_code"] = -101;
                values[valuesById[-102] = "unknown_dsa"] = -102;
                values[valuesById[-103] = "unknown_system_call"] = -103;
                values[valuesById[-104] = "operation_not_found"] = -104;
                values[valuesById[-200] = "authorization_failure"] = -200;
                values[valuesById[-201] = "invalid_nonce"] = -201;
                values[valuesById[-202] = "invalid_signature"] = -202;
                values[valuesById[-203] = "malformed_block"] = -203;
                values[valuesById[-204] = "malformed_transaction"] = -204;
                values[valuesById[-205] = "block_resource_failure"] = -205;
                values[valuesById[-1000] = "unknown_backend"] = -1000;
                values[valuesById[-1001] = "unexpected_state"] = -1001;
                values[valuesById[-1002] = "missing_required_arguments"] = -1002;
                values[valuesById[-1003] = "unknown_previous_block"] = -1003;
                values[valuesById[-1004] = "unexpected_height"] = -1004;
                values[valuesById[-1005] = "block_state_error"] = -1005;
                values[valuesById[-1006] = "state_merkle_mismatch"] = -1006;
                values[valuesById[-1007] = "unexpected_receipt"] = -1007;
                values[valuesById[-1008] = "rpc_failure"] = -1008;
                values[valuesById[-1009] = "pending_state_error"] = -1009;
                values[valuesById[-1010] = "timestamp_out_of_bounds"] = -1010;
                values[valuesById[-1011] = "indexer_failure"] = -1011;
                values[valuesById[-1012] = "network_bandwidth_limit_exceeded"] = -1012;
                values[valuesById[-1013] = "compute_bandwidth_limit_exceeded"] = -1013;
                values[valuesById[-1014] = "disk_storage_limit_exceeded"] = -1014;
                return values;
            })();
    
            chain.nop_arguments = (function() {
    
                /**
                 * Properties of a nop_arguments.
                 * @memberof koinos.chain
                 * @interface Inop_arguments
                 */
    
                /**
                 * Constructs a new nop_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a nop_arguments.
                 * @implements Inop_arguments
                 * @constructor
                 * @param {koinos.chain.Inop_arguments=} [properties] Properties to set
                 */
                function nop_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new nop_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {koinos.chain.Inop_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.nop_arguments} nop_arguments instance
                 */
                nop_arguments.create = function create(properties) {
                    return new nop_arguments(properties);
                };
    
                /**
                 * Encodes the specified nop_arguments message. Does not implicitly {@link koinos.chain.nop_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {koinos.chain.Inop_arguments} message nop_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                nop_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified nop_arguments message, length delimited. Does not implicitly {@link koinos.chain.nop_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {koinos.chain.Inop_arguments} message nop_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                nop_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a nop_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.nop_arguments} nop_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                nop_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.nop_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a nop_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.nop_arguments} nop_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                nop_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a nop_arguments message.
                 * @function verify
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                nop_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a nop_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.nop_arguments} nop_arguments
                 */
                nop_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.nop_arguments)
                        return object;
                    return new $root.koinos.chain.nop_arguments();
                };
    
                /**
                 * Creates a plain object from a nop_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.nop_arguments
                 * @static
                 * @param {koinos.chain.nop_arguments} message nop_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                nop_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this nop_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.nop_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                nop_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return nop_arguments;
            })();
    
            chain.nop_result = (function() {
    
                /**
                 * Properties of a nop_result.
                 * @memberof koinos.chain
                 * @interface Inop_result
                 */
    
                /**
                 * Constructs a new nop_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a nop_result.
                 * @implements Inop_result
                 * @constructor
                 * @param {koinos.chain.Inop_result=} [properties] Properties to set
                 */
                function nop_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new nop_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {koinos.chain.Inop_result=} [properties] Properties to set
                 * @returns {koinos.chain.nop_result} nop_result instance
                 */
                nop_result.create = function create(properties) {
                    return new nop_result(properties);
                };
    
                /**
                 * Encodes the specified nop_result message. Does not implicitly {@link koinos.chain.nop_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {koinos.chain.Inop_result} message nop_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                nop_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified nop_result message, length delimited. Does not implicitly {@link koinos.chain.nop_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {koinos.chain.Inop_result} message nop_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                nop_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a nop_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.nop_result} nop_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                nop_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.nop_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a nop_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.nop_result} nop_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                nop_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a nop_result message.
                 * @function verify
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                nop_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a nop_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.nop_result} nop_result
                 */
                nop_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.nop_result)
                        return object;
                    return new $root.koinos.chain.nop_result();
                };
    
                /**
                 * Creates a plain object from a nop_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.nop_result
                 * @static
                 * @param {koinos.chain.nop_result} message nop_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                nop_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this nop_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.nop_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                nop_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return nop_result;
            })();
    
            chain.get_head_info_arguments = (function() {
    
                /**
                 * Properties of a get_head_info_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_head_info_arguments
                 */
    
                /**
                 * Constructs a new get_head_info_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_head_info_arguments.
                 * @implements Iget_head_info_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_head_info_arguments=} [properties] Properties to set
                 */
                function get_head_info_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_head_info_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {koinos.chain.Iget_head_info_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_head_info_arguments} get_head_info_arguments instance
                 */
                get_head_info_arguments.create = function create(properties) {
                    return new get_head_info_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_head_info_arguments message. Does not implicitly {@link koinos.chain.get_head_info_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {koinos.chain.Iget_head_info_arguments} message get_head_info_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_head_info_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_head_info_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_head_info_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {koinos.chain.Iget_head_info_arguments} message get_head_info_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_head_info_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_head_info_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_head_info_arguments} get_head_info_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_head_info_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_head_info_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_head_info_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_head_info_arguments} get_head_info_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_head_info_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_head_info_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_head_info_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_head_info_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_head_info_arguments} get_head_info_arguments
                 */
                get_head_info_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_head_info_arguments)
                        return object;
                    return new $root.koinos.chain.get_head_info_arguments();
                };
    
                /**
                 * Creates a plain object from a get_head_info_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_head_info_arguments
                 * @static
                 * @param {koinos.chain.get_head_info_arguments} message get_head_info_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_head_info_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_head_info_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_head_info_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_head_info_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_head_info_arguments;
            })();
    
            chain.get_head_info_result = (function() {
    
                /**
                 * Properties of a get_head_info_result.
                 * @memberof koinos.chain
                 * @interface Iget_head_info_result
                 * @property {koinos.chain.Ihead_info|null} [value] get_head_info_result value
                 */
    
                /**
                 * Constructs a new get_head_info_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_head_info_result.
                 * @implements Iget_head_info_result
                 * @constructor
                 * @param {koinos.chain.Iget_head_info_result=} [properties] Properties to set
                 */
                function get_head_info_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_head_info_result value.
                 * @member {koinos.chain.Ihead_info|null|undefined} value
                 * @memberof koinos.chain.get_head_info_result
                 * @instance
                 */
                get_head_info_result.prototype.value = null;
    
                /**
                 * Creates a new get_head_info_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {koinos.chain.Iget_head_info_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_head_info_result} get_head_info_result instance
                 */
                get_head_info_result.create = function create(properties) {
                    return new get_head_info_result(properties);
                };
    
                /**
                 * Encodes the specified get_head_info_result message. Does not implicitly {@link koinos.chain.get_head_info_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {koinos.chain.Iget_head_info_result} message get_head_info_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_head_info_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.head_info.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_head_info_result message, length delimited. Does not implicitly {@link koinos.chain.get_head_info_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {koinos.chain.Iget_head_info_result} message get_head_info_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_head_info_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_head_info_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_head_info_result} get_head_info_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_head_info_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_head_info_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.head_info.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_head_info_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_head_info_result} get_head_info_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_head_info_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_head_info_result message.
                 * @function verify
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_head_info_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.head_info.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_head_info_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_head_info_result} get_head_info_result
                 */
                get_head_info_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_head_info_result)
                        return object;
                    var message = new $root.koinos.chain.get_head_info_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_head_info_result.value: object expected");
                        message.value = $root.koinos.chain.head_info.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_head_info_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_head_info_result
                 * @static
                 * @param {koinos.chain.get_head_info_result} message get_head_info_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_head_info_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.head_info.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_head_info_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_head_info_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_head_info_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_head_info_result;
            })();
    
            chain.apply_block_arguments = (function() {
    
                /**
                 * Properties of an apply_block_arguments.
                 * @memberof koinos.chain
                 * @interface Iapply_block_arguments
                 * @property {koinos.protocol.Iblock|null} [block] apply_block_arguments block
                 */
    
                /**
                 * Constructs a new apply_block_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_block_arguments.
                 * @implements Iapply_block_arguments
                 * @constructor
                 * @param {koinos.chain.Iapply_block_arguments=} [properties] Properties to set
                 */
                function apply_block_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * apply_block_arguments block.
                 * @member {koinos.protocol.Iblock|null|undefined} block
                 * @memberof koinos.chain.apply_block_arguments
                 * @instance
                 */
                apply_block_arguments.prototype.block = null;
    
                /**
                 * Creates a new apply_block_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {koinos.chain.Iapply_block_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.apply_block_arguments} apply_block_arguments instance
                 */
                apply_block_arguments.create = function create(properties) {
                    return new apply_block_arguments(properties);
                };
    
                /**
                 * Encodes the specified apply_block_arguments message. Does not implicitly {@link koinos.chain.apply_block_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {koinos.chain.Iapply_block_arguments} message apply_block_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_block_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.block != null && Object.hasOwnProperty.call(message, "block"))
                        $root.koinos.protocol.block.encode(message.block, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_block_arguments message, length delimited. Does not implicitly {@link koinos.chain.apply_block_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {koinos.chain.Iapply_block_arguments} message apply_block_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_block_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_block_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_block_arguments} apply_block_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_block_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_block_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.block = $root.koinos.protocol.block.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_block_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_block_arguments} apply_block_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_block_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_block_arguments message.
                 * @function verify
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_block_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.block != null && message.hasOwnProperty("block")) {
                        var error = $root.koinos.protocol.block.verify(message.block);
                        if (error)
                            return "block." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an apply_block_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_block_arguments} apply_block_arguments
                 */
                apply_block_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_block_arguments)
                        return object;
                    var message = new $root.koinos.chain.apply_block_arguments();
                    if (object.block != null) {
                        if (typeof object.block !== "object")
                            throw TypeError(".koinos.chain.apply_block_arguments.block: object expected");
                        message.block = $root.koinos.protocol.block.fromObject(object.block);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an apply_block_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_block_arguments
                 * @static
                 * @param {koinos.chain.apply_block_arguments} message apply_block_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_block_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.block = null;
                    if (message.block != null && message.hasOwnProperty("block"))
                        object.block = $root.koinos.protocol.block.toObject(message.block, options);
                    return object;
                };
    
                /**
                 * Converts this apply_block_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_block_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_block_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_block_arguments;
            })();
    
            chain.apply_block_result = (function() {
    
                /**
                 * Properties of an apply_block_result.
                 * @memberof koinos.chain
                 * @interface Iapply_block_result
                 */
    
                /**
                 * Constructs a new apply_block_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_block_result.
                 * @implements Iapply_block_result
                 * @constructor
                 * @param {koinos.chain.Iapply_block_result=} [properties] Properties to set
                 */
                function apply_block_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new apply_block_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {koinos.chain.Iapply_block_result=} [properties] Properties to set
                 * @returns {koinos.chain.apply_block_result} apply_block_result instance
                 */
                apply_block_result.create = function create(properties) {
                    return new apply_block_result(properties);
                };
    
                /**
                 * Encodes the specified apply_block_result message. Does not implicitly {@link koinos.chain.apply_block_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {koinos.chain.Iapply_block_result} message apply_block_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_block_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_block_result message, length delimited. Does not implicitly {@link koinos.chain.apply_block_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {koinos.chain.Iapply_block_result} message apply_block_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_block_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_block_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_block_result} apply_block_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_block_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_block_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_block_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_block_result} apply_block_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_block_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_block_result message.
                 * @function verify
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_block_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an apply_block_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_block_result} apply_block_result
                 */
                apply_block_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_block_result)
                        return object;
                    return new $root.koinos.chain.apply_block_result();
                };
    
                /**
                 * Creates a plain object from an apply_block_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_block_result
                 * @static
                 * @param {koinos.chain.apply_block_result} message apply_block_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_block_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this apply_block_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_block_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_block_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_block_result;
            })();
    
            chain.apply_transaction_arguments = (function() {
    
                /**
                 * Properties of an apply_transaction_arguments.
                 * @memberof koinos.chain
                 * @interface Iapply_transaction_arguments
                 * @property {koinos.protocol.Itransaction|null} [transaction] apply_transaction_arguments transaction
                 */
    
                /**
                 * Constructs a new apply_transaction_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_transaction_arguments.
                 * @implements Iapply_transaction_arguments
                 * @constructor
                 * @param {koinos.chain.Iapply_transaction_arguments=} [properties] Properties to set
                 */
                function apply_transaction_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * apply_transaction_arguments transaction.
                 * @member {koinos.protocol.Itransaction|null|undefined} transaction
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @instance
                 */
                apply_transaction_arguments.prototype.transaction = null;
    
                /**
                 * Creates a new apply_transaction_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {koinos.chain.Iapply_transaction_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.apply_transaction_arguments} apply_transaction_arguments instance
                 */
                apply_transaction_arguments.create = function create(properties) {
                    return new apply_transaction_arguments(properties);
                };
    
                /**
                 * Encodes the specified apply_transaction_arguments message. Does not implicitly {@link koinos.chain.apply_transaction_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {koinos.chain.Iapply_transaction_arguments} message apply_transaction_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_transaction_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transaction != null && Object.hasOwnProperty.call(message, "transaction"))
                        $root.koinos.protocol.transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_transaction_arguments message, length delimited. Does not implicitly {@link koinos.chain.apply_transaction_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {koinos.chain.Iapply_transaction_arguments} message apply_transaction_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_transaction_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_transaction_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_transaction_arguments} apply_transaction_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_transaction_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_transaction_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transaction = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_transaction_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_transaction_arguments} apply_transaction_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_transaction_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_transaction_arguments message.
                 * @function verify
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_transaction_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transaction != null && message.hasOwnProperty("transaction")) {
                        var error = $root.koinos.protocol.transaction.verify(message.transaction);
                        if (error)
                            return "transaction." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an apply_transaction_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_transaction_arguments} apply_transaction_arguments
                 */
                apply_transaction_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_transaction_arguments)
                        return object;
                    var message = new $root.koinos.chain.apply_transaction_arguments();
                    if (object.transaction != null) {
                        if (typeof object.transaction !== "object")
                            throw TypeError(".koinos.chain.apply_transaction_arguments.transaction: object expected");
                        message.transaction = $root.koinos.protocol.transaction.fromObject(object.transaction);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an apply_transaction_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @static
                 * @param {koinos.chain.apply_transaction_arguments} message apply_transaction_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_transaction_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.transaction = null;
                    if (message.transaction != null && message.hasOwnProperty("transaction"))
                        object.transaction = $root.koinos.protocol.transaction.toObject(message.transaction, options);
                    return object;
                };
    
                /**
                 * Converts this apply_transaction_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_transaction_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_transaction_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_transaction_arguments;
            })();
    
            chain.apply_transaction_result = (function() {
    
                /**
                 * Properties of an apply_transaction_result.
                 * @memberof koinos.chain
                 * @interface Iapply_transaction_result
                 */
    
                /**
                 * Constructs a new apply_transaction_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_transaction_result.
                 * @implements Iapply_transaction_result
                 * @constructor
                 * @param {koinos.chain.Iapply_transaction_result=} [properties] Properties to set
                 */
                function apply_transaction_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new apply_transaction_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {koinos.chain.Iapply_transaction_result=} [properties] Properties to set
                 * @returns {koinos.chain.apply_transaction_result} apply_transaction_result instance
                 */
                apply_transaction_result.create = function create(properties) {
                    return new apply_transaction_result(properties);
                };
    
                /**
                 * Encodes the specified apply_transaction_result message. Does not implicitly {@link koinos.chain.apply_transaction_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {koinos.chain.Iapply_transaction_result} message apply_transaction_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_transaction_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_transaction_result message, length delimited. Does not implicitly {@link koinos.chain.apply_transaction_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {koinos.chain.Iapply_transaction_result} message apply_transaction_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_transaction_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_transaction_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_transaction_result} apply_transaction_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_transaction_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_transaction_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_transaction_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_transaction_result} apply_transaction_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_transaction_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_transaction_result message.
                 * @function verify
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_transaction_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an apply_transaction_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_transaction_result} apply_transaction_result
                 */
                apply_transaction_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_transaction_result)
                        return object;
                    return new $root.koinos.chain.apply_transaction_result();
                };
    
                /**
                 * Creates a plain object from an apply_transaction_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_transaction_result
                 * @static
                 * @param {koinos.chain.apply_transaction_result} message apply_transaction_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_transaction_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this apply_transaction_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_transaction_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_transaction_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_transaction_result;
            })();
    
            chain.apply_upload_contract_operation_arguments = (function() {
    
                /**
                 * Properties of an apply_upload_contract_operation_arguments.
                 * @memberof koinos.chain
                 * @interface Iapply_upload_contract_operation_arguments
                 * @property {koinos.protocol.Iupload_contract_operation|null} [op] apply_upload_contract_operation_arguments op
                 */
    
                /**
                 * Constructs a new apply_upload_contract_operation_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_upload_contract_operation_arguments.
                 * @implements Iapply_upload_contract_operation_arguments
                 * @constructor
                 * @param {koinos.chain.Iapply_upload_contract_operation_arguments=} [properties] Properties to set
                 */
                function apply_upload_contract_operation_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * apply_upload_contract_operation_arguments op.
                 * @member {koinos.protocol.Iupload_contract_operation|null|undefined} op
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @instance
                 */
                apply_upload_contract_operation_arguments.prototype.op = null;
    
                /**
                 * Creates a new apply_upload_contract_operation_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_upload_contract_operation_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.apply_upload_contract_operation_arguments} apply_upload_contract_operation_arguments instance
                 */
                apply_upload_contract_operation_arguments.create = function create(properties) {
                    return new apply_upload_contract_operation_arguments(properties);
                };
    
                /**
                 * Encodes the specified apply_upload_contract_operation_arguments message. Does not implicitly {@link koinos.chain.apply_upload_contract_operation_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_upload_contract_operation_arguments} message apply_upload_contract_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_upload_contract_operation_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                        $root.koinos.protocol.upload_contract_operation.encode(message.op, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_upload_contract_operation_arguments message, length delimited. Does not implicitly {@link koinos.chain.apply_upload_contract_operation_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_upload_contract_operation_arguments} message apply_upload_contract_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_upload_contract_operation_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_upload_contract_operation_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_upload_contract_operation_arguments} apply_upload_contract_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_upload_contract_operation_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_upload_contract_operation_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.op = $root.koinos.protocol.upload_contract_operation.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_upload_contract_operation_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_upload_contract_operation_arguments} apply_upload_contract_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_upload_contract_operation_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_upload_contract_operation_arguments message.
                 * @function verify
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_upload_contract_operation_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.op != null && message.hasOwnProperty("op")) {
                        var error = $root.koinos.protocol.upload_contract_operation.verify(message.op);
                        if (error)
                            return "op." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an apply_upload_contract_operation_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_upload_contract_operation_arguments} apply_upload_contract_operation_arguments
                 */
                apply_upload_contract_operation_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_upload_contract_operation_arguments)
                        return object;
                    var message = new $root.koinos.chain.apply_upload_contract_operation_arguments();
                    if (object.op != null) {
                        if (typeof object.op !== "object")
                            throw TypeError(".koinos.chain.apply_upload_contract_operation_arguments.op: object expected");
                        message.op = $root.koinos.protocol.upload_contract_operation.fromObject(object.op);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an apply_upload_contract_operation_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.apply_upload_contract_operation_arguments} message apply_upload_contract_operation_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_upload_contract_operation_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.op = null;
                    if (message.op != null && message.hasOwnProperty("op"))
                        object.op = $root.koinos.protocol.upload_contract_operation.toObject(message.op, options);
                    return object;
                };
    
                /**
                 * Converts this apply_upload_contract_operation_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_upload_contract_operation_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_upload_contract_operation_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_upload_contract_operation_arguments;
            })();
    
            chain.apply_upload_contract_operation_result = (function() {
    
                /**
                 * Properties of an apply_upload_contract_operation_result.
                 * @memberof koinos.chain
                 * @interface Iapply_upload_contract_operation_result
                 */
    
                /**
                 * Constructs a new apply_upload_contract_operation_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_upload_contract_operation_result.
                 * @implements Iapply_upload_contract_operation_result
                 * @constructor
                 * @param {koinos.chain.Iapply_upload_contract_operation_result=} [properties] Properties to set
                 */
                function apply_upload_contract_operation_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new apply_upload_contract_operation_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_upload_contract_operation_result=} [properties] Properties to set
                 * @returns {koinos.chain.apply_upload_contract_operation_result} apply_upload_contract_operation_result instance
                 */
                apply_upload_contract_operation_result.create = function create(properties) {
                    return new apply_upload_contract_operation_result(properties);
                };
    
                /**
                 * Encodes the specified apply_upload_contract_operation_result message. Does not implicitly {@link koinos.chain.apply_upload_contract_operation_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_upload_contract_operation_result} message apply_upload_contract_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_upload_contract_operation_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_upload_contract_operation_result message, length delimited. Does not implicitly {@link koinos.chain.apply_upload_contract_operation_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_upload_contract_operation_result} message apply_upload_contract_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_upload_contract_operation_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_upload_contract_operation_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_upload_contract_operation_result} apply_upload_contract_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_upload_contract_operation_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_upload_contract_operation_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_upload_contract_operation_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_upload_contract_operation_result} apply_upload_contract_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_upload_contract_operation_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_upload_contract_operation_result message.
                 * @function verify
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_upload_contract_operation_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an apply_upload_contract_operation_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_upload_contract_operation_result} apply_upload_contract_operation_result
                 */
                apply_upload_contract_operation_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_upload_contract_operation_result)
                        return object;
                    return new $root.koinos.chain.apply_upload_contract_operation_result();
                };
    
                /**
                 * Creates a plain object from an apply_upload_contract_operation_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @static
                 * @param {koinos.chain.apply_upload_contract_operation_result} message apply_upload_contract_operation_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_upload_contract_operation_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this apply_upload_contract_operation_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_upload_contract_operation_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_upload_contract_operation_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_upload_contract_operation_result;
            })();
    
            chain.apply_call_contract_operation_arguments = (function() {
    
                /**
                 * Properties of an apply_call_contract_operation_arguments.
                 * @memberof koinos.chain
                 * @interface Iapply_call_contract_operation_arguments
                 * @property {koinos.protocol.Icall_contract_operation|null} [op] apply_call_contract_operation_arguments op
                 */
    
                /**
                 * Constructs a new apply_call_contract_operation_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_call_contract_operation_arguments.
                 * @implements Iapply_call_contract_operation_arguments
                 * @constructor
                 * @param {koinos.chain.Iapply_call_contract_operation_arguments=} [properties] Properties to set
                 */
                function apply_call_contract_operation_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * apply_call_contract_operation_arguments op.
                 * @member {koinos.protocol.Icall_contract_operation|null|undefined} op
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @instance
                 */
                apply_call_contract_operation_arguments.prototype.op = null;
    
                /**
                 * Creates a new apply_call_contract_operation_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_call_contract_operation_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.apply_call_contract_operation_arguments} apply_call_contract_operation_arguments instance
                 */
                apply_call_contract_operation_arguments.create = function create(properties) {
                    return new apply_call_contract_operation_arguments(properties);
                };
    
                /**
                 * Encodes the specified apply_call_contract_operation_arguments message. Does not implicitly {@link koinos.chain.apply_call_contract_operation_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_call_contract_operation_arguments} message apply_call_contract_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_call_contract_operation_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                        $root.koinos.protocol.call_contract_operation.encode(message.op, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_call_contract_operation_arguments message, length delimited. Does not implicitly {@link koinos.chain.apply_call_contract_operation_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_call_contract_operation_arguments} message apply_call_contract_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_call_contract_operation_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_call_contract_operation_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_call_contract_operation_arguments} apply_call_contract_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_call_contract_operation_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_call_contract_operation_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.op = $root.koinos.protocol.call_contract_operation.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_call_contract_operation_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_call_contract_operation_arguments} apply_call_contract_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_call_contract_operation_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_call_contract_operation_arguments message.
                 * @function verify
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_call_contract_operation_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.op != null && message.hasOwnProperty("op")) {
                        var error = $root.koinos.protocol.call_contract_operation.verify(message.op);
                        if (error)
                            return "op." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an apply_call_contract_operation_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_call_contract_operation_arguments} apply_call_contract_operation_arguments
                 */
                apply_call_contract_operation_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_call_contract_operation_arguments)
                        return object;
                    var message = new $root.koinos.chain.apply_call_contract_operation_arguments();
                    if (object.op != null) {
                        if (typeof object.op !== "object")
                            throw TypeError(".koinos.chain.apply_call_contract_operation_arguments.op: object expected");
                        message.op = $root.koinos.protocol.call_contract_operation.fromObject(object.op);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an apply_call_contract_operation_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.apply_call_contract_operation_arguments} message apply_call_contract_operation_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_call_contract_operation_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.op = null;
                    if (message.op != null && message.hasOwnProperty("op"))
                        object.op = $root.koinos.protocol.call_contract_operation.toObject(message.op, options);
                    return object;
                };
    
                /**
                 * Converts this apply_call_contract_operation_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_call_contract_operation_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_call_contract_operation_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_call_contract_operation_arguments;
            })();
    
            chain.apply_call_contract_operation_result = (function() {
    
                /**
                 * Properties of an apply_call_contract_operation_result.
                 * @memberof koinos.chain
                 * @interface Iapply_call_contract_operation_result
                 */
    
                /**
                 * Constructs a new apply_call_contract_operation_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_call_contract_operation_result.
                 * @implements Iapply_call_contract_operation_result
                 * @constructor
                 * @param {koinos.chain.Iapply_call_contract_operation_result=} [properties] Properties to set
                 */
                function apply_call_contract_operation_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new apply_call_contract_operation_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_call_contract_operation_result=} [properties] Properties to set
                 * @returns {koinos.chain.apply_call_contract_operation_result} apply_call_contract_operation_result instance
                 */
                apply_call_contract_operation_result.create = function create(properties) {
                    return new apply_call_contract_operation_result(properties);
                };
    
                /**
                 * Encodes the specified apply_call_contract_operation_result message. Does not implicitly {@link koinos.chain.apply_call_contract_operation_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_call_contract_operation_result} message apply_call_contract_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_call_contract_operation_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_call_contract_operation_result message, length delimited. Does not implicitly {@link koinos.chain.apply_call_contract_operation_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_call_contract_operation_result} message apply_call_contract_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_call_contract_operation_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_call_contract_operation_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_call_contract_operation_result} apply_call_contract_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_call_contract_operation_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_call_contract_operation_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_call_contract_operation_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_call_contract_operation_result} apply_call_contract_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_call_contract_operation_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_call_contract_operation_result message.
                 * @function verify
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_call_contract_operation_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an apply_call_contract_operation_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_call_contract_operation_result} apply_call_contract_operation_result
                 */
                apply_call_contract_operation_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_call_contract_operation_result)
                        return object;
                    return new $root.koinos.chain.apply_call_contract_operation_result();
                };
    
                /**
                 * Creates a plain object from an apply_call_contract_operation_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @static
                 * @param {koinos.chain.apply_call_contract_operation_result} message apply_call_contract_operation_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_call_contract_operation_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this apply_call_contract_operation_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_call_contract_operation_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_call_contract_operation_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_call_contract_operation_result;
            })();
    
            chain.apply_set_system_call_operation_arguments = (function() {
    
                /**
                 * Properties of an apply_set_system_call_operation_arguments.
                 * @memberof koinos.chain
                 * @interface Iapply_set_system_call_operation_arguments
                 * @property {koinos.protocol.Iset_system_call_operation|null} [op] apply_set_system_call_operation_arguments op
                 */
    
                /**
                 * Constructs a new apply_set_system_call_operation_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_set_system_call_operation_arguments.
                 * @implements Iapply_set_system_call_operation_arguments
                 * @constructor
                 * @param {koinos.chain.Iapply_set_system_call_operation_arguments=} [properties] Properties to set
                 */
                function apply_set_system_call_operation_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * apply_set_system_call_operation_arguments op.
                 * @member {koinos.protocol.Iset_system_call_operation|null|undefined} op
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @instance
                 */
                apply_set_system_call_operation_arguments.prototype.op = null;
    
                /**
                 * Creates a new apply_set_system_call_operation_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_set_system_call_operation_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.apply_set_system_call_operation_arguments} apply_set_system_call_operation_arguments instance
                 */
                apply_set_system_call_operation_arguments.create = function create(properties) {
                    return new apply_set_system_call_operation_arguments(properties);
                };
    
                /**
                 * Encodes the specified apply_set_system_call_operation_arguments message. Does not implicitly {@link koinos.chain.apply_set_system_call_operation_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_set_system_call_operation_arguments} message apply_set_system_call_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_call_operation_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                        $root.koinos.protocol.set_system_call_operation.encode(message.op, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_set_system_call_operation_arguments message, length delimited. Does not implicitly {@link koinos.chain.apply_set_system_call_operation_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_set_system_call_operation_arguments} message apply_set_system_call_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_call_operation_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_set_system_call_operation_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_set_system_call_operation_arguments} apply_set_system_call_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_call_operation_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_set_system_call_operation_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.op = $root.koinos.protocol.set_system_call_operation.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_set_system_call_operation_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_set_system_call_operation_arguments} apply_set_system_call_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_call_operation_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_set_system_call_operation_arguments message.
                 * @function verify
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_set_system_call_operation_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.op != null && message.hasOwnProperty("op")) {
                        var error = $root.koinos.protocol.set_system_call_operation.verify(message.op);
                        if (error)
                            return "op." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an apply_set_system_call_operation_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_set_system_call_operation_arguments} apply_set_system_call_operation_arguments
                 */
                apply_set_system_call_operation_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_set_system_call_operation_arguments)
                        return object;
                    var message = new $root.koinos.chain.apply_set_system_call_operation_arguments();
                    if (object.op != null) {
                        if (typeof object.op !== "object")
                            throw TypeError(".koinos.chain.apply_set_system_call_operation_arguments.op: object expected");
                        message.op = $root.koinos.protocol.set_system_call_operation.fromObject(object.op);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an apply_set_system_call_operation_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @static
                 * @param {koinos.chain.apply_set_system_call_operation_arguments} message apply_set_system_call_operation_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_set_system_call_operation_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.op = null;
                    if (message.op != null && message.hasOwnProperty("op"))
                        object.op = $root.koinos.protocol.set_system_call_operation.toObject(message.op, options);
                    return object;
                };
    
                /**
                 * Converts this apply_set_system_call_operation_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_set_system_call_operation_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_set_system_call_operation_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_set_system_call_operation_arguments;
            })();
    
            chain.apply_set_system_call_operation_result = (function() {
    
                /**
                 * Properties of an apply_set_system_call_operation_result.
                 * @memberof koinos.chain
                 * @interface Iapply_set_system_call_operation_result
                 */
    
                /**
                 * Constructs a new apply_set_system_call_operation_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_set_system_call_operation_result.
                 * @implements Iapply_set_system_call_operation_result
                 * @constructor
                 * @param {koinos.chain.Iapply_set_system_call_operation_result=} [properties] Properties to set
                 */
                function apply_set_system_call_operation_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new apply_set_system_call_operation_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_set_system_call_operation_result=} [properties] Properties to set
                 * @returns {koinos.chain.apply_set_system_call_operation_result} apply_set_system_call_operation_result instance
                 */
                apply_set_system_call_operation_result.create = function create(properties) {
                    return new apply_set_system_call_operation_result(properties);
                };
    
                /**
                 * Encodes the specified apply_set_system_call_operation_result message. Does not implicitly {@link koinos.chain.apply_set_system_call_operation_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_set_system_call_operation_result} message apply_set_system_call_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_call_operation_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_set_system_call_operation_result message, length delimited. Does not implicitly {@link koinos.chain.apply_set_system_call_operation_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_set_system_call_operation_result} message apply_set_system_call_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_call_operation_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_set_system_call_operation_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_set_system_call_operation_result} apply_set_system_call_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_call_operation_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_set_system_call_operation_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_set_system_call_operation_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_set_system_call_operation_result} apply_set_system_call_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_call_operation_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_set_system_call_operation_result message.
                 * @function verify
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_set_system_call_operation_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an apply_set_system_call_operation_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_set_system_call_operation_result} apply_set_system_call_operation_result
                 */
                apply_set_system_call_operation_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_set_system_call_operation_result)
                        return object;
                    return new $root.koinos.chain.apply_set_system_call_operation_result();
                };
    
                /**
                 * Creates a plain object from an apply_set_system_call_operation_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @static
                 * @param {koinos.chain.apply_set_system_call_operation_result} message apply_set_system_call_operation_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_set_system_call_operation_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this apply_set_system_call_operation_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_set_system_call_operation_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_set_system_call_operation_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_set_system_call_operation_result;
            })();
    
            chain.apply_set_system_contract_operation_arguments = (function() {
    
                /**
                 * Properties of an apply_set_system_contract_operation_arguments.
                 * @memberof koinos.chain
                 * @interface Iapply_set_system_contract_operation_arguments
                 * @property {koinos.protocol.Iset_system_contract_operation|null} [op] apply_set_system_contract_operation_arguments op
                 */
    
                /**
                 * Constructs a new apply_set_system_contract_operation_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_set_system_contract_operation_arguments.
                 * @implements Iapply_set_system_contract_operation_arguments
                 * @constructor
                 * @param {koinos.chain.Iapply_set_system_contract_operation_arguments=} [properties] Properties to set
                 */
                function apply_set_system_contract_operation_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * apply_set_system_contract_operation_arguments op.
                 * @member {koinos.protocol.Iset_system_contract_operation|null|undefined} op
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @instance
                 */
                apply_set_system_contract_operation_arguments.prototype.op = null;
    
                /**
                 * Creates a new apply_set_system_contract_operation_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_set_system_contract_operation_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.apply_set_system_contract_operation_arguments} apply_set_system_contract_operation_arguments instance
                 */
                apply_set_system_contract_operation_arguments.create = function create(properties) {
                    return new apply_set_system_contract_operation_arguments(properties);
                };
    
                /**
                 * Encodes the specified apply_set_system_contract_operation_arguments message. Does not implicitly {@link koinos.chain.apply_set_system_contract_operation_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_set_system_contract_operation_arguments} message apply_set_system_contract_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_contract_operation_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                        $root.koinos.protocol.set_system_contract_operation.encode(message.op, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_set_system_contract_operation_arguments message, length delimited. Does not implicitly {@link koinos.chain.apply_set_system_contract_operation_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.Iapply_set_system_contract_operation_arguments} message apply_set_system_contract_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_contract_operation_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_set_system_contract_operation_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_set_system_contract_operation_arguments} apply_set_system_contract_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_contract_operation_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_set_system_contract_operation_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.op = $root.koinos.protocol.set_system_contract_operation.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_set_system_contract_operation_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_set_system_contract_operation_arguments} apply_set_system_contract_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_contract_operation_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_set_system_contract_operation_arguments message.
                 * @function verify
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_set_system_contract_operation_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.op != null && message.hasOwnProperty("op")) {
                        var error = $root.koinos.protocol.set_system_contract_operation.verify(message.op);
                        if (error)
                            return "op." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an apply_set_system_contract_operation_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_set_system_contract_operation_arguments} apply_set_system_contract_operation_arguments
                 */
                apply_set_system_contract_operation_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_set_system_contract_operation_arguments)
                        return object;
                    var message = new $root.koinos.chain.apply_set_system_contract_operation_arguments();
                    if (object.op != null) {
                        if (typeof object.op !== "object")
                            throw TypeError(".koinos.chain.apply_set_system_contract_operation_arguments.op: object expected");
                        message.op = $root.koinos.protocol.set_system_contract_operation.fromObject(object.op);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an apply_set_system_contract_operation_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @static
                 * @param {koinos.chain.apply_set_system_contract_operation_arguments} message apply_set_system_contract_operation_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_set_system_contract_operation_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.op = null;
                    if (message.op != null && message.hasOwnProperty("op"))
                        object.op = $root.koinos.protocol.set_system_contract_operation.toObject(message.op, options);
                    return object;
                };
    
                /**
                 * Converts this apply_set_system_contract_operation_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_set_system_contract_operation_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_set_system_contract_operation_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_set_system_contract_operation_arguments;
            })();
    
            chain.apply_set_system_contract_operation_result = (function() {
    
                /**
                 * Properties of an apply_set_system_contract_operation_result.
                 * @memberof koinos.chain
                 * @interface Iapply_set_system_contract_operation_result
                 */
    
                /**
                 * Constructs a new apply_set_system_contract_operation_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an apply_set_system_contract_operation_result.
                 * @implements Iapply_set_system_contract_operation_result
                 * @constructor
                 * @param {koinos.chain.Iapply_set_system_contract_operation_result=} [properties] Properties to set
                 */
                function apply_set_system_contract_operation_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new apply_set_system_contract_operation_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_set_system_contract_operation_result=} [properties] Properties to set
                 * @returns {koinos.chain.apply_set_system_contract_operation_result} apply_set_system_contract_operation_result instance
                 */
                apply_set_system_contract_operation_result.create = function create(properties) {
                    return new apply_set_system_contract_operation_result(properties);
                };
    
                /**
                 * Encodes the specified apply_set_system_contract_operation_result message. Does not implicitly {@link koinos.chain.apply_set_system_contract_operation_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_set_system_contract_operation_result} message apply_set_system_contract_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_contract_operation_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified apply_set_system_contract_operation_result message, length delimited. Does not implicitly {@link koinos.chain.apply_set_system_contract_operation_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {koinos.chain.Iapply_set_system_contract_operation_result} message apply_set_system_contract_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                apply_set_system_contract_operation_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an apply_set_system_contract_operation_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.apply_set_system_contract_operation_result} apply_set_system_contract_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_contract_operation_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.apply_set_system_contract_operation_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an apply_set_system_contract_operation_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.apply_set_system_contract_operation_result} apply_set_system_contract_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                apply_set_system_contract_operation_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an apply_set_system_contract_operation_result message.
                 * @function verify
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                apply_set_system_contract_operation_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an apply_set_system_contract_operation_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.apply_set_system_contract_operation_result} apply_set_system_contract_operation_result
                 */
                apply_set_system_contract_operation_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.apply_set_system_contract_operation_result)
                        return object;
                    return new $root.koinos.chain.apply_set_system_contract_operation_result();
                };
    
                /**
                 * Creates a plain object from an apply_set_system_contract_operation_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @static
                 * @param {koinos.chain.apply_set_system_contract_operation_result} message apply_set_system_contract_operation_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                apply_set_system_contract_operation_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this apply_set_system_contract_operation_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.apply_set_system_contract_operation_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                apply_set_system_contract_operation_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return apply_set_system_contract_operation_result;
            })();
    
            chain.pre_block_callback_arguments = (function() {
    
                /**
                 * Properties of a pre_block_callback_arguments.
                 * @memberof koinos.chain
                 * @interface Ipre_block_callback_arguments
                 */
    
                /**
                 * Constructs a new pre_block_callback_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a pre_block_callback_arguments.
                 * @implements Ipre_block_callback_arguments
                 * @constructor
                 * @param {koinos.chain.Ipre_block_callback_arguments=} [properties] Properties to set
                 */
                function pre_block_callback_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new pre_block_callback_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipre_block_callback_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.pre_block_callback_arguments} pre_block_callback_arguments instance
                 */
                pre_block_callback_arguments.create = function create(properties) {
                    return new pre_block_callback_arguments(properties);
                };
    
                /**
                 * Encodes the specified pre_block_callback_arguments message. Does not implicitly {@link koinos.chain.pre_block_callback_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipre_block_callback_arguments} message pre_block_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_block_callback_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified pre_block_callback_arguments message, length delimited. Does not implicitly {@link koinos.chain.pre_block_callback_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipre_block_callback_arguments} message pre_block_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_block_callback_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a pre_block_callback_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.pre_block_callback_arguments} pre_block_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_block_callback_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.pre_block_callback_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a pre_block_callback_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.pre_block_callback_arguments} pre_block_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_block_callback_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a pre_block_callback_arguments message.
                 * @function verify
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                pre_block_callback_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a pre_block_callback_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.pre_block_callback_arguments} pre_block_callback_arguments
                 */
                pre_block_callback_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.pre_block_callback_arguments)
                        return object;
                    return new $root.koinos.chain.pre_block_callback_arguments();
                };
    
                /**
                 * Creates a plain object from a pre_block_callback_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @static
                 * @param {koinos.chain.pre_block_callback_arguments} message pre_block_callback_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                pre_block_callback_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this pre_block_callback_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.pre_block_callback_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                pre_block_callback_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return pre_block_callback_arguments;
            })();
    
            chain.pre_block_callback_result = (function() {
    
                /**
                 * Properties of a pre_block_callback_result.
                 * @memberof koinos.chain
                 * @interface Ipre_block_callback_result
                 */
    
                /**
                 * Constructs a new pre_block_callback_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a pre_block_callback_result.
                 * @implements Ipre_block_callback_result
                 * @constructor
                 * @param {koinos.chain.Ipre_block_callback_result=} [properties] Properties to set
                 */
                function pre_block_callback_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new pre_block_callback_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {koinos.chain.Ipre_block_callback_result=} [properties] Properties to set
                 * @returns {koinos.chain.pre_block_callback_result} pre_block_callback_result instance
                 */
                pre_block_callback_result.create = function create(properties) {
                    return new pre_block_callback_result(properties);
                };
    
                /**
                 * Encodes the specified pre_block_callback_result message. Does not implicitly {@link koinos.chain.pre_block_callback_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {koinos.chain.Ipre_block_callback_result} message pre_block_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_block_callback_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified pre_block_callback_result message, length delimited. Does not implicitly {@link koinos.chain.pre_block_callback_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {koinos.chain.Ipre_block_callback_result} message pre_block_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_block_callback_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a pre_block_callback_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.pre_block_callback_result} pre_block_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_block_callback_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.pre_block_callback_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a pre_block_callback_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.pre_block_callback_result} pre_block_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_block_callback_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a pre_block_callback_result message.
                 * @function verify
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                pre_block_callback_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a pre_block_callback_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.pre_block_callback_result} pre_block_callback_result
                 */
                pre_block_callback_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.pre_block_callback_result)
                        return object;
                    return new $root.koinos.chain.pre_block_callback_result();
                };
    
                /**
                 * Creates a plain object from a pre_block_callback_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.pre_block_callback_result
                 * @static
                 * @param {koinos.chain.pre_block_callback_result} message pre_block_callback_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                pre_block_callback_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this pre_block_callback_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.pre_block_callback_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                pre_block_callback_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return pre_block_callback_result;
            })();
    
            chain.post_block_callback_arguments = (function() {
    
                /**
                 * Properties of a post_block_callback_arguments.
                 * @memberof koinos.chain
                 * @interface Ipost_block_callback_arguments
                 */
    
                /**
                 * Constructs a new post_block_callback_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a post_block_callback_arguments.
                 * @implements Ipost_block_callback_arguments
                 * @constructor
                 * @param {koinos.chain.Ipost_block_callback_arguments=} [properties] Properties to set
                 */
                function post_block_callback_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new post_block_callback_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipost_block_callback_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.post_block_callback_arguments} post_block_callback_arguments instance
                 */
                post_block_callback_arguments.create = function create(properties) {
                    return new post_block_callback_arguments(properties);
                };
    
                /**
                 * Encodes the specified post_block_callback_arguments message. Does not implicitly {@link koinos.chain.post_block_callback_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipost_block_callback_arguments} message post_block_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_block_callback_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified post_block_callback_arguments message, length delimited. Does not implicitly {@link koinos.chain.post_block_callback_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipost_block_callback_arguments} message post_block_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_block_callback_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a post_block_callback_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.post_block_callback_arguments} post_block_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_block_callback_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.post_block_callback_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a post_block_callback_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.post_block_callback_arguments} post_block_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_block_callback_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a post_block_callback_arguments message.
                 * @function verify
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                post_block_callback_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a post_block_callback_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.post_block_callback_arguments} post_block_callback_arguments
                 */
                post_block_callback_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.post_block_callback_arguments)
                        return object;
                    return new $root.koinos.chain.post_block_callback_arguments();
                };
    
                /**
                 * Creates a plain object from a post_block_callback_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @static
                 * @param {koinos.chain.post_block_callback_arguments} message post_block_callback_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                post_block_callback_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this post_block_callback_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.post_block_callback_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                post_block_callback_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return post_block_callback_arguments;
            })();
    
            chain.post_block_callback_result = (function() {
    
                /**
                 * Properties of a post_block_callback_result.
                 * @memberof koinos.chain
                 * @interface Ipost_block_callback_result
                 */
    
                /**
                 * Constructs a new post_block_callback_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a post_block_callback_result.
                 * @implements Ipost_block_callback_result
                 * @constructor
                 * @param {koinos.chain.Ipost_block_callback_result=} [properties] Properties to set
                 */
                function post_block_callback_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new post_block_callback_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {koinos.chain.Ipost_block_callback_result=} [properties] Properties to set
                 * @returns {koinos.chain.post_block_callback_result} post_block_callback_result instance
                 */
                post_block_callback_result.create = function create(properties) {
                    return new post_block_callback_result(properties);
                };
    
                /**
                 * Encodes the specified post_block_callback_result message. Does not implicitly {@link koinos.chain.post_block_callback_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {koinos.chain.Ipost_block_callback_result} message post_block_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_block_callback_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified post_block_callback_result message, length delimited. Does not implicitly {@link koinos.chain.post_block_callback_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {koinos.chain.Ipost_block_callback_result} message post_block_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_block_callback_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a post_block_callback_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.post_block_callback_result} post_block_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_block_callback_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.post_block_callback_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a post_block_callback_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.post_block_callback_result} post_block_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_block_callback_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a post_block_callback_result message.
                 * @function verify
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                post_block_callback_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a post_block_callback_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.post_block_callback_result} post_block_callback_result
                 */
                post_block_callback_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.post_block_callback_result)
                        return object;
                    return new $root.koinos.chain.post_block_callback_result();
                };
    
                /**
                 * Creates a plain object from a post_block_callback_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.post_block_callback_result
                 * @static
                 * @param {koinos.chain.post_block_callback_result} message post_block_callback_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                post_block_callback_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this post_block_callback_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.post_block_callback_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                post_block_callback_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return post_block_callback_result;
            })();
    
            chain.pre_transaction_callback_arguments = (function() {
    
                /**
                 * Properties of a pre_transaction_callback_arguments.
                 * @memberof koinos.chain
                 * @interface Ipre_transaction_callback_arguments
                 */
    
                /**
                 * Constructs a new pre_transaction_callback_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a pre_transaction_callback_arguments.
                 * @implements Ipre_transaction_callback_arguments
                 * @constructor
                 * @param {koinos.chain.Ipre_transaction_callback_arguments=} [properties] Properties to set
                 */
                function pre_transaction_callback_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new pre_transaction_callback_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipre_transaction_callback_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.pre_transaction_callback_arguments} pre_transaction_callback_arguments instance
                 */
                pre_transaction_callback_arguments.create = function create(properties) {
                    return new pre_transaction_callback_arguments(properties);
                };
    
                /**
                 * Encodes the specified pre_transaction_callback_arguments message. Does not implicitly {@link koinos.chain.pre_transaction_callback_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipre_transaction_callback_arguments} message pre_transaction_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_transaction_callback_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified pre_transaction_callback_arguments message, length delimited. Does not implicitly {@link koinos.chain.pre_transaction_callback_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipre_transaction_callback_arguments} message pre_transaction_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_transaction_callback_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a pre_transaction_callback_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.pre_transaction_callback_arguments} pre_transaction_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_transaction_callback_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.pre_transaction_callback_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a pre_transaction_callback_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.pre_transaction_callback_arguments} pre_transaction_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_transaction_callback_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a pre_transaction_callback_arguments message.
                 * @function verify
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                pre_transaction_callback_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a pre_transaction_callback_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.pre_transaction_callback_arguments} pre_transaction_callback_arguments
                 */
                pre_transaction_callback_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.pre_transaction_callback_arguments)
                        return object;
                    return new $root.koinos.chain.pre_transaction_callback_arguments();
                };
    
                /**
                 * Creates a plain object from a pre_transaction_callback_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.pre_transaction_callback_arguments} message pre_transaction_callback_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                pre_transaction_callback_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this pre_transaction_callback_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.pre_transaction_callback_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                pre_transaction_callback_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return pre_transaction_callback_arguments;
            })();
    
            chain.pre_transaction_callback_result = (function() {
    
                /**
                 * Properties of a pre_transaction_callback_result.
                 * @memberof koinos.chain
                 * @interface Ipre_transaction_callback_result
                 */
    
                /**
                 * Constructs a new pre_transaction_callback_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a pre_transaction_callback_result.
                 * @implements Ipre_transaction_callback_result
                 * @constructor
                 * @param {koinos.chain.Ipre_transaction_callback_result=} [properties] Properties to set
                 */
                function pre_transaction_callback_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new pre_transaction_callback_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {koinos.chain.Ipre_transaction_callback_result=} [properties] Properties to set
                 * @returns {koinos.chain.pre_transaction_callback_result} pre_transaction_callback_result instance
                 */
                pre_transaction_callback_result.create = function create(properties) {
                    return new pre_transaction_callback_result(properties);
                };
    
                /**
                 * Encodes the specified pre_transaction_callback_result message. Does not implicitly {@link koinos.chain.pre_transaction_callback_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {koinos.chain.Ipre_transaction_callback_result} message pre_transaction_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_transaction_callback_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified pre_transaction_callback_result message, length delimited. Does not implicitly {@link koinos.chain.pre_transaction_callback_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {koinos.chain.Ipre_transaction_callback_result} message pre_transaction_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                pre_transaction_callback_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a pre_transaction_callback_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.pre_transaction_callback_result} pre_transaction_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_transaction_callback_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.pre_transaction_callback_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a pre_transaction_callback_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.pre_transaction_callback_result} pre_transaction_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                pre_transaction_callback_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a pre_transaction_callback_result message.
                 * @function verify
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                pre_transaction_callback_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a pre_transaction_callback_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.pre_transaction_callback_result} pre_transaction_callback_result
                 */
                pre_transaction_callback_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.pre_transaction_callback_result)
                        return object;
                    return new $root.koinos.chain.pre_transaction_callback_result();
                };
    
                /**
                 * Creates a plain object from a pre_transaction_callback_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @static
                 * @param {koinos.chain.pre_transaction_callback_result} message pre_transaction_callback_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                pre_transaction_callback_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this pre_transaction_callback_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.pre_transaction_callback_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                pre_transaction_callback_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return pre_transaction_callback_result;
            })();
    
            chain.post_transaction_callback_arguments = (function() {
    
                /**
                 * Properties of a post_transaction_callback_arguments.
                 * @memberof koinos.chain
                 * @interface Ipost_transaction_callback_arguments
                 */
    
                /**
                 * Constructs a new post_transaction_callback_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a post_transaction_callback_arguments.
                 * @implements Ipost_transaction_callback_arguments
                 * @constructor
                 * @param {koinos.chain.Ipost_transaction_callback_arguments=} [properties] Properties to set
                 */
                function post_transaction_callback_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new post_transaction_callback_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipost_transaction_callback_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.post_transaction_callback_arguments} post_transaction_callback_arguments instance
                 */
                post_transaction_callback_arguments.create = function create(properties) {
                    return new post_transaction_callback_arguments(properties);
                };
    
                /**
                 * Encodes the specified post_transaction_callback_arguments message. Does not implicitly {@link koinos.chain.post_transaction_callback_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipost_transaction_callback_arguments} message post_transaction_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_transaction_callback_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified post_transaction_callback_arguments message, length delimited. Does not implicitly {@link koinos.chain.post_transaction_callback_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.Ipost_transaction_callback_arguments} message post_transaction_callback_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_transaction_callback_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a post_transaction_callback_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.post_transaction_callback_arguments} post_transaction_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_transaction_callback_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.post_transaction_callback_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a post_transaction_callback_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.post_transaction_callback_arguments} post_transaction_callback_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_transaction_callback_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a post_transaction_callback_arguments message.
                 * @function verify
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                post_transaction_callback_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a post_transaction_callback_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.post_transaction_callback_arguments} post_transaction_callback_arguments
                 */
                post_transaction_callback_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.post_transaction_callback_arguments)
                        return object;
                    return new $root.koinos.chain.post_transaction_callback_arguments();
                };
    
                /**
                 * Creates a plain object from a post_transaction_callback_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @static
                 * @param {koinos.chain.post_transaction_callback_arguments} message post_transaction_callback_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                post_transaction_callback_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this post_transaction_callback_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.post_transaction_callback_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                post_transaction_callback_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return post_transaction_callback_arguments;
            })();
    
            chain.post_transaction_callback_result = (function() {
    
                /**
                 * Properties of a post_transaction_callback_result.
                 * @memberof koinos.chain
                 * @interface Ipost_transaction_callback_result
                 */
    
                /**
                 * Constructs a new post_transaction_callback_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a post_transaction_callback_result.
                 * @implements Ipost_transaction_callback_result
                 * @constructor
                 * @param {koinos.chain.Ipost_transaction_callback_result=} [properties] Properties to set
                 */
                function post_transaction_callback_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new post_transaction_callback_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {koinos.chain.Ipost_transaction_callback_result=} [properties] Properties to set
                 * @returns {koinos.chain.post_transaction_callback_result} post_transaction_callback_result instance
                 */
                post_transaction_callback_result.create = function create(properties) {
                    return new post_transaction_callback_result(properties);
                };
    
                /**
                 * Encodes the specified post_transaction_callback_result message. Does not implicitly {@link koinos.chain.post_transaction_callback_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {koinos.chain.Ipost_transaction_callback_result} message post_transaction_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_transaction_callback_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified post_transaction_callback_result message, length delimited. Does not implicitly {@link koinos.chain.post_transaction_callback_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {koinos.chain.Ipost_transaction_callback_result} message post_transaction_callback_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                post_transaction_callback_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a post_transaction_callback_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.post_transaction_callback_result} post_transaction_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_transaction_callback_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.post_transaction_callback_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a post_transaction_callback_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.post_transaction_callback_result} post_transaction_callback_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                post_transaction_callback_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a post_transaction_callback_result message.
                 * @function verify
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                post_transaction_callback_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a post_transaction_callback_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.post_transaction_callback_result} post_transaction_callback_result
                 */
                post_transaction_callback_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.post_transaction_callback_result)
                        return object;
                    return new $root.koinos.chain.post_transaction_callback_result();
                };
    
                /**
                 * Creates a plain object from a post_transaction_callback_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @static
                 * @param {koinos.chain.post_transaction_callback_result} message post_transaction_callback_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                post_transaction_callback_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this post_transaction_callback_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.post_transaction_callback_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                post_transaction_callback_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return post_transaction_callback_result;
            })();
    
            chain.get_chain_id_arguments = (function() {
    
                /**
                 * Properties of a get_chain_id_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_chain_id_arguments
                 */
    
                /**
                 * Constructs a new get_chain_id_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_chain_id_arguments.
                 * @implements Iget_chain_id_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_chain_id_arguments=} [properties] Properties to set
                 */
                function get_chain_id_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_chain_id_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {koinos.chain.Iget_chain_id_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_chain_id_arguments} get_chain_id_arguments instance
                 */
                get_chain_id_arguments.create = function create(properties) {
                    return new get_chain_id_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_chain_id_arguments message. Does not implicitly {@link koinos.chain.get_chain_id_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {koinos.chain.Iget_chain_id_arguments} message get_chain_id_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_chain_id_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_chain_id_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_chain_id_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {koinos.chain.Iget_chain_id_arguments} message get_chain_id_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_chain_id_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_chain_id_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_chain_id_arguments} get_chain_id_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_chain_id_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_chain_id_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_chain_id_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_chain_id_arguments} get_chain_id_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_chain_id_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_chain_id_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_chain_id_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_chain_id_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_chain_id_arguments} get_chain_id_arguments
                 */
                get_chain_id_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_chain_id_arguments)
                        return object;
                    return new $root.koinos.chain.get_chain_id_arguments();
                };
    
                /**
                 * Creates a plain object from a get_chain_id_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @static
                 * @param {koinos.chain.get_chain_id_arguments} message get_chain_id_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_chain_id_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_chain_id_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_chain_id_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_chain_id_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_chain_id_arguments;
            })();
    
            chain.get_chain_id_result = (function() {
    
                /**
                 * Properties of a get_chain_id_result.
                 * @memberof koinos.chain
                 * @interface Iget_chain_id_result
                 * @property {Uint8Array|null} [value] get_chain_id_result value
                 */
    
                /**
                 * Constructs a new get_chain_id_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_chain_id_result.
                 * @implements Iget_chain_id_result
                 * @constructor
                 * @param {koinos.chain.Iget_chain_id_result=} [properties] Properties to set
                 */
                function get_chain_id_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_chain_id_result value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.get_chain_id_result
                 * @instance
                 */
                get_chain_id_result.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new get_chain_id_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {koinos.chain.Iget_chain_id_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_chain_id_result} get_chain_id_result instance
                 */
                get_chain_id_result.create = function create(properties) {
                    return new get_chain_id_result(properties);
                };
    
                /**
                 * Encodes the specified get_chain_id_result message. Does not implicitly {@link koinos.chain.get_chain_id_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {koinos.chain.Iget_chain_id_result} message get_chain_id_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_chain_id_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_chain_id_result message, length delimited. Does not implicitly {@link koinos.chain.get_chain_id_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {koinos.chain.Iget_chain_id_result} message get_chain_id_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_chain_id_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_chain_id_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_chain_id_result} get_chain_id_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_chain_id_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_chain_id_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_chain_id_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_chain_id_result} get_chain_id_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_chain_id_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_chain_id_result message.
                 * @function verify
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_chain_id_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_chain_id_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_chain_id_result} get_chain_id_result
                 */
                get_chain_id_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_chain_id_result)
                        return object;
                    var message = new $root.koinos.chain.get_chain_id_result();
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_chain_id_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_chain_id_result
                 * @static
                 * @param {koinos.chain.get_chain_id_result} message get_chain_id_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_chain_id_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this get_chain_id_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_chain_id_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_chain_id_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_chain_id_result;
            })();
    
            chain.process_block_signature_arguments = (function() {
    
                /**
                 * Properties of a process_block_signature_arguments.
                 * @memberof koinos.chain
                 * @interface Iprocess_block_signature_arguments
                 * @property {Uint8Array|null} [digest] process_block_signature_arguments digest
                 * @property {koinos.protocol.Iblock_header|null} [header] process_block_signature_arguments header
                 * @property {Uint8Array|null} [signature] process_block_signature_arguments signature
                 */
    
                /**
                 * Constructs a new process_block_signature_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a process_block_signature_arguments.
                 * @implements Iprocess_block_signature_arguments
                 * @constructor
                 * @param {koinos.chain.Iprocess_block_signature_arguments=} [properties] Properties to set
                 */
                function process_block_signature_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * process_block_signature_arguments digest.
                 * @member {Uint8Array} digest
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @instance
                 */
                process_block_signature_arguments.prototype.digest = $util.newBuffer([]);
    
                /**
                 * process_block_signature_arguments header.
                 * @member {koinos.protocol.Iblock_header|null|undefined} header
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @instance
                 */
                process_block_signature_arguments.prototype.header = null;
    
                /**
                 * process_block_signature_arguments signature.
                 * @member {Uint8Array} signature
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @instance
                 */
                process_block_signature_arguments.prototype.signature = $util.newBuffer([]);
    
                /**
                 * Creates a new process_block_signature_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {koinos.chain.Iprocess_block_signature_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.process_block_signature_arguments} process_block_signature_arguments instance
                 */
                process_block_signature_arguments.create = function create(properties) {
                    return new process_block_signature_arguments(properties);
                };
    
                /**
                 * Encodes the specified process_block_signature_arguments message. Does not implicitly {@link koinos.chain.process_block_signature_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {koinos.chain.Iprocess_block_signature_arguments} message process_block_signature_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                process_block_signature_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.digest);
                    if (message.header != null && Object.hasOwnProperty.call(message, "header"))
                        $root.koinos.protocol.block_header.encode(message.header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                    return writer;
                };
    
                /**
                 * Encodes the specified process_block_signature_arguments message, length delimited. Does not implicitly {@link koinos.chain.process_block_signature_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {koinos.chain.Iprocess_block_signature_arguments} message process_block_signature_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                process_block_signature_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a process_block_signature_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.process_block_signature_arguments} process_block_signature_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                process_block_signature_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.process_block_signature_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.digest = reader.bytes();
                            break;
                        case 2:
                            message.header = $root.koinos.protocol.block_header.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.signature = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a process_block_signature_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.process_block_signature_arguments} process_block_signature_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                process_block_signature_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a process_block_signature_arguments message.
                 * @function verify
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                process_block_signature_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.digest != null && message.hasOwnProperty("digest"))
                        if (!(message.digest && typeof message.digest.length === "number" || $util.isString(message.digest)))
                            return "digest: buffer expected";
                    if (message.header != null && message.hasOwnProperty("header")) {
                        var error = $root.koinos.protocol.block_header.verify(message.header);
                        if (error)
                            return "header." + error;
                    }
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                            return "signature: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a process_block_signature_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.process_block_signature_arguments} process_block_signature_arguments
                 */
                process_block_signature_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.process_block_signature_arguments)
                        return object;
                    var message = new $root.koinos.chain.process_block_signature_arguments();
                    if (object.digest != null)
                        if (typeof object.digest === "string")
                            $util.base64.decode(object.digest, message.digest = $util.newBuffer($util.base64.length(object.digest)), 0);
                        else if (object.digest.length)
                            message.digest = object.digest;
                    if (object.header != null) {
                        if (typeof object.header !== "object")
                            throw TypeError(".koinos.chain.process_block_signature_arguments.header: object expected");
                        message.header = $root.koinos.protocol.block_header.fromObject(object.header);
                    }
                    if (object.signature != null)
                        if (typeof object.signature === "string")
                            $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                        else if (object.signature.length)
                            message.signature = object.signature;
                    return message;
                };
    
                /**
                 * Creates a plain object from a process_block_signature_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @static
                 * @param {koinos.chain.process_block_signature_arguments} message process_block_signature_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                process_block_signature_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.digest = "";
                        else {
                            object.digest = [];
                            if (options.bytes !== Array)
                                object.digest = $util.newBuffer(object.digest);
                        }
                        object.header = null;
                        if (options.bytes === String)
                            object.signature = "";
                        else {
                            object.signature = [];
                            if (options.bytes !== Array)
                                object.signature = $util.newBuffer(object.signature);
                        }
                    }
                    if (message.digest != null && message.hasOwnProperty("digest"))
                        object.digest = options.bytes === String ? $util.base64.encode(message.digest, 0, message.digest.length) : options.bytes === Array ? Array.prototype.slice.call(message.digest) : message.digest;
                    if (message.header != null && message.hasOwnProperty("header"))
                        object.header = $root.koinos.protocol.block_header.toObject(message.header, options);
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                    return object;
                };
    
                /**
                 * Converts this process_block_signature_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.process_block_signature_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                process_block_signature_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return process_block_signature_arguments;
            })();
    
            chain.process_block_signature_result = (function() {
    
                /**
                 * Properties of a process_block_signature_result.
                 * @memberof koinos.chain
                 * @interface Iprocess_block_signature_result
                 * @property {boolean|null} [value] process_block_signature_result value
                 */
    
                /**
                 * Constructs a new process_block_signature_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a process_block_signature_result.
                 * @implements Iprocess_block_signature_result
                 * @constructor
                 * @param {koinos.chain.Iprocess_block_signature_result=} [properties] Properties to set
                 */
                function process_block_signature_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * process_block_signature_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.process_block_signature_result
                 * @instance
                 */
                process_block_signature_result.prototype.value = false;
    
                /**
                 * Creates a new process_block_signature_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {koinos.chain.Iprocess_block_signature_result=} [properties] Properties to set
                 * @returns {koinos.chain.process_block_signature_result} process_block_signature_result instance
                 */
                process_block_signature_result.create = function create(properties) {
                    return new process_block_signature_result(properties);
                };
    
                /**
                 * Encodes the specified process_block_signature_result message. Does not implicitly {@link koinos.chain.process_block_signature_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {koinos.chain.Iprocess_block_signature_result} message process_block_signature_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                process_block_signature_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified process_block_signature_result message, length delimited. Does not implicitly {@link koinos.chain.process_block_signature_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {koinos.chain.Iprocess_block_signature_result} message process_block_signature_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                process_block_signature_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a process_block_signature_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.process_block_signature_result} process_block_signature_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                process_block_signature_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.process_block_signature_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a process_block_signature_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.process_block_signature_result} process_block_signature_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                process_block_signature_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a process_block_signature_result message.
                 * @function verify
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                process_block_signature_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a process_block_signature_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.process_block_signature_result} process_block_signature_result
                 */
                process_block_signature_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.process_block_signature_result)
                        return object;
                    var message = new $root.koinos.chain.process_block_signature_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a process_block_signature_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.process_block_signature_result
                 * @static
                 * @param {koinos.chain.process_block_signature_result} message process_block_signature_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                process_block_signature_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this process_block_signature_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.process_block_signature_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                process_block_signature_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return process_block_signature_result;
            })();
    
            chain.get_transaction_arguments = (function() {
    
                /**
                 * Properties of a get_transaction_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_transaction_arguments
                 */
    
                /**
                 * Constructs a new get_transaction_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_transaction_arguments.
                 * @implements Iget_transaction_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_transaction_arguments=} [properties] Properties to set
                 */
                function get_transaction_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_transaction_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {koinos.chain.Iget_transaction_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_transaction_arguments} get_transaction_arguments instance
                 */
                get_transaction_arguments.create = function create(properties) {
                    return new get_transaction_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_transaction_arguments message. Does not implicitly {@link koinos.chain.get_transaction_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {koinos.chain.Iget_transaction_arguments} message get_transaction_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_transaction_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_transaction_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {koinos.chain.Iget_transaction_arguments} message get_transaction_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_transaction_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_transaction_arguments} get_transaction_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_transaction_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_transaction_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_transaction_arguments} get_transaction_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_transaction_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_transaction_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_transaction_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_transaction_arguments} get_transaction_arguments
                 */
                get_transaction_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_transaction_arguments)
                        return object;
                    return new $root.koinos.chain.get_transaction_arguments();
                };
    
                /**
                 * Creates a plain object from a get_transaction_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_transaction_arguments
                 * @static
                 * @param {koinos.chain.get_transaction_arguments} message get_transaction_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_transaction_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_transaction_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_transaction_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_transaction_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_transaction_arguments;
            })();
    
            chain.get_transaction_result = (function() {
    
                /**
                 * Properties of a get_transaction_result.
                 * @memberof koinos.chain
                 * @interface Iget_transaction_result
                 * @property {koinos.protocol.Itransaction|null} [value] get_transaction_result value
                 */
    
                /**
                 * Constructs a new get_transaction_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_transaction_result.
                 * @implements Iget_transaction_result
                 * @constructor
                 * @param {koinos.chain.Iget_transaction_result=} [properties] Properties to set
                 */
                function get_transaction_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_transaction_result value.
                 * @member {koinos.protocol.Itransaction|null|undefined} value
                 * @memberof koinos.chain.get_transaction_result
                 * @instance
                 */
                get_transaction_result.prototype.value = null;
    
                /**
                 * Creates a new get_transaction_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {koinos.chain.Iget_transaction_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_transaction_result} get_transaction_result instance
                 */
                get_transaction_result.create = function create(properties) {
                    return new get_transaction_result(properties);
                };
    
                /**
                 * Encodes the specified get_transaction_result message. Does not implicitly {@link koinos.chain.get_transaction_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {koinos.chain.Iget_transaction_result} message get_transaction_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.protocol.transaction.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_transaction_result message, length delimited. Does not implicitly {@link koinos.chain.get_transaction_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {koinos.chain.Iget_transaction_result} message get_transaction_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_transaction_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_transaction_result} get_transaction_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_transaction_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.protocol.transaction.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_transaction_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_transaction_result} get_transaction_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_transaction_result message.
                 * @function verify
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_transaction_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.protocol.transaction.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_transaction_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_transaction_result} get_transaction_result
                 */
                get_transaction_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_transaction_result)
                        return object;
                    var message = new $root.koinos.chain.get_transaction_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_transaction_result.value: object expected");
                        message.value = $root.koinos.protocol.transaction.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_transaction_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_transaction_result
                 * @static
                 * @param {koinos.chain.get_transaction_result} message get_transaction_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_transaction_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.protocol.transaction.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_transaction_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_transaction_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_transaction_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_transaction_result;
            })();
    
            /**
             * system_authorization_type enum.
             * @name koinos.chain.system_authorization_type
             * @enum {number}
             * @property {number} set_system_contract=0 set_system_contract value
             * @property {number} set_system_call=1 set_system_call value
             */
            chain.system_authorization_type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "set_system_contract"] = 0;
                values[valuesById[1] = "set_system_call"] = 1;
                return values;
            })();
    
            chain.get_transaction_field_arguments = (function() {
    
                /**
                 * Properties of a get_transaction_field_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_transaction_field_arguments
                 * @property {string|null} [field] get_transaction_field_arguments field
                 */
    
                /**
                 * Constructs a new get_transaction_field_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_transaction_field_arguments.
                 * @implements Iget_transaction_field_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_transaction_field_arguments=} [properties] Properties to set
                 */
                function get_transaction_field_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_transaction_field_arguments field.
                 * @member {string} field
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @instance
                 */
                get_transaction_field_arguments.prototype.field = "";
    
                /**
                 * Creates a new get_transaction_field_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {koinos.chain.Iget_transaction_field_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_transaction_field_arguments} get_transaction_field_arguments instance
                 */
                get_transaction_field_arguments.create = function create(properties) {
                    return new get_transaction_field_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_transaction_field_arguments message. Does not implicitly {@link koinos.chain.get_transaction_field_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {koinos.chain.Iget_transaction_field_arguments} message get_transaction_field_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_field_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.field != null && Object.hasOwnProperty.call(message, "field"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.field);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_transaction_field_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_transaction_field_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {koinos.chain.Iget_transaction_field_arguments} message get_transaction_field_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_field_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_transaction_field_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_transaction_field_arguments} get_transaction_field_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_field_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_transaction_field_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.field = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_transaction_field_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_transaction_field_arguments} get_transaction_field_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_field_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_transaction_field_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_transaction_field_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.field != null && message.hasOwnProperty("field"))
                        if (!$util.isString(message.field))
                            return "field: string expected";
                    return null;
                };
    
                /**
                 * Creates a get_transaction_field_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_transaction_field_arguments} get_transaction_field_arguments
                 */
                get_transaction_field_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_transaction_field_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_transaction_field_arguments();
                    if (object.field != null)
                        message.field = String(object.field);
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_transaction_field_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @static
                 * @param {koinos.chain.get_transaction_field_arguments} message get_transaction_field_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_transaction_field_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.field = "";
                    if (message.field != null && message.hasOwnProperty("field"))
                        object.field = message.field;
                    return object;
                };
    
                /**
                 * Converts this get_transaction_field_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_transaction_field_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_transaction_field_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_transaction_field_arguments;
            })();
    
            chain.get_transaction_field_result = (function() {
    
                /**
                 * Properties of a get_transaction_field_result.
                 * @memberof koinos.chain
                 * @interface Iget_transaction_field_result
                 * @property {koinos.chain.Ivalue_type|null} [value] get_transaction_field_result value
                 */
    
                /**
                 * Constructs a new get_transaction_field_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_transaction_field_result.
                 * @implements Iget_transaction_field_result
                 * @constructor
                 * @param {koinos.chain.Iget_transaction_field_result=} [properties] Properties to set
                 */
                function get_transaction_field_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_transaction_field_result value.
                 * @member {koinos.chain.Ivalue_type|null|undefined} value
                 * @memberof koinos.chain.get_transaction_field_result
                 * @instance
                 */
                get_transaction_field_result.prototype.value = null;
    
                /**
                 * Creates a new get_transaction_field_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {koinos.chain.Iget_transaction_field_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_transaction_field_result} get_transaction_field_result instance
                 */
                get_transaction_field_result.create = function create(properties) {
                    return new get_transaction_field_result(properties);
                };
    
                /**
                 * Encodes the specified get_transaction_field_result message. Does not implicitly {@link koinos.chain.get_transaction_field_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {koinos.chain.Iget_transaction_field_result} message get_transaction_field_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_field_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.value_type.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_transaction_field_result message, length delimited. Does not implicitly {@link koinos.chain.get_transaction_field_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {koinos.chain.Iget_transaction_field_result} message get_transaction_field_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_transaction_field_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_transaction_field_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_transaction_field_result} get_transaction_field_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_field_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_transaction_field_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.value_type.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_transaction_field_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_transaction_field_result} get_transaction_field_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_transaction_field_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_transaction_field_result message.
                 * @function verify
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_transaction_field_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.value_type.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_transaction_field_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_transaction_field_result} get_transaction_field_result
                 */
                get_transaction_field_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_transaction_field_result)
                        return object;
                    var message = new $root.koinos.chain.get_transaction_field_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_transaction_field_result.value: object expected");
                        message.value = $root.koinos.chain.value_type.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_transaction_field_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_transaction_field_result
                 * @static
                 * @param {koinos.chain.get_transaction_field_result} message get_transaction_field_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_transaction_field_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.value_type.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_transaction_field_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_transaction_field_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_transaction_field_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_transaction_field_result;
            })();
    
            chain.get_block_arguments = (function() {
    
                /**
                 * Properties of a get_block_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_block_arguments
                 */
    
                /**
                 * Constructs a new get_block_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_block_arguments.
                 * @implements Iget_block_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_block_arguments=} [properties] Properties to set
                 */
                function get_block_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_block_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {koinos.chain.Iget_block_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_block_arguments} get_block_arguments instance
                 */
                get_block_arguments.create = function create(properties) {
                    return new get_block_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_block_arguments message. Does not implicitly {@link koinos.chain.get_block_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {koinos.chain.Iget_block_arguments} message get_block_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_block_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_block_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {koinos.chain.Iget_block_arguments} message get_block_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_block_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_block_arguments} get_block_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_block_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_block_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_block_arguments} get_block_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_block_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_block_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_block_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_block_arguments} get_block_arguments
                 */
                get_block_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_block_arguments)
                        return object;
                    return new $root.koinos.chain.get_block_arguments();
                };
    
                /**
                 * Creates a plain object from a get_block_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_block_arguments
                 * @static
                 * @param {koinos.chain.get_block_arguments} message get_block_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_block_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_block_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_block_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_block_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_block_arguments;
            })();
    
            chain.get_block_result = (function() {
    
                /**
                 * Properties of a get_block_result.
                 * @memberof koinos.chain
                 * @interface Iget_block_result
                 * @property {koinos.protocol.Iblock|null} [value] get_block_result value
                 */
    
                /**
                 * Constructs a new get_block_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_block_result.
                 * @implements Iget_block_result
                 * @constructor
                 * @param {koinos.chain.Iget_block_result=} [properties] Properties to set
                 */
                function get_block_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_block_result value.
                 * @member {koinos.protocol.Iblock|null|undefined} value
                 * @memberof koinos.chain.get_block_result
                 * @instance
                 */
                get_block_result.prototype.value = null;
    
                /**
                 * Creates a new get_block_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {koinos.chain.Iget_block_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_block_result} get_block_result instance
                 */
                get_block_result.create = function create(properties) {
                    return new get_block_result(properties);
                };
    
                /**
                 * Encodes the specified get_block_result message. Does not implicitly {@link koinos.chain.get_block_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {koinos.chain.Iget_block_result} message get_block_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.protocol.block.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_block_result message, length delimited. Does not implicitly {@link koinos.chain.get_block_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {koinos.chain.Iget_block_result} message get_block_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_block_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_block_result} get_block_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_block_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.protocol.block.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_block_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_block_result} get_block_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_block_result message.
                 * @function verify
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_block_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.protocol.block.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_block_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_block_result} get_block_result
                 */
                get_block_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_block_result)
                        return object;
                    var message = new $root.koinos.chain.get_block_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_block_result.value: object expected");
                        message.value = $root.koinos.protocol.block.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_block_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_block_result
                 * @static
                 * @param {koinos.chain.get_block_result} message get_block_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_block_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.protocol.block.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_block_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_block_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_block_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_block_result;
            })();
    
            chain.get_block_field_arguments = (function() {
    
                /**
                 * Properties of a get_block_field_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_block_field_arguments
                 * @property {string|null} [field] get_block_field_arguments field
                 */
    
                /**
                 * Constructs a new get_block_field_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_block_field_arguments.
                 * @implements Iget_block_field_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_block_field_arguments=} [properties] Properties to set
                 */
                function get_block_field_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_block_field_arguments field.
                 * @member {string} field
                 * @memberof koinos.chain.get_block_field_arguments
                 * @instance
                 */
                get_block_field_arguments.prototype.field = "";
    
                /**
                 * Creates a new get_block_field_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {koinos.chain.Iget_block_field_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_block_field_arguments} get_block_field_arguments instance
                 */
                get_block_field_arguments.create = function create(properties) {
                    return new get_block_field_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_block_field_arguments message. Does not implicitly {@link koinos.chain.get_block_field_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {koinos.chain.Iget_block_field_arguments} message get_block_field_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_field_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.field != null && Object.hasOwnProperty.call(message, "field"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.field);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_block_field_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_block_field_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {koinos.chain.Iget_block_field_arguments} message get_block_field_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_field_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_block_field_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_block_field_arguments} get_block_field_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_field_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_block_field_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.field = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_block_field_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_block_field_arguments} get_block_field_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_field_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_block_field_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_block_field_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.field != null && message.hasOwnProperty("field"))
                        if (!$util.isString(message.field))
                            return "field: string expected";
                    return null;
                };
    
                /**
                 * Creates a get_block_field_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_block_field_arguments} get_block_field_arguments
                 */
                get_block_field_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_block_field_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_block_field_arguments();
                    if (object.field != null)
                        message.field = String(object.field);
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_block_field_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_block_field_arguments
                 * @static
                 * @param {koinos.chain.get_block_field_arguments} message get_block_field_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_block_field_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.field = "";
                    if (message.field != null && message.hasOwnProperty("field"))
                        object.field = message.field;
                    return object;
                };
    
                /**
                 * Converts this get_block_field_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_block_field_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_block_field_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_block_field_arguments;
            })();
    
            chain.get_block_field_result = (function() {
    
                /**
                 * Properties of a get_block_field_result.
                 * @memberof koinos.chain
                 * @interface Iget_block_field_result
                 * @property {koinos.chain.Ivalue_type|null} [value] get_block_field_result value
                 */
    
                /**
                 * Constructs a new get_block_field_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_block_field_result.
                 * @implements Iget_block_field_result
                 * @constructor
                 * @param {koinos.chain.Iget_block_field_result=} [properties] Properties to set
                 */
                function get_block_field_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_block_field_result value.
                 * @member {koinos.chain.Ivalue_type|null|undefined} value
                 * @memberof koinos.chain.get_block_field_result
                 * @instance
                 */
                get_block_field_result.prototype.value = null;
    
                /**
                 * Creates a new get_block_field_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {koinos.chain.Iget_block_field_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_block_field_result} get_block_field_result instance
                 */
                get_block_field_result.create = function create(properties) {
                    return new get_block_field_result(properties);
                };
    
                /**
                 * Encodes the specified get_block_field_result message. Does not implicitly {@link koinos.chain.get_block_field_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {koinos.chain.Iget_block_field_result} message get_block_field_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_field_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.value_type.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_block_field_result message, length delimited. Does not implicitly {@link koinos.chain.get_block_field_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {koinos.chain.Iget_block_field_result} message get_block_field_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_block_field_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_block_field_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_block_field_result} get_block_field_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_field_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_block_field_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.value_type.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_block_field_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_block_field_result} get_block_field_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_block_field_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_block_field_result message.
                 * @function verify
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_block_field_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.value_type.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_block_field_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_block_field_result} get_block_field_result
                 */
                get_block_field_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_block_field_result)
                        return object;
                    var message = new $root.koinos.chain.get_block_field_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_block_field_result.value: object expected");
                        message.value = $root.koinos.chain.value_type.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_block_field_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_block_field_result
                 * @static
                 * @param {koinos.chain.get_block_field_result} message get_block_field_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_block_field_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.value_type.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_block_field_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_block_field_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_block_field_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_block_field_result;
            })();
    
            chain.get_last_irreversible_block_arguments = (function() {
    
                /**
                 * Properties of a get_last_irreversible_block_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_last_irreversible_block_arguments
                 */
    
                /**
                 * Constructs a new get_last_irreversible_block_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_last_irreversible_block_arguments.
                 * @implements Iget_last_irreversible_block_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_last_irreversible_block_arguments=} [properties] Properties to set
                 */
                function get_last_irreversible_block_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_last_irreversible_block_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {koinos.chain.Iget_last_irreversible_block_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_last_irreversible_block_arguments} get_last_irreversible_block_arguments instance
                 */
                get_last_irreversible_block_arguments.create = function create(properties) {
                    return new get_last_irreversible_block_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_last_irreversible_block_arguments message. Does not implicitly {@link koinos.chain.get_last_irreversible_block_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {koinos.chain.Iget_last_irreversible_block_arguments} message get_last_irreversible_block_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_last_irreversible_block_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_last_irreversible_block_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_last_irreversible_block_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {koinos.chain.Iget_last_irreversible_block_arguments} message get_last_irreversible_block_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_last_irreversible_block_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_last_irreversible_block_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_last_irreversible_block_arguments} get_last_irreversible_block_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_last_irreversible_block_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_last_irreversible_block_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_last_irreversible_block_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_last_irreversible_block_arguments} get_last_irreversible_block_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_last_irreversible_block_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_last_irreversible_block_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_last_irreversible_block_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_last_irreversible_block_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_last_irreversible_block_arguments} get_last_irreversible_block_arguments
                 */
                get_last_irreversible_block_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_last_irreversible_block_arguments)
                        return object;
                    return new $root.koinos.chain.get_last_irreversible_block_arguments();
                };
    
                /**
                 * Creates a plain object from a get_last_irreversible_block_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @static
                 * @param {koinos.chain.get_last_irreversible_block_arguments} message get_last_irreversible_block_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_last_irreversible_block_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_last_irreversible_block_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_last_irreversible_block_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_last_irreversible_block_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_last_irreversible_block_arguments;
            })();
    
            chain.get_last_irreversible_block_result = (function() {
    
                /**
                 * Properties of a get_last_irreversible_block_result.
                 * @memberof koinos.chain
                 * @interface Iget_last_irreversible_block_result
                 * @property {number|Long|null} [value] get_last_irreversible_block_result value
                 */
    
                /**
                 * Constructs a new get_last_irreversible_block_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_last_irreversible_block_result.
                 * @implements Iget_last_irreversible_block_result
                 * @constructor
                 * @param {koinos.chain.Iget_last_irreversible_block_result=} [properties] Properties to set
                 */
                function get_last_irreversible_block_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_last_irreversible_block_result value.
                 * @member {number|Long} value
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @instance
                 */
                get_last_irreversible_block_result.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new get_last_irreversible_block_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {koinos.chain.Iget_last_irreversible_block_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_last_irreversible_block_result} get_last_irreversible_block_result instance
                 */
                get_last_irreversible_block_result.create = function create(properties) {
                    return new get_last_irreversible_block_result(properties);
                };
    
                /**
                 * Encodes the specified get_last_irreversible_block_result message. Does not implicitly {@link koinos.chain.get_last_irreversible_block_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {koinos.chain.Iget_last_irreversible_block_result} message get_last_irreversible_block_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_last_irreversible_block_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_last_irreversible_block_result message, length delimited. Does not implicitly {@link koinos.chain.get_last_irreversible_block_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {koinos.chain.Iget_last_irreversible_block_result} message get_last_irreversible_block_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_last_irreversible_block_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_last_irreversible_block_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_last_irreversible_block_result} get_last_irreversible_block_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_last_irreversible_block_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_last_irreversible_block_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_last_irreversible_block_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_last_irreversible_block_result} get_last_irreversible_block_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_last_irreversible_block_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_last_irreversible_block_result message.
                 * @function verify
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_last_irreversible_block_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                            return "value: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a get_last_irreversible_block_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_last_irreversible_block_result} get_last_irreversible_block_result
                 */
                get_last_irreversible_block_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_last_irreversible_block_result)
                        return object;
                    var message = new $root.koinos.chain.get_last_irreversible_block_result();
                    if (object.value != null)
                        if ($util.Long)
                            (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                        else if (typeof object.value === "string")
                            message.value = parseInt(object.value, 10);
                        else if (typeof object.value === "number")
                            message.value = object.value;
                        else if (typeof object.value === "object")
                            message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_last_irreversible_block_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @static
                 * @param {koinos.chain.get_last_irreversible_block_result} message get_last_irreversible_block_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_last_irreversible_block_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.value = options.longs === String ? "0" : 0;
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value === "number")
                            object.value = options.longs === String ? String(message.value) : message.value;
                        else
                            object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                    return object;
                };
    
                /**
                 * Converts this get_last_irreversible_block_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_last_irreversible_block_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_last_irreversible_block_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_last_irreversible_block_result;
            })();
    
            chain.get_account_nonce_arguments = (function() {
    
                /**
                 * Properties of a get_account_nonce_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_account_nonce_arguments
                 * @property {Uint8Array|null} [account] get_account_nonce_arguments account
                 */
    
                /**
                 * Constructs a new get_account_nonce_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_account_nonce_arguments.
                 * @implements Iget_account_nonce_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_account_nonce_arguments=} [properties] Properties to set
                 */
                function get_account_nonce_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_account_nonce_arguments account.
                 * @member {Uint8Array} account
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @instance
                 */
                get_account_nonce_arguments.prototype.account = $util.newBuffer([]);
    
                /**
                 * Creates a new get_account_nonce_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iget_account_nonce_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_account_nonce_arguments} get_account_nonce_arguments instance
                 */
                get_account_nonce_arguments.create = function create(properties) {
                    return new get_account_nonce_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_account_nonce_arguments message. Does not implicitly {@link koinos.chain.get_account_nonce_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iget_account_nonce_arguments} message get_account_nonce_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_nonce_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_account_nonce_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_account_nonce_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iget_account_nonce_arguments} message get_account_nonce_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_nonce_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_account_nonce_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_account_nonce_arguments} get_account_nonce_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_nonce_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_account_nonce_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.account = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_account_nonce_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_account_nonce_arguments} get_account_nonce_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_nonce_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_account_nonce_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_account_nonce_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_account_nonce_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_account_nonce_arguments} get_account_nonce_arguments
                 */
                get_account_nonce_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_account_nonce_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_account_nonce_arguments();
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_account_nonce_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.get_account_nonce_arguments} message get_account_nonce_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_account_nonce_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    return object;
                };
    
                /**
                 * Converts this get_account_nonce_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_account_nonce_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_account_nonce_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_account_nonce_arguments;
            })();
    
            chain.get_account_nonce_result = (function() {
    
                /**
                 * Properties of a get_account_nonce_result.
                 * @memberof koinos.chain
                 * @interface Iget_account_nonce_result
                 * @property {Uint8Array|null} [value] get_account_nonce_result value
                 */
    
                /**
                 * Constructs a new get_account_nonce_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_account_nonce_result.
                 * @implements Iget_account_nonce_result
                 * @constructor
                 * @param {koinos.chain.Iget_account_nonce_result=} [properties] Properties to set
                 */
                function get_account_nonce_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_account_nonce_result value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.get_account_nonce_result
                 * @instance
                 */
                get_account_nonce_result.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new get_account_nonce_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iget_account_nonce_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_account_nonce_result} get_account_nonce_result instance
                 */
                get_account_nonce_result.create = function create(properties) {
                    return new get_account_nonce_result(properties);
                };
    
                /**
                 * Encodes the specified get_account_nonce_result message. Does not implicitly {@link koinos.chain.get_account_nonce_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iget_account_nonce_result} message get_account_nonce_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_nonce_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_account_nonce_result message, length delimited. Does not implicitly {@link koinos.chain.get_account_nonce_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iget_account_nonce_result} message get_account_nonce_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_nonce_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_account_nonce_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_account_nonce_result} get_account_nonce_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_nonce_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_account_nonce_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_account_nonce_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_account_nonce_result} get_account_nonce_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_nonce_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_account_nonce_result message.
                 * @function verify
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_account_nonce_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_account_nonce_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_account_nonce_result} get_account_nonce_result
                 */
                get_account_nonce_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_account_nonce_result)
                        return object;
                    var message = new $root.koinos.chain.get_account_nonce_result();
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_account_nonce_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_account_nonce_result
                 * @static
                 * @param {koinos.chain.get_account_nonce_result} message get_account_nonce_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_account_nonce_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this get_account_nonce_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_account_nonce_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_account_nonce_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_account_nonce_result;
            })();
    
            chain.verify_account_nonce_arguments = (function() {
    
                /**
                 * Properties of a verify_account_nonce_arguments.
                 * @memberof koinos.chain
                 * @interface Iverify_account_nonce_arguments
                 * @property {Uint8Array|null} [account] verify_account_nonce_arguments account
                 * @property {Uint8Array|null} [nonce] verify_account_nonce_arguments nonce
                 */
    
                /**
                 * Constructs a new verify_account_nonce_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_account_nonce_arguments.
                 * @implements Iverify_account_nonce_arguments
                 * @constructor
                 * @param {koinos.chain.Iverify_account_nonce_arguments=} [properties] Properties to set
                 */
                function verify_account_nonce_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_account_nonce_arguments account.
                 * @member {Uint8Array} account
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @instance
                 */
                verify_account_nonce_arguments.prototype.account = $util.newBuffer([]);
    
                /**
                 * verify_account_nonce_arguments nonce.
                 * @member {Uint8Array} nonce
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @instance
                 */
                verify_account_nonce_arguments.prototype.nonce = $util.newBuffer([]);
    
                /**
                 * Creates a new verify_account_nonce_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iverify_account_nonce_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.verify_account_nonce_arguments} verify_account_nonce_arguments instance
                 */
                verify_account_nonce_arguments.create = function create(properties) {
                    return new verify_account_nonce_arguments(properties);
                };
    
                /**
                 * Encodes the specified verify_account_nonce_arguments message. Does not implicitly {@link koinos.chain.verify_account_nonce_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iverify_account_nonce_arguments} message verify_account_nonce_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_account_nonce_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                    if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_account_nonce_arguments message, length delimited. Does not implicitly {@link koinos.chain.verify_account_nonce_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iverify_account_nonce_arguments} message verify_account_nonce_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_account_nonce_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_account_nonce_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_account_nonce_arguments} verify_account_nonce_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_account_nonce_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_account_nonce_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.account = reader.bytes();
                            break;
                        case 2:
                            message.nonce = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_account_nonce_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_account_nonce_arguments} verify_account_nonce_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_account_nonce_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_account_nonce_arguments message.
                 * @function verify
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_account_nonce_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                            return "nonce: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a verify_account_nonce_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_account_nonce_arguments} verify_account_nonce_arguments
                 */
                verify_account_nonce_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_account_nonce_arguments)
                        return object;
                    var message = new $root.koinos.chain.verify_account_nonce_arguments();
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    if (object.nonce != null)
                        if (typeof object.nonce === "string")
                            $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                        else if (object.nonce.length)
                            message.nonce = object.nonce;
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_account_nonce_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.verify_account_nonce_arguments} message verify_account_nonce_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_account_nonce_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                        if (options.bytes === String)
                            object.nonce = "";
                        else {
                            object.nonce = [];
                            if (options.bytes !== Array)
                                object.nonce = $util.newBuffer(object.nonce);
                        }
                    }
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                    return object;
                };
    
                /**
                 * Converts this verify_account_nonce_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_account_nonce_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_account_nonce_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_account_nonce_arguments;
            })();
    
            chain.verify_account_nonce_result = (function() {
    
                /**
                 * Properties of a verify_account_nonce_result.
                 * @memberof koinos.chain
                 * @interface Iverify_account_nonce_result
                 * @property {boolean|null} [value] verify_account_nonce_result value
                 */
    
                /**
                 * Constructs a new verify_account_nonce_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_account_nonce_result.
                 * @implements Iverify_account_nonce_result
                 * @constructor
                 * @param {koinos.chain.Iverify_account_nonce_result=} [properties] Properties to set
                 */
                function verify_account_nonce_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_account_nonce_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @instance
                 */
                verify_account_nonce_result.prototype.value = false;
    
                /**
                 * Creates a new verify_account_nonce_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iverify_account_nonce_result=} [properties] Properties to set
                 * @returns {koinos.chain.verify_account_nonce_result} verify_account_nonce_result instance
                 */
                verify_account_nonce_result.create = function create(properties) {
                    return new verify_account_nonce_result(properties);
                };
    
                /**
                 * Encodes the specified verify_account_nonce_result message. Does not implicitly {@link koinos.chain.verify_account_nonce_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iverify_account_nonce_result} message verify_account_nonce_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_account_nonce_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_account_nonce_result message, length delimited. Does not implicitly {@link koinos.chain.verify_account_nonce_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iverify_account_nonce_result} message verify_account_nonce_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_account_nonce_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_account_nonce_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_account_nonce_result} verify_account_nonce_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_account_nonce_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_account_nonce_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_account_nonce_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_account_nonce_result} verify_account_nonce_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_account_nonce_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_account_nonce_result message.
                 * @function verify
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_account_nonce_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a verify_account_nonce_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_account_nonce_result} verify_account_nonce_result
                 */
                verify_account_nonce_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_account_nonce_result)
                        return object;
                    var message = new $root.koinos.chain.verify_account_nonce_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_account_nonce_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @static
                 * @param {koinos.chain.verify_account_nonce_result} message verify_account_nonce_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_account_nonce_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this verify_account_nonce_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_account_nonce_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_account_nonce_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_account_nonce_result;
            })();
    
            chain.set_account_nonce_arguments = (function() {
    
                /**
                 * Properties of a set_account_nonce_arguments.
                 * @memberof koinos.chain
                 * @interface Iset_account_nonce_arguments
                 * @property {Uint8Array|null} [account] set_account_nonce_arguments account
                 * @property {Uint8Array|null} [nonce] set_account_nonce_arguments nonce
                 */
    
                /**
                 * Constructs a new set_account_nonce_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a set_account_nonce_arguments.
                 * @implements Iset_account_nonce_arguments
                 * @constructor
                 * @param {koinos.chain.Iset_account_nonce_arguments=} [properties] Properties to set
                 */
                function set_account_nonce_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * set_account_nonce_arguments account.
                 * @member {Uint8Array} account
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @instance
                 */
                set_account_nonce_arguments.prototype.account = $util.newBuffer([]);
    
                /**
                 * set_account_nonce_arguments nonce.
                 * @member {Uint8Array} nonce
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @instance
                 */
                set_account_nonce_arguments.prototype.nonce = $util.newBuffer([]);
    
                /**
                 * Creates a new set_account_nonce_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iset_account_nonce_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.set_account_nonce_arguments} set_account_nonce_arguments instance
                 */
                set_account_nonce_arguments.create = function create(properties) {
                    return new set_account_nonce_arguments(properties);
                };
    
                /**
                 * Encodes the specified set_account_nonce_arguments message. Does not implicitly {@link koinos.chain.set_account_nonce_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iset_account_nonce_arguments} message set_account_nonce_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_account_nonce_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                    if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nonce);
                    return writer;
                };
    
                /**
                 * Encodes the specified set_account_nonce_arguments message, length delimited. Does not implicitly {@link koinos.chain.set_account_nonce_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.Iset_account_nonce_arguments} message set_account_nonce_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_account_nonce_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a set_account_nonce_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.set_account_nonce_arguments} set_account_nonce_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_account_nonce_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.set_account_nonce_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.account = reader.bytes();
                            break;
                        case 2:
                            message.nonce = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a set_account_nonce_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.set_account_nonce_arguments} set_account_nonce_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_account_nonce_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a set_account_nonce_arguments message.
                 * @function verify
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                set_account_nonce_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (!(message.nonce && typeof message.nonce.length === "number" || $util.isString(message.nonce)))
                            return "nonce: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a set_account_nonce_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.set_account_nonce_arguments} set_account_nonce_arguments
                 */
                set_account_nonce_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.set_account_nonce_arguments)
                        return object;
                    var message = new $root.koinos.chain.set_account_nonce_arguments();
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    if (object.nonce != null)
                        if (typeof object.nonce === "string")
                            $util.base64.decode(object.nonce, message.nonce = $util.newBuffer($util.base64.length(object.nonce)), 0);
                        else if (object.nonce.length)
                            message.nonce = object.nonce;
                    return message;
                };
    
                /**
                 * Creates a plain object from a set_account_nonce_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @static
                 * @param {koinos.chain.set_account_nonce_arguments} message set_account_nonce_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                set_account_nonce_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                        if (options.bytes === String)
                            object.nonce = "";
                        else {
                            object.nonce = [];
                            if (options.bytes !== Array)
                                object.nonce = $util.newBuffer(object.nonce);
                        }
                    }
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        object.nonce = options.bytes === String ? $util.base64.encode(message.nonce, 0, message.nonce.length) : options.bytes === Array ? Array.prototype.slice.call(message.nonce) : message.nonce;
                    return object;
                };
    
                /**
                 * Converts this set_account_nonce_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.set_account_nonce_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                set_account_nonce_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return set_account_nonce_arguments;
            })();
    
            chain.set_account_nonce_result = (function() {
    
                /**
                 * Properties of a set_account_nonce_result.
                 * @memberof koinos.chain
                 * @interface Iset_account_nonce_result
                 */
    
                /**
                 * Constructs a new set_account_nonce_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a set_account_nonce_result.
                 * @implements Iset_account_nonce_result
                 * @constructor
                 * @param {koinos.chain.Iset_account_nonce_result=} [properties] Properties to set
                 */
                function set_account_nonce_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new set_account_nonce_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iset_account_nonce_result=} [properties] Properties to set
                 * @returns {koinos.chain.set_account_nonce_result} set_account_nonce_result instance
                 */
                set_account_nonce_result.create = function create(properties) {
                    return new set_account_nonce_result(properties);
                };
    
                /**
                 * Encodes the specified set_account_nonce_result message. Does not implicitly {@link koinos.chain.set_account_nonce_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iset_account_nonce_result} message set_account_nonce_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_account_nonce_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified set_account_nonce_result message, length delimited. Does not implicitly {@link koinos.chain.set_account_nonce_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {koinos.chain.Iset_account_nonce_result} message set_account_nonce_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                set_account_nonce_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a set_account_nonce_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.set_account_nonce_result} set_account_nonce_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_account_nonce_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.set_account_nonce_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a set_account_nonce_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.set_account_nonce_result} set_account_nonce_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                set_account_nonce_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a set_account_nonce_result message.
                 * @function verify
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                set_account_nonce_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a set_account_nonce_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.set_account_nonce_result} set_account_nonce_result
                 */
                set_account_nonce_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.set_account_nonce_result)
                        return object;
                    return new $root.koinos.chain.set_account_nonce_result();
                };
    
                /**
                 * Creates a plain object from a set_account_nonce_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.set_account_nonce_result
                 * @static
                 * @param {koinos.chain.set_account_nonce_result} message set_account_nonce_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                set_account_nonce_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this set_account_nonce_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.set_account_nonce_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                set_account_nonce_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return set_account_nonce_result;
            })();
    
            chain.check_system_authority_arguments = (function() {
    
                /**
                 * Properties of a check_system_authority_arguments.
                 * @memberof koinos.chain
                 * @interface Icheck_system_authority_arguments
                 * @property {koinos.chain.system_authorization_type|null} [type] check_system_authority_arguments type
                 */
    
                /**
                 * Constructs a new check_system_authority_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a check_system_authority_arguments.
                 * @implements Icheck_system_authority_arguments
                 * @constructor
                 * @param {koinos.chain.Icheck_system_authority_arguments=} [properties] Properties to set
                 */
                function check_system_authority_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * check_system_authority_arguments type.
                 * @member {koinos.chain.system_authorization_type} type
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @instance
                 */
                check_system_authority_arguments.prototype.type = 0;
    
                /**
                 * Creates a new check_system_authority_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {koinos.chain.Icheck_system_authority_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.check_system_authority_arguments} check_system_authority_arguments instance
                 */
                check_system_authority_arguments.create = function create(properties) {
                    return new check_system_authority_arguments(properties);
                };
    
                /**
                 * Encodes the specified check_system_authority_arguments message. Does not implicitly {@link koinos.chain.check_system_authority_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {koinos.chain.Icheck_system_authority_arguments} message check_system_authority_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_system_authority_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    return writer;
                };
    
                /**
                 * Encodes the specified check_system_authority_arguments message, length delimited. Does not implicitly {@link koinos.chain.check_system_authority_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {koinos.chain.Icheck_system_authority_arguments} message check_system_authority_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_system_authority_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a check_system_authority_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.check_system_authority_arguments} check_system_authority_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_system_authority_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.check_system_authority_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a check_system_authority_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.check_system_authority_arguments} check_system_authority_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_system_authority_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a check_system_authority_arguments message.
                 * @function verify
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                check_system_authority_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a check_system_authority_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.check_system_authority_arguments} check_system_authority_arguments
                 */
                check_system_authority_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.check_system_authority_arguments)
                        return object;
                    var message = new $root.koinos.chain.check_system_authority_arguments();
                    switch (object.type) {
                    case "set_system_contract":
                    case 0:
                        message.type = 0;
                        break;
                    case "set_system_call":
                    case 1:
                        message.type = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a check_system_authority_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @static
                 * @param {koinos.chain.check_system_authority_arguments} message check_system_authority_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                check_system_authority_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.type = options.enums === String ? "set_system_contract" : 0;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.koinos.chain.system_authorization_type[message.type] : message.type;
                    return object;
                };
    
                /**
                 * Converts this check_system_authority_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.check_system_authority_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                check_system_authority_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return check_system_authority_arguments;
            })();
    
            chain.check_system_authority_result = (function() {
    
                /**
                 * Properties of a check_system_authority_result.
                 * @memberof koinos.chain
                 * @interface Icheck_system_authority_result
                 * @property {boolean|null} [value] check_system_authority_result value
                 */
    
                /**
                 * Constructs a new check_system_authority_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a check_system_authority_result.
                 * @implements Icheck_system_authority_result
                 * @constructor
                 * @param {koinos.chain.Icheck_system_authority_result=} [properties] Properties to set
                 */
                function check_system_authority_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * check_system_authority_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.check_system_authority_result
                 * @instance
                 */
                check_system_authority_result.prototype.value = false;
    
                /**
                 * Creates a new check_system_authority_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {koinos.chain.Icheck_system_authority_result=} [properties] Properties to set
                 * @returns {koinos.chain.check_system_authority_result} check_system_authority_result instance
                 */
                check_system_authority_result.create = function create(properties) {
                    return new check_system_authority_result(properties);
                };
    
                /**
                 * Encodes the specified check_system_authority_result message. Does not implicitly {@link koinos.chain.check_system_authority_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {koinos.chain.Icheck_system_authority_result} message check_system_authority_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_system_authority_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified check_system_authority_result message, length delimited. Does not implicitly {@link koinos.chain.check_system_authority_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {koinos.chain.Icheck_system_authority_result} message check_system_authority_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_system_authority_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a check_system_authority_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.check_system_authority_result} check_system_authority_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_system_authority_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.check_system_authority_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a check_system_authority_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.check_system_authority_result} check_system_authority_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_system_authority_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a check_system_authority_result message.
                 * @function verify
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                check_system_authority_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a check_system_authority_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.check_system_authority_result} check_system_authority_result
                 */
                check_system_authority_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.check_system_authority_result)
                        return object;
                    var message = new $root.koinos.chain.check_system_authority_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a check_system_authority_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.check_system_authority_result
                 * @static
                 * @param {koinos.chain.check_system_authority_result} message check_system_authority_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                check_system_authority_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this check_system_authority_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.check_system_authority_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                check_system_authority_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return check_system_authority_result;
            })();
    
            chain.get_operation_arguments = (function() {
    
                /**
                 * Properties of a get_operation_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_operation_arguments
                 */
    
                /**
                 * Constructs a new get_operation_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_operation_arguments.
                 * @implements Iget_operation_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_operation_arguments=} [properties] Properties to set
                 */
                function get_operation_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_operation_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {koinos.chain.Iget_operation_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_operation_arguments} get_operation_arguments instance
                 */
                get_operation_arguments.create = function create(properties) {
                    return new get_operation_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_operation_arguments message. Does not implicitly {@link koinos.chain.get_operation_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {koinos.chain.Iget_operation_arguments} message get_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_operation_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_operation_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_operation_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {koinos.chain.Iget_operation_arguments} message get_operation_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_operation_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_operation_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_operation_arguments} get_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_operation_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_operation_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_operation_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_operation_arguments} get_operation_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_operation_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_operation_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_operation_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_operation_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_operation_arguments} get_operation_arguments
                 */
                get_operation_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_operation_arguments)
                        return object;
                    return new $root.koinos.chain.get_operation_arguments();
                };
    
                /**
                 * Creates a plain object from a get_operation_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_operation_arguments
                 * @static
                 * @param {koinos.chain.get_operation_arguments} message get_operation_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_operation_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_operation_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_operation_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_operation_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_operation_arguments;
            })();
    
            chain.get_operation_result = (function() {
    
                /**
                 * Properties of a get_operation_result.
                 * @memberof koinos.chain
                 * @interface Iget_operation_result
                 * @property {koinos.protocol.Ioperation|null} [value] get_operation_result value
                 */
    
                /**
                 * Constructs a new get_operation_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_operation_result.
                 * @implements Iget_operation_result
                 * @constructor
                 * @param {koinos.chain.Iget_operation_result=} [properties] Properties to set
                 */
                function get_operation_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_operation_result value.
                 * @member {koinos.protocol.Ioperation|null|undefined} value
                 * @memberof koinos.chain.get_operation_result
                 * @instance
                 */
                get_operation_result.prototype.value = null;
    
                /**
                 * Creates a new get_operation_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {koinos.chain.Iget_operation_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_operation_result} get_operation_result instance
                 */
                get_operation_result.create = function create(properties) {
                    return new get_operation_result(properties);
                };
    
                /**
                 * Encodes the specified get_operation_result message. Does not implicitly {@link koinos.chain.get_operation_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {koinos.chain.Iget_operation_result} message get_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_operation_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.protocol.operation.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_operation_result message, length delimited. Does not implicitly {@link koinos.chain.get_operation_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {koinos.chain.Iget_operation_result} message get_operation_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_operation_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_operation_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_operation_result} get_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_operation_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_operation_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.protocol.operation.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_operation_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_operation_result} get_operation_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_operation_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_operation_result message.
                 * @function verify
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_operation_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.protocol.operation.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_operation_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_operation_result} get_operation_result
                 */
                get_operation_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_operation_result)
                        return object;
                    var message = new $root.koinos.chain.get_operation_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_operation_result.value: object expected");
                        message.value = $root.koinos.protocol.operation.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_operation_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_operation_result
                 * @static
                 * @param {koinos.chain.get_operation_result} message get_operation_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_operation_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.protocol.operation.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_operation_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_operation_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_operation_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_operation_result;
            })();
    
            chain.get_account_rc_arguments = (function() {
    
                /**
                 * Properties of a get_account_rc_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_account_rc_arguments
                 * @property {Uint8Array|null} [account] get_account_rc_arguments account
                 */
    
                /**
                 * Constructs a new get_account_rc_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_account_rc_arguments.
                 * @implements Iget_account_rc_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_account_rc_arguments=} [properties] Properties to set
                 */
                function get_account_rc_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_account_rc_arguments account.
                 * @member {Uint8Array} account
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @instance
                 */
                get_account_rc_arguments.prototype.account = $util.newBuffer([]);
    
                /**
                 * Creates a new get_account_rc_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {koinos.chain.Iget_account_rc_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_account_rc_arguments} get_account_rc_arguments instance
                 */
                get_account_rc_arguments.create = function create(properties) {
                    return new get_account_rc_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_account_rc_arguments message. Does not implicitly {@link koinos.chain.get_account_rc_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {koinos.chain.Iget_account_rc_arguments} message get_account_rc_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_rc_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_account_rc_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_account_rc_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {koinos.chain.Iget_account_rc_arguments} message get_account_rc_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_rc_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_account_rc_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_account_rc_arguments} get_account_rc_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_rc_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_account_rc_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.account = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_account_rc_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_account_rc_arguments} get_account_rc_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_rc_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_account_rc_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_account_rc_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_account_rc_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_account_rc_arguments} get_account_rc_arguments
                 */
                get_account_rc_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_account_rc_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_account_rc_arguments();
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_account_rc_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @static
                 * @param {koinos.chain.get_account_rc_arguments} message get_account_rc_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_account_rc_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    return object;
                };
    
                /**
                 * Converts this get_account_rc_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_account_rc_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_account_rc_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_account_rc_arguments;
            })();
    
            chain.get_account_rc_result = (function() {
    
                /**
                 * Properties of a get_account_rc_result.
                 * @memberof koinos.chain
                 * @interface Iget_account_rc_result
                 * @property {number|Long|null} [value] get_account_rc_result value
                 */
    
                /**
                 * Constructs a new get_account_rc_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_account_rc_result.
                 * @implements Iget_account_rc_result
                 * @constructor
                 * @param {koinos.chain.Iget_account_rc_result=} [properties] Properties to set
                 */
                function get_account_rc_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_account_rc_result value.
                 * @member {number|Long} value
                 * @memberof koinos.chain.get_account_rc_result
                 * @instance
                 */
                get_account_rc_result.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new get_account_rc_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {koinos.chain.Iget_account_rc_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_account_rc_result} get_account_rc_result instance
                 */
                get_account_rc_result.create = function create(properties) {
                    return new get_account_rc_result(properties);
                };
    
                /**
                 * Encodes the specified get_account_rc_result message. Does not implicitly {@link koinos.chain.get_account_rc_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {koinos.chain.Iget_account_rc_result} message get_account_rc_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_rc_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_account_rc_result message, length delimited. Does not implicitly {@link koinos.chain.get_account_rc_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {koinos.chain.Iget_account_rc_result} message get_account_rc_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_account_rc_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_account_rc_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_account_rc_result} get_account_rc_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_rc_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_account_rc_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_account_rc_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_account_rc_result} get_account_rc_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_account_rc_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_account_rc_result message.
                 * @function verify
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_account_rc_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                            return "value: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a get_account_rc_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_account_rc_result} get_account_rc_result
                 */
                get_account_rc_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_account_rc_result)
                        return object;
                    var message = new $root.koinos.chain.get_account_rc_result();
                    if (object.value != null)
                        if ($util.Long)
                            (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                        else if (typeof object.value === "string")
                            message.value = parseInt(object.value, 10);
                        else if (typeof object.value === "number")
                            message.value = object.value;
                        else if (typeof object.value === "object")
                            message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_account_rc_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_account_rc_result
                 * @static
                 * @param {koinos.chain.get_account_rc_result} message get_account_rc_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_account_rc_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.value = options.longs === String ? "0" : 0;
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value === "number")
                            object.value = options.longs === String ? String(message.value) : message.value;
                        else
                            object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                    return object;
                };
    
                /**
                 * Converts this get_account_rc_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_account_rc_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_account_rc_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_account_rc_result;
            })();
    
            chain.consume_account_rc_arguments = (function() {
    
                /**
                 * Properties of a consume_account_rc_arguments.
                 * @memberof koinos.chain
                 * @interface Iconsume_account_rc_arguments
                 * @property {Uint8Array|null} [account] consume_account_rc_arguments account
                 * @property {number|Long|null} [value] consume_account_rc_arguments value
                 */
    
                /**
                 * Constructs a new consume_account_rc_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a consume_account_rc_arguments.
                 * @implements Iconsume_account_rc_arguments
                 * @constructor
                 * @param {koinos.chain.Iconsume_account_rc_arguments=} [properties] Properties to set
                 */
                function consume_account_rc_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * consume_account_rc_arguments account.
                 * @member {Uint8Array} account
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @instance
                 */
                consume_account_rc_arguments.prototype.account = $util.newBuffer([]);
    
                /**
                 * consume_account_rc_arguments value.
                 * @member {number|Long} value
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @instance
                 */
                consume_account_rc_arguments.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new consume_account_rc_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {koinos.chain.Iconsume_account_rc_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.consume_account_rc_arguments} consume_account_rc_arguments instance
                 */
                consume_account_rc_arguments.create = function create(properties) {
                    return new consume_account_rc_arguments(properties);
                };
    
                /**
                 * Encodes the specified consume_account_rc_arguments message. Does not implicitly {@link koinos.chain.consume_account_rc_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {koinos.chain.Iconsume_account_rc_arguments} message consume_account_rc_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_account_rc_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified consume_account_rc_arguments message, length delimited. Does not implicitly {@link koinos.chain.consume_account_rc_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {koinos.chain.Iconsume_account_rc_arguments} message consume_account_rc_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_account_rc_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a consume_account_rc_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.consume_account_rc_arguments} consume_account_rc_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_account_rc_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.consume_account_rc_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.account = reader.bytes();
                            break;
                        case 2:
                            message.value = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a consume_account_rc_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.consume_account_rc_arguments} consume_account_rc_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_account_rc_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a consume_account_rc_arguments message.
                 * @function verify
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                consume_account_rc_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                            return "value: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a consume_account_rc_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.consume_account_rc_arguments} consume_account_rc_arguments
                 */
                consume_account_rc_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.consume_account_rc_arguments)
                        return object;
                    var message = new $root.koinos.chain.consume_account_rc_arguments();
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    if (object.value != null)
                        if ($util.Long)
                            (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                        else if (typeof object.value === "string")
                            message.value = parseInt(object.value, 10);
                        else if (typeof object.value === "number")
                            message.value = object.value;
                        else if (typeof object.value === "object")
                            message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a consume_account_rc_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @static
                 * @param {koinos.chain.consume_account_rc_arguments} message consume_account_rc_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                consume_account_rc_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.value = options.longs === String ? "0" : 0;
                    }
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value === "number")
                            object.value = options.longs === String ? String(message.value) : message.value;
                        else
                            object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                    return object;
                };
    
                /**
                 * Converts this consume_account_rc_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.consume_account_rc_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                consume_account_rc_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return consume_account_rc_arguments;
            })();
    
            chain.consume_account_rc_result = (function() {
    
                /**
                 * Properties of a consume_account_rc_result.
                 * @memberof koinos.chain
                 * @interface Iconsume_account_rc_result
                 * @property {boolean|null} [value] consume_account_rc_result value
                 */
    
                /**
                 * Constructs a new consume_account_rc_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a consume_account_rc_result.
                 * @implements Iconsume_account_rc_result
                 * @constructor
                 * @param {koinos.chain.Iconsume_account_rc_result=} [properties] Properties to set
                 */
                function consume_account_rc_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * consume_account_rc_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.consume_account_rc_result
                 * @instance
                 */
                consume_account_rc_result.prototype.value = false;
    
                /**
                 * Creates a new consume_account_rc_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {koinos.chain.Iconsume_account_rc_result=} [properties] Properties to set
                 * @returns {koinos.chain.consume_account_rc_result} consume_account_rc_result instance
                 */
                consume_account_rc_result.create = function create(properties) {
                    return new consume_account_rc_result(properties);
                };
    
                /**
                 * Encodes the specified consume_account_rc_result message. Does not implicitly {@link koinos.chain.consume_account_rc_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {koinos.chain.Iconsume_account_rc_result} message consume_account_rc_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_account_rc_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified consume_account_rc_result message, length delimited. Does not implicitly {@link koinos.chain.consume_account_rc_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {koinos.chain.Iconsume_account_rc_result} message consume_account_rc_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_account_rc_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a consume_account_rc_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.consume_account_rc_result} consume_account_rc_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_account_rc_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.consume_account_rc_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a consume_account_rc_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.consume_account_rc_result} consume_account_rc_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_account_rc_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a consume_account_rc_result message.
                 * @function verify
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                consume_account_rc_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a consume_account_rc_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.consume_account_rc_result} consume_account_rc_result
                 */
                consume_account_rc_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.consume_account_rc_result)
                        return object;
                    var message = new $root.koinos.chain.consume_account_rc_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a consume_account_rc_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.consume_account_rc_result
                 * @static
                 * @param {koinos.chain.consume_account_rc_result} message consume_account_rc_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                consume_account_rc_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this consume_account_rc_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.consume_account_rc_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                consume_account_rc_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return consume_account_rc_result;
            })();
    
            chain.get_resource_limits_arguments = (function() {
    
                /**
                 * Properties of a get_resource_limits_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_resource_limits_arguments
                 */
    
                /**
                 * Constructs a new get_resource_limits_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_resource_limits_arguments.
                 * @implements Iget_resource_limits_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_resource_limits_arguments=} [properties] Properties to set
                 */
                function get_resource_limits_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_resource_limits_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {koinos.chain.Iget_resource_limits_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_resource_limits_arguments} get_resource_limits_arguments instance
                 */
                get_resource_limits_arguments.create = function create(properties) {
                    return new get_resource_limits_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_resource_limits_arguments message. Does not implicitly {@link koinos.chain.get_resource_limits_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {koinos.chain.Iget_resource_limits_arguments} message get_resource_limits_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_resource_limits_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_resource_limits_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_resource_limits_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {koinos.chain.Iget_resource_limits_arguments} message get_resource_limits_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_resource_limits_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_resource_limits_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_resource_limits_arguments} get_resource_limits_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_resource_limits_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_resource_limits_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_resource_limits_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_resource_limits_arguments} get_resource_limits_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_resource_limits_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_resource_limits_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_resource_limits_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_resource_limits_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_resource_limits_arguments} get_resource_limits_arguments
                 */
                get_resource_limits_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_resource_limits_arguments)
                        return object;
                    return new $root.koinos.chain.get_resource_limits_arguments();
                };
    
                /**
                 * Creates a plain object from a get_resource_limits_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @static
                 * @param {koinos.chain.get_resource_limits_arguments} message get_resource_limits_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_resource_limits_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_resource_limits_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_resource_limits_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_resource_limits_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_resource_limits_arguments;
            })();
    
            chain.get_resource_limits_result = (function() {
    
                /**
                 * Properties of a get_resource_limits_result.
                 * @memberof koinos.chain
                 * @interface Iget_resource_limits_result
                 * @property {koinos.chain.Iresource_limit_data|null} [value] get_resource_limits_result value
                 */
    
                /**
                 * Constructs a new get_resource_limits_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_resource_limits_result.
                 * @implements Iget_resource_limits_result
                 * @constructor
                 * @param {koinos.chain.Iget_resource_limits_result=} [properties] Properties to set
                 */
                function get_resource_limits_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_resource_limits_result value.
                 * @member {koinos.chain.Iresource_limit_data|null|undefined} value
                 * @memberof koinos.chain.get_resource_limits_result
                 * @instance
                 */
                get_resource_limits_result.prototype.value = null;
    
                /**
                 * Creates a new get_resource_limits_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {koinos.chain.Iget_resource_limits_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_resource_limits_result} get_resource_limits_result instance
                 */
                get_resource_limits_result.create = function create(properties) {
                    return new get_resource_limits_result(properties);
                };
    
                /**
                 * Encodes the specified get_resource_limits_result message. Does not implicitly {@link koinos.chain.get_resource_limits_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {koinos.chain.Iget_resource_limits_result} message get_resource_limits_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_resource_limits_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.resource_limit_data.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_resource_limits_result message, length delimited. Does not implicitly {@link koinos.chain.get_resource_limits_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {koinos.chain.Iget_resource_limits_result} message get_resource_limits_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_resource_limits_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_resource_limits_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_resource_limits_result} get_resource_limits_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_resource_limits_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_resource_limits_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.resource_limit_data.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_resource_limits_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_resource_limits_result} get_resource_limits_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_resource_limits_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_resource_limits_result message.
                 * @function verify
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_resource_limits_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.resource_limit_data.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_resource_limits_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_resource_limits_result} get_resource_limits_result
                 */
                get_resource_limits_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_resource_limits_result)
                        return object;
                    var message = new $root.koinos.chain.get_resource_limits_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_resource_limits_result.value: object expected");
                        message.value = $root.koinos.chain.resource_limit_data.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_resource_limits_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_resource_limits_result
                 * @static
                 * @param {koinos.chain.get_resource_limits_result} message get_resource_limits_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_resource_limits_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.resource_limit_data.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_resource_limits_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_resource_limits_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_resource_limits_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_resource_limits_result;
            })();
    
            chain.consume_block_resources_arguments = (function() {
    
                /**
                 * Properties of a consume_block_resources_arguments.
                 * @memberof koinos.chain
                 * @interface Iconsume_block_resources_arguments
                 * @property {number|Long|null} [disk_storage_consumed] consume_block_resources_arguments disk_storage_consumed
                 * @property {number|Long|null} [network_bandwidth_consumed] consume_block_resources_arguments network_bandwidth_consumed
                 * @property {number|Long|null} [compute_bandwidth_consumed] consume_block_resources_arguments compute_bandwidth_consumed
                 */
    
                /**
                 * Constructs a new consume_block_resources_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a consume_block_resources_arguments.
                 * @implements Iconsume_block_resources_arguments
                 * @constructor
                 * @param {koinos.chain.Iconsume_block_resources_arguments=} [properties] Properties to set
                 */
                function consume_block_resources_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * consume_block_resources_arguments disk_storage_consumed.
                 * @member {number|Long} disk_storage_consumed
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @instance
                 */
                consume_block_resources_arguments.prototype.disk_storage_consumed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * consume_block_resources_arguments network_bandwidth_consumed.
                 * @member {number|Long} network_bandwidth_consumed
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @instance
                 */
                consume_block_resources_arguments.prototype.network_bandwidth_consumed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * consume_block_resources_arguments compute_bandwidth_consumed.
                 * @member {number|Long} compute_bandwidth_consumed
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @instance
                 */
                consume_block_resources_arguments.prototype.compute_bandwidth_consumed = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new consume_block_resources_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {koinos.chain.Iconsume_block_resources_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.consume_block_resources_arguments} consume_block_resources_arguments instance
                 */
                consume_block_resources_arguments.create = function create(properties) {
                    return new consume_block_resources_arguments(properties);
                };
    
                /**
                 * Encodes the specified consume_block_resources_arguments message. Does not implicitly {@link koinos.chain.consume_block_resources_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {koinos.chain.Iconsume_block_resources_arguments} message consume_block_resources_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_block_resources_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.disk_storage_consumed != null && Object.hasOwnProperty.call(message, "disk_storage_consumed"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.disk_storage_consumed);
                    if (message.network_bandwidth_consumed != null && Object.hasOwnProperty.call(message, "network_bandwidth_consumed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.network_bandwidth_consumed);
                    if (message.compute_bandwidth_consumed != null && Object.hasOwnProperty.call(message, "compute_bandwidth_consumed"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.compute_bandwidth_consumed);
                    return writer;
                };
    
                /**
                 * Encodes the specified consume_block_resources_arguments message, length delimited. Does not implicitly {@link koinos.chain.consume_block_resources_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {koinos.chain.Iconsume_block_resources_arguments} message consume_block_resources_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_block_resources_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a consume_block_resources_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.consume_block_resources_arguments} consume_block_resources_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_block_resources_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.consume_block_resources_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.disk_storage_consumed = reader.uint64();
                            break;
                        case 2:
                            message.network_bandwidth_consumed = reader.uint64();
                            break;
                        case 3:
                            message.compute_bandwidth_consumed = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a consume_block_resources_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.consume_block_resources_arguments} consume_block_resources_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_block_resources_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a consume_block_resources_arguments message.
                 * @function verify
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                consume_block_resources_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.disk_storage_consumed != null && message.hasOwnProperty("disk_storage_consumed"))
                        if (!$util.isInteger(message.disk_storage_consumed) && !(message.disk_storage_consumed && $util.isInteger(message.disk_storage_consumed.low) && $util.isInteger(message.disk_storage_consumed.high)))
                            return "disk_storage_consumed: integer|Long expected";
                    if (message.network_bandwidth_consumed != null && message.hasOwnProperty("network_bandwidth_consumed"))
                        if (!$util.isInteger(message.network_bandwidth_consumed) && !(message.network_bandwidth_consumed && $util.isInteger(message.network_bandwidth_consumed.low) && $util.isInteger(message.network_bandwidth_consumed.high)))
                            return "network_bandwidth_consumed: integer|Long expected";
                    if (message.compute_bandwidth_consumed != null && message.hasOwnProperty("compute_bandwidth_consumed"))
                        if (!$util.isInteger(message.compute_bandwidth_consumed) && !(message.compute_bandwidth_consumed && $util.isInteger(message.compute_bandwidth_consumed.low) && $util.isInteger(message.compute_bandwidth_consumed.high)))
                            return "compute_bandwidth_consumed: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a consume_block_resources_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.consume_block_resources_arguments} consume_block_resources_arguments
                 */
                consume_block_resources_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.consume_block_resources_arguments)
                        return object;
                    var message = new $root.koinos.chain.consume_block_resources_arguments();
                    if (object.disk_storage_consumed != null)
                        if ($util.Long)
                            (message.disk_storage_consumed = $util.Long.fromValue(object.disk_storage_consumed)).unsigned = true;
                        else if (typeof object.disk_storage_consumed === "string")
                            message.disk_storage_consumed = parseInt(object.disk_storage_consumed, 10);
                        else if (typeof object.disk_storage_consumed === "number")
                            message.disk_storage_consumed = object.disk_storage_consumed;
                        else if (typeof object.disk_storage_consumed === "object")
                            message.disk_storage_consumed = new $util.LongBits(object.disk_storage_consumed.low >>> 0, object.disk_storage_consumed.high >>> 0).toNumber(true);
                    if (object.network_bandwidth_consumed != null)
                        if ($util.Long)
                            (message.network_bandwidth_consumed = $util.Long.fromValue(object.network_bandwidth_consumed)).unsigned = true;
                        else if (typeof object.network_bandwidth_consumed === "string")
                            message.network_bandwidth_consumed = parseInt(object.network_bandwidth_consumed, 10);
                        else if (typeof object.network_bandwidth_consumed === "number")
                            message.network_bandwidth_consumed = object.network_bandwidth_consumed;
                        else if (typeof object.network_bandwidth_consumed === "object")
                            message.network_bandwidth_consumed = new $util.LongBits(object.network_bandwidth_consumed.low >>> 0, object.network_bandwidth_consumed.high >>> 0).toNumber(true);
                    if (object.compute_bandwidth_consumed != null)
                        if ($util.Long)
                            (message.compute_bandwidth_consumed = $util.Long.fromValue(object.compute_bandwidth_consumed)).unsigned = true;
                        else if (typeof object.compute_bandwidth_consumed === "string")
                            message.compute_bandwidth_consumed = parseInt(object.compute_bandwidth_consumed, 10);
                        else if (typeof object.compute_bandwidth_consumed === "number")
                            message.compute_bandwidth_consumed = object.compute_bandwidth_consumed;
                        else if (typeof object.compute_bandwidth_consumed === "object")
                            message.compute_bandwidth_consumed = new $util.LongBits(object.compute_bandwidth_consumed.low >>> 0, object.compute_bandwidth_consumed.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a consume_block_resources_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @static
                 * @param {koinos.chain.consume_block_resources_arguments} message consume_block_resources_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                consume_block_resources_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.disk_storage_consumed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.disk_storage_consumed = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.network_bandwidth_consumed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.network_bandwidth_consumed = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.compute_bandwidth_consumed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.compute_bandwidth_consumed = options.longs === String ? "0" : 0;
                    }
                    if (message.disk_storage_consumed != null && message.hasOwnProperty("disk_storage_consumed"))
                        if (typeof message.disk_storage_consumed === "number")
                            object.disk_storage_consumed = options.longs === String ? String(message.disk_storage_consumed) : message.disk_storage_consumed;
                        else
                            object.disk_storage_consumed = options.longs === String ? $util.Long.prototype.toString.call(message.disk_storage_consumed) : options.longs === Number ? new $util.LongBits(message.disk_storage_consumed.low >>> 0, message.disk_storage_consumed.high >>> 0).toNumber(true) : message.disk_storage_consumed;
                    if (message.network_bandwidth_consumed != null && message.hasOwnProperty("network_bandwidth_consumed"))
                        if (typeof message.network_bandwidth_consumed === "number")
                            object.network_bandwidth_consumed = options.longs === String ? String(message.network_bandwidth_consumed) : message.network_bandwidth_consumed;
                        else
                            object.network_bandwidth_consumed = options.longs === String ? $util.Long.prototype.toString.call(message.network_bandwidth_consumed) : options.longs === Number ? new $util.LongBits(message.network_bandwidth_consumed.low >>> 0, message.network_bandwidth_consumed.high >>> 0).toNumber(true) : message.network_bandwidth_consumed;
                    if (message.compute_bandwidth_consumed != null && message.hasOwnProperty("compute_bandwidth_consumed"))
                        if (typeof message.compute_bandwidth_consumed === "number")
                            object.compute_bandwidth_consumed = options.longs === String ? String(message.compute_bandwidth_consumed) : message.compute_bandwidth_consumed;
                        else
                            object.compute_bandwidth_consumed = options.longs === String ? $util.Long.prototype.toString.call(message.compute_bandwidth_consumed) : options.longs === Number ? new $util.LongBits(message.compute_bandwidth_consumed.low >>> 0, message.compute_bandwidth_consumed.high >>> 0).toNumber(true) : message.compute_bandwidth_consumed;
                    return object;
                };
    
                /**
                 * Converts this consume_block_resources_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.consume_block_resources_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                consume_block_resources_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return consume_block_resources_arguments;
            })();
    
            chain.consume_block_resources_result = (function() {
    
                /**
                 * Properties of a consume_block_resources_result.
                 * @memberof koinos.chain
                 * @interface Iconsume_block_resources_result
                 * @property {boolean|null} [value] consume_block_resources_result value
                 */
    
                /**
                 * Constructs a new consume_block_resources_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a consume_block_resources_result.
                 * @implements Iconsume_block_resources_result
                 * @constructor
                 * @param {koinos.chain.Iconsume_block_resources_result=} [properties] Properties to set
                 */
                function consume_block_resources_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * consume_block_resources_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.consume_block_resources_result
                 * @instance
                 */
                consume_block_resources_result.prototype.value = false;
    
                /**
                 * Creates a new consume_block_resources_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {koinos.chain.Iconsume_block_resources_result=} [properties] Properties to set
                 * @returns {koinos.chain.consume_block_resources_result} consume_block_resources_result instance
                 */
                consume_block_resources_result.create = function create(properties) {
                    return new consume_block_resources_result(properties);
                };
    
                /**
                 * Encodes the specified consume_block_resources_result message. Does not implicitly {@link koinos.chain.consume_block_resources_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {koinos.chain.Iconsume_block_resources_result} message consume_block_resources_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_block_resources_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified consume_block_resources_result message, length delimited. Does not implicitly {@link koinos.chain.consume_block_resources_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {koinos.chain.Iconsume_block_resources_result} message consume_block_resources_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                consume_block_resources_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a consume_block_resources_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.consume_block_resources_result} consume_block_resources_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_block_resources_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.consume_block_resources_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a consume_block_resources_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.consume_block_resources_result} consume_block_resources_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                consume_block_resources_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a consume_block_resources_result message.
                 * @function verify
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                consume_block_resources_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a consume_block_resources_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.consume_block_resources_result} consume_block_resources_result
                 */
                consume_block_resources_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.consume_block_resources_result)
                        return object;
                    var message = new $root.koinos.chain.consume_block_resources_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a consume_block_resources_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.consume_block_resources_result
                 * @static
                 * @param {koinos.chain.consume_block_resources_result} message consume_block_resources_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                consume_block_resources_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this consume_block_resources_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.consume_block_resources_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                consume_block_resources_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return consume_block_resources_result;
            })();
    
            chain.put_object_arguments = (function() {
    
                /**
                 * Properties of a put_object_arguments.
                 * @memberof koinos.chain
                 * @interface Iput_object_arguments
                 * @property {koinos.chain.Iobject_space|null} [space] put_object_arguments space
                 * @property {Uint8Array|null} [key] put_object_arguments key
                 * @property {Uint8Array|null} [obj] put_object_arguments obj
                 */
    
                /**
                 * Constructs a new put_object_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a put_object_arguments.
                 * @implements Iput_object_arguments
                 * @constructor
                 * @param {koinos.chain.Iput_object_arguments=} [properties] Properties to set
                 */
                function put_object_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * put_object_arguments space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.put_object_arguments
                 * @instance
                 */
                put_object_arguments.prototype.space = null;
    
                /**
                 * put_object_arguments key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.put_object_arguments
                 * @instance
                 */
                put_object_arguments.prototype.key = $util.newBuffer([]);
    
                /**
                 * put_object_arguments obj.
                 * @member {Uint8Array} obj
                 * @memberof koinos.chain.put_object_arguments
                 * @instance
                 */
                put_object_arguments.prototype.obj = $util.newBuffer([]);
    
                /**
                 * Creates a new put_object_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {koinos.chain.Iput_object_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.put_object_arguments} put_object_arguments instance
                 */
                put_object_arguments.create = function create(properties) {
                    return new put_object_arguments(properties);
                };
    
                /**
                 * Encodes the specified put_object_arguments message. Does not implicitly {@link koinos.chain.put_object_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {koinos.chain.Iput_object_arguments} message put_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                put_object_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    if (message.obj != null && Object.hasOwnProperty.call(message, "obj"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.obj);
                    return writer;
                };
    
                /**
                 * Encodes the specified put_object_arguments message, length delimited. Does not implicitly {@link koinos.chain.put_object_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {koinos.chain.Iput_object_arguments} message put_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                put_object_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a put_object_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.put_object_arguments} put_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                put_object_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.put_object_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        case 3:
                            message.obj = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a put_object_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.put_object_arguments} put_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                put_object_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a put_object_arguments message.
                 * @function verify
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                put_object_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    if (message.obj != null && message.hasOwnProperty("obj"))
                        if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                            return "obj: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a put_object_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.put_object_arguments} put_object_arguments
                 */
                put_object_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.put_object_arguments)
                        return object;
                    var message = new $root.koinos.chain.put_object_arguments();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.put_object_arguments.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    if (object.obj != null)
                        if (typeof object.obj === "string")
                            $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                        else if (object.obj.length)
                            message.obj = object.obj;
                    return message;
                };
    
                /**
                 * Creates a plain object from a put_object_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.put_object_arguments
                 * @static
                 * @param {koinos.chain.put_object_arguments} message put_object_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                put_object_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                        if (options.bytes === String)
                            object.obj = "";
                        else {
                            object.obj = [];
                            if (options.bytes !== Array)
                                object.obj = $util.newBuffer(object.obj);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    if (message.obj != null && message.hasOwnProperty("obj"))
                        object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                    return object;
                };
    
                /**
                 * Converts this put_object_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.put_object_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                put_object_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return put_object_arguments;
            })();
    
            chain.put_object_result = (function() {
    
                /**
                 * Properties of a put_object_result.
                 * @memberof koinos.chain
                 * @interface Iput_object_result
                 */
    
                /**
                 * Constructs a new put_object_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a put_object_result.
                 * @implements Iput_object_result
                 * @constructor
                 * @param {koinos.chain.Iput_object_result=} [properties] Properties to set
                 */
                function put_object_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new put_object_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {koinos.chain.Iput_object_result=} [properties] Properties to set
                 * @returns {koinos.chain.put_object_result} put_object_result instance
                 */
                put_object_result.create = function create(properties) {
                    return new put_object_result(properties);
                };
    
                /**
                 * Encodes the specified put_object_result message. Does not implicitly {@link koinos.chain.put_object_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {koinos.chain.Iput_object_result} message put_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                put_object_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified put_object_result message, length delimited. Does not implicitly {@link koinos.chain.put_object_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {koinos.chain.Iput_object_result} message put_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                put_object_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a put_object_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.put_object_result} put_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                put_object_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.put_object_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a put_object_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.put_object_result} put_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                put_object_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a put_object_result message.
                 * @function verify
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                put_object_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a put_object_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.put_object_result} put_object_result
                 */
                put_object_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.put_object_result)
                        return object;
                    return new $root.koinos.chain.put_object_result();
                };
    
                /**
                 * Creates a plain object from a put_object_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.put_object_result
                 * @static
                 * @param {koinos.chain.put_object_result} message put_object_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                put_object_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this put_object_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.put_object_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                put_object_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return put_object_result;
            })();
    
            chain.remove_object_arguments = (function() {
    
                /**
                 * Properties of a remove_object_arguments.
                 * @memberof koinos.chain
                 * @interface Iremove_object_arguments
                 * @property {koinos.chain.Iobject_space|null} [space] remove_object_arguments space
                 * @property {Uint8Array|null} [key] remove_object_arguments key
                 */
    
                /**
                 * Constructs a new remove_object_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a remove_object_arguments.
                 * @implements Iremove_object_arguments
                 * @constructor
                 * @param {koinos.chain.Iremove_object_arguments=} [properties] Properties to set
                 */
                function remove_object_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * remove_object_arguments space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.remove_object_arguments
                 * @instance
                 */
                remove_object_arguments.prototype.space = null;
    
                /**
                 * remove_object_arguments key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.remove_object_arguments
                 * @instance
                 */
                remove_object_arguments.prototype.key = $util.newBuffer([]);
    
                /**
                 * Creates a new remove_object_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {koinos.chain.Iremove_object_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.remove_object_arguments} remove_object_arguments instance
                 */
                remove_object_arguments.create = function create(properties) {
                    return new remove_object_arguments(properties);
                };
    
                /**
                 * Encodes the specified remove_object_arguments message. Does not implicitly {@link koinos.chain.remove_object_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {koinos.chain.Iremove_object_arguments} message remove_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                remove_object_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified remove_object_arguments message, length delimited. Does not implicitly {@link koinos.chain.remove_object_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {koinos.chain.Iremove_object_arguments} message remove_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                remove_object_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a remove_object_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.remove_object_arguments} remove_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                remove_object_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.remove_object_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a remove_object_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.remove_object_arguments} remove_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                remove_object_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a remove_object_arguments message.
                 * @function verify
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                remove_object_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a remove_object_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.remove_object_arguments} remove_object_arguments
                 */
                remove_object_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.remove_object_arguments)
                        return object;
                    var message = new $root.koinos.chain.remove_object_arguments();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.remove_object_arguments.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };
    
                /**
                 * Creates a plain object from a remove_object_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.remove_object_arguments
                 * @static
                 * @param {koinos.chain.remove_object_arguments} message remove_object_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                remove_object_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };
    
                /**
                 * Converts this remove_object_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.remove_object_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                remove_object_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return remove_object_arguments;
            })();
    
            chain.remove_object_result = (function() {
    
                /**
                 * Properties of a remove_object_result.
                 * @memberof koinos.chain
                 * @interface Iremove_object_result
                 */
    
                /**
                 * Constructs a new remove_object_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a remove_object_result.
                 * @implements Iremove_object_result
                 * @constructor
                 * @param {koinos.chain.Iremove_object_result=} [properties] Properties to set
                 */
                function remove_object_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new remove_object_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {koinos.chain.Iremove_object_result=} [properties] Properties to set
                 * @returns {koinos.chain.remove_object_result} remove_object_result instance
                 */
                remove_object_result.create = function create(properties) {
                    return new remove_object_result(properties);
                };
    
                /**
                 * Encodes the specified remove_object_result message. Does not implicitly {@link koinos.chain.remove_object_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {koinos.chain.Iremove_object_result} message remove_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                remove_object_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified remove_object_result message, length delimited. Does not implicitly {@link koinos.chain.remove_object_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {koinos.chain.Iremove_object_result} message remove_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                remove_object_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a remove_object_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.remove_object_result} remove_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                remove_object_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.remove_object_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a remove_object_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.remove_object_result} remove_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                remove_object_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a remove_object_result message.
                 * @function verify
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                remove_object_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a remove_object_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.remove_object_result} remove_object_result
                 */
                remove_object_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.remove_object_result)
                        return object;
                    return new $root.koinos.chain.remove_object_result();
                };
    
                /**
                 * Creates a plain object from a remove_object_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.remove_object_result
                 * @static
                 * @param {koinos.chain.remove_object_result} message remove_object_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                remove_object_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this remove_object_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.remove_object_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                remove_object_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return remove_object_result;
            })();
    
            chain.get_object_arguments = (function() {
    
                /**
                 * Properties of a get_object_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_object_arguments
                 * @property {koinos.chain.Iobject_space|null} [space] get_object_arguments space
                 * @property {Uint8Array|null} [key] get_object_arguments key
                 */
    
                /**
                 * Constructs a new get_object_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_object_arguments.
                 * @implements Iget_object_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_object_arguments=} [properties] Properties to set
                 */
                function get_object_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_object_arguments space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.get_object_arguments
                 * @instance
                 */
                get_object_arguments.prototype.space = null;
    
                /**
                 * get_object_arguments key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.get_object_arguments
                 * @instance
                 */
                get_object_arguments.prototype.key = $util.newBuffer([]);
    
                /**
                 * Creates a new get_object_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_object_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_object_arguments} get_object_arguments instance
                 */
                get_object_arguments.create = function create(properties) {
                    return new get_object_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_object_arguments message. Does not implicitly {@link koinos.chain.get_object_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_object_arguments} message get_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_object_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_object_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_object_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_object_arguments} message get_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_object_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_object_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_object_arguments} get_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_object_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_object_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_object_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_object_arguments} get_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_object_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_object_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_object_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_object_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_object_arguments} get_object_arguments
                 */
                get_object_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_object_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_object_arguments();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.get_object_arguments.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_object_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_object_arguments
                 * @static
                 * @param {koinos.chain.get_object_arguments} message get_object_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_object_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };
    
                /**
                 * Converts this get_object_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_object_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_object_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_object_arguments;
            })();
    
            chain.database_object = (function() {
    
                /**
                 * Properties of a database_object.
                 * @memberof koinos.chain
                 * @interface Idatabase_object
                 * @property {boolean|null} [exists] database_object exists
                 * @property {Uint8Array|null} [value] database_object value
                 * @property {Uint8Array|null} [key] database_object key
                 */
    
                /**
                 * Constructs a new database_object.
                 * @memberof koinos.chain
                 * @classdesc Represents a database_object.
                 * @implements Idatabase_object
                 * @constructor
                 * @param {koinos.chain.Idatabase_object=} [properties] Properties to set
                 */
                function database_object(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * database_object exists.
                 * @member {boolean} exists
                 * @memberof koinos.chain.database_object
                 * @instance
                 */
                database_object.prototype.exists = false;
    
                /**
                 * database_object value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.database_object
                 * @instance
                 */
                database_object.prototype.value = $util.newBuffer([]);
    
                /**
                 * database_object key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.database_object
                 * @instance
                 */
                database_object.prototype.key = $util.newBuffer([]);
    
                /**
                 * Creates a new database_object instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {koinos.chain.Idatabase_object=} [properties] Properties to set
                 * @returns {koinos.chain.database_object} database_object instance
                 */
                database_object.create = function create(properties) {
                    return new database_object(properties);
                };
    
                /**
                 * Encodes the specified database_object message. Does not implicitly {@link koinos.chain.database_object.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {koinos.chain.Idatabase_object} message database_object message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                database_object.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.exists != null && Object.hasOwnProperty.call(message, "exists"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.exists);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified database_object message, length delimited. Does not implicitly {@link koinos.chain.database_object.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {koinos.chain.Idatabase_object} message database_object message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                database_object.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a database_object message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.database_object} database_object
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                database_object.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.database_object();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.exists = reader.bool();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        case 3:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a database_object message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.database_object} database_object
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                database_object.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a database_object message.
                 * @function verify
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                database_object.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.exists != null && message.hasOwnProperty("exists"))
                        if (typeof message.exists !== "boolean")
                            return "exists: boolean expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a database_object message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.database_object} database_object
                 */
                database_object.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.database_object)
                        return object;
                    var message = new $root.koinos.chain.database_object();
                    if (object.exists != null)
                        message.exists = Boolean(object.exists);
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };
    
                /**
                 * Creates a plain object from a database_object message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.database_object
                 * @static
                 * @param {koinos.chain.database_object} message database_object
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                database_object.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.exists = false;
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.exists != null && message.hasOwnProperty("exists"))
                        object.exists = message.exists;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };
    
                /**
                 * Converts this database_object to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.database_object
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                database_object.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return database_object;
            })();
    
            chain.get_object_result = (function() {
    
                /**
                 * Properties of a get_object_result.
                 * @memberof koinos.chain
                 * @interface Iget_object_result
                 * @property {koinos.chain.Idatabase_object|null} [value] get_object_result value
                 */
    
                /**
                 * Constructs a new get_object_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_object_result.
                 * @implements Iget_object_result
                 * @constructor
                 * @param {koinos.chain.Iget_object_result=} [properties] Properties to set
                 */
                function get_object_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_object_result value.
                 * @member {koinos.chain.Idatabase_object|null|undefined} value
                 * @memberof koinos.chain.get_object_result
                 * @instance
                 */
                get_object_result.prototype.value = null;
    
                /**
                 * Creates a new get_object_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {koinos.chain.Iget_object_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_object_result} get_object_result instance
                 */
                get_object_result.create = function create(properties) {
                    return new get_object_result(properties);
                };
    
                /**
                 * Encodes the specified get_object_result message. Does not implicitly {@link koinos.chain.get_object_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {koinos.chain.Iget_object_result} message get_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_object_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.database_object.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_object_result message, length delimited. Does not implicitly {@link koinos.chain.get_object_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {koinos.chain.Iget_object_result} message get_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_object_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_object_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_object_result} get_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_object_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_object_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.database_object.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_object_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_object_result} get_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_object_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_object_result message.
                 * @function verify
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_object_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.database_object.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_object_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_object_result} get_object_result
                 */
                get_object_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_object_result)
                        return object;
                    var message = new $root.koinos.chain.get_object_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_object_result.value: object expected");
                        message.value = $root.koinos.chain.database_object.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_object_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_object_result
                 * @static
                 * @param {koinos.chain.get_object_result} message get_object_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_object_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.database_object.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_object_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_object_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_object_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_object_result;
            })();
    
            chain.get_next_object_arguments = (function() {
    
                /**
                 * Properties of a get_next_object_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_next_object_arguments
                 * @property {koinos.chain.Iobject_space|null} [space] get_next_object_arguments space
                 * @property {Uint8Array|null} [key] get_next_object_arguments key
                 */
    
                /**
                 * Constructs a new get_next_object_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_next_object_arguments.
                 * @implements Iget_next_object_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_next_object_arguments=} [properties] Properties to set
                 */
                function get_next_object_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_next_object_arguments space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.get_next_object_arguments
                 * @instance
                 */
                get_next_object_arguments.prototype.space = null;
    
                /**
                 * get_next_object_arguments key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.get_next_object_arguments
                 * @instance
                 */
                get_next_object_arguments.prototype.key = $util.newBuffer([]);
    
                /**
                 * Creates a new get_next_object_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_next_object_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_next_object_arguments} get_next_object_arguments instance
                 */
                get_next_object_arguments.create = function create(properties) {
                    return new get_next_object_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_next_object_arguments message. Does not implicitly {@link koinos.chain.get_next_object_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_next_object_arguments} message get_next_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_next_object_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_next_object_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_next_object_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_next_object_arguments} message get_next_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_next_object_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_next_object_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_next_object_arguments} get_next_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_next_object_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_next_object_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_next_object_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_next_object_arguments} get_next_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_next_object_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_next_object_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_next_object_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_next_object_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_next_object_arguments} get_next_object_arguments
                 */
                get_next_object_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_next_object_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_next_object_arguments();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.get_next_object_arguments.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_next_object_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_next_object_arguments
                 * @static
                 * @param {koinos.chain.get_next_object_arguments} message get_next_object_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_next_object_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };
    
                /**
                 * Converts this get_next_object_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_next_object_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_next_object_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_next_object_arguments;
            })();
    
            chain.get_next_object_result = (function() {
    
                /**
                 * Properties of a get_next_object_result.
                 * @memberof koinos.chain
                 * @interface Iget_next_object_result
                 * @property {koinos.chain.Idatabase_object|null} [value] get_next_object_result value
                 */
    
                /**
                 * Constructs a new get_next_object_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_next_object_result.
                 * @implements Iget_next_object_result
                 * @constructor
                 * @param {koinos.chain.Iget_next_object_result=} [properties] Properties to set
                 */
                function get_next_object_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_next_object_result value.
                 * @member {koinos.chain.Idatabase_object|null|undefined} value
                 * @memberof koinos.chain.get_next_object_result
                 * @instance
                 */
                get_next_object_result.prototype.value = null;
    
                /**
                 * Creates a new get_next_object_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {koinos.chain.Iget_next_object_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_next_object_result} get_next_object_result instance
                 */
                get_next_object_result.create = function create(properties) {
                    return new get_next_object_result(properties);
                };
    
                /**
                 * Encodes the specified get_next_object_result message. Does not implicitly {@link koinos.chain.get_next_object_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {koinos.chain.Iget_next_object_result} message get_next_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_next_object_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.database_object.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_next_object_result message, length delimited. Does not implicitly {@link koinos.chain.get_next_object_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {koinos.chain.Iget_next_object_result} message get_next_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_next_object_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_next_object_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_next_object_result} get_next_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_next_object_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_next_object_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.database_object.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_next_object_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_next_object_result} get_next_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_next_object_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_next_object_result message.
                 * @function verify
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_next_object_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.database_object.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_next_object_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_next_object_result} get_next_object_result
                 */
                get_next_object_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_next_object_result)
                        return object;
                    var message = new $root.koinos.chain.get_next_object_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_next_object_result.value: object expected");
                        message.value = $root.koinos.chain.database_object.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_next_object_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_next_object_result
                 * @static
                 * @param {koinos.chain.get_next_object_result} message get_next_object_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_next_object_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.database_object.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_next_object_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_next_object_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_next_object_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_next_object_result;
            })();
    
            chain.get_prev_object_arguments = (function() {
    
                /**
                 * Properties of a get_prev_object_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_prev_object_arguments
                 * @property {koinos.chain.Iobject_space|null} [space] get_prev_object_arguments space
                 * @property {Uint8Array|null} [key] get_prev_object_arguments key
                 */
    
                /**
                 * Constructs a new get_prev_object_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_prev_object_arguments.
                 * @implements Iget_prev_object_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_prev_object_arguments=} [properties] Properties to set
                 */
                function get_prev_object_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_prev_object_arguments space.
                 * @member {koinos.chain.Iobject_space|null|undefined} space
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @instance
                 */
                get_prev_object_arguments.prototype.space = null;
    
                /**
                 * get_prev_object_arguments key.
                 * @member {Uint8Array} key
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @instance
                 */
                get_prev_object_arguments.prototype.key = $util.newBuffer([]);
    
                /**
                 * Creates a new get_prev_object_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_prev_object_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_prev_object_arguments} get_prev_object_arguments instance
                 */
                get_prev_object_arguments.create = function create(properties) {
                    return new get_prev_object_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_prev_object_arguments message. Does not implicitly {@link koinos.chain.get_prev_object_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_prev_object_arguments} message get_prev_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_prev_object_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.space != null && Object.hasOwnProperty.call(message, "space"))
                        $root.koinos.chain.object_space.encode(message.space, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_prev_object_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_prev_object_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {koinos.chain.Iget_prev_object_arguments} message get_prev_object_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_prev_object_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_prev_object_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_prev_object_arguments} get_prev_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_prev_object_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_prev_object_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.space = $root.koinos.chain.object_space.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.key = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_prev_object_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_prev_object_arguments} get_prev_object_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_prev_object_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_prev_object_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_prev_object_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.space != null && message.hasOwnProperty("space")) {
                        var error = $root.koinos.chain.object_space.verify(message.space);
                        if (error)
                            return "space." + error;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                            return "key: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_prev_object_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_prev_object_arguments} get_prev_object_arguments
                 */
                get_prev_object_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_prev_object_arguments)
                        return object;
                    var message = new $root.koinos.chain.get_prev_object_arguments();
                    if (object.space != null) {
                        if (typeof object.space !== "object")
                            throw TypeError(".koinos.chain.get_prev_object_arguments.space: object expected");
                        message.space = $root.koinos.chain.object_space.fromObject(object.space);
                    }
                    if (object.key != null)
                        if (typeof object.key === "string")
                            $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                        else if (object.key.length)
                            message.key = object.key;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_prev_object_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @static
                 * @param {koinos.chain.get_prev_object_arguments} message get_prev_object_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_prev_object_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.space = null;
                        if (options.bytes === String)
                            object.key = "";
                        else {
                            object.key = [];
                            if (options.bytes !== Array)
                                object.key = $util.newBuffer(object.key);
                        }
                    }
                    if (message.space != null && message.hasOwnProperty("space"))
                        object.space = $root.koinos.chain.object_space.toObject(message.space, options);
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                    return object;
                };
    
                /**
                 * Converts this get_prev_object_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_prev_object_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_prev_object_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_prev_object_arguments;
            })();
    
            chain.get_prev_object_result = (function() {
    
                /**
                 * Properties of a get_prev_object_result.
                 * @memberof koinos.chain
                 * @interface Iget_prev_object_result
                 * @property {koinos.chain.Idatabase_object|null} [value] get_prev_object_result value
                 */
    
                /**
                 * Constructs a new get_prev_object_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_prev_object_result.
                 * @implements Iget_prev_object_result
                 * @constructor
                 * @param {koinos.chain.Iget_prev_object_result=} [properties] Properties to set
                 */
                function get_prev_object_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_prev_object_result value.
                 * @member {koinos.chain.Idatabase_object|null|undefined} value
                 * @memberof koinos.chain.get_prev_object_result
                 * @instance
                 */
                get_prev_object_result.prototype.value = null;
    
                /**
                 * Creates a new get_prev_object_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {koinos.chain.Iget_prev_object_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_prev_object_result} get_prev_object_result instance
                 */
                get_prev_object_result.create = function create(properties) {
                    return new get_prev_object_result(properties);
                };
    
                /**
                 * Encodes the specified get_prev_object_result message. Does not implicitly {@link koinos.chain.get_prev_object_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {koinos.chain.Iget_prev_object_result} message get_prev_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_prev_object_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.database_object.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_prev_object_result message, length delimited. Does not implicitly {@link koinos.chain.get_prev_object_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {koinos.chain.Iget_prev_object_result} message get_prev_object_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_prev_object_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_prev_object_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_prev_object_result} get_prev_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_prev_object_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_prev_object_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.database_object.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_prev_object_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_prev_object_result} get_prev_object_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_prev_object_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_prev_object_result message.
                 * @function verify
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_prev_object_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.database_object.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_prev_object_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_prev_object_result} get_prev_object_result
                 */
                get_prev_object_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_prev_object_result)
                        return object;
                    var message = new $root.koinos.chain.get_prev_object_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_prev_object_result.value: object expected");
                        message.value = $root.koinos.chain.database_object.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_prev_object_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_prev_object_result
                 * @static
                 * @param {koinos.chain.get_prev_object_result} message get_prev_object_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_prev_object_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.database_object.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_prev_object_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_prev_object_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_prev_object_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_prev_object_result;
            })();
    
            chain.log_arguments = (function() {
    
                /**
                 * Properties of a log_arguments.
                 * @memberof koinos.chain
                 * @interface Ilog_arguments
                 * @property {string|null} [message] log_arguments message
                 */
    
                /**
                 * Constructs a new log_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a log_arguments.
                 * @implements Ilog_arguments
                 * @constructor
                 * @param {koinos.chain.Ilog_arguments=} [properties] Properties to set
                 */
                function log_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * log_arguments message.
                 * @member {string} message
                 * @memberof koinos.chain.log_arguments
                 * @instance
                 */
                log_arguments.prototype.message = "";
    
                /**
                 * Creates a new log_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {koinos.chain.Ilog_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.log_arguments} log_arguments instance
                 */
                log_arguments.create = function create(properties) {
                    return new log_arguments(properties);
                };
    
                /**
                 * Encodes the specified log_arguments message. Does not implicitly {@link koinos.chain.log_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {koinos.chain.Ilog_arguments} message log_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                log_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                    return writer;
                };
    
                /**
                 * Encodes the specified log_arguments message, length delimited. Does not implicitly {@link koinos.chain.log_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {koinos.chain.Ilog_arguments} message log_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                log_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a log_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.log_arguments} log_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                log_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.log_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a log_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.log_arguments} log_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                log_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a log_arguments message.
                 * @function verify
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                log_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };
    
                /**
                 * Creates a log_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.log_arguments} log_arguments
                 */
                log_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.log_arguments)
                        return object;
                    var message = new $root.koinos.chain.log_arguments();
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };
    
                /**
                 * Creates a plain object from a log_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.log_arguments
                 * @static
                 * @param {koinos.chain.log_arguments} message log_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                log_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.message = "";
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };
    
                /**
                 * Converts this log_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.log_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                log_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return log_arguments;
            })();
    
            chain.log_result = (function() {
    
                /**
                 * Properties of a log_result.
                 * @memberof koinos.chain
                 * @interface Ilog_result
                 */
    
                /**
                 * Constructs a new log_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a log_result.
                 * @implements Ilog_result
                 * @constructor
                 * @param {koinos.chain.Ilog_result=} [properties] Properties to set
                 */
                function log_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new log_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {koinos.chain.Ilog_result=} [properties] Properties to set
                 * @returns {koinos.chain.log_result} log_result instance
                 */
                log_result.create = function create(properties) {
                    return new log_result(properties);
                };
    
                /**
                 * Encodes the specified log_result message. Does not implicitly {@link koinos.chain.log_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {koinos.chain.Ilog_result} message log_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                log_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified log_result message, length delimited. Does not implicitly {@link koinos.chain.log_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {koinos.chain.Ilog_result} message log_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                log_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a log_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.log_result} log_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                log_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.log_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a log_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.log_result} log_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                log_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a log_result message.
                 * @function verify
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                log_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a log_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.log_result} log_result
                 */
                log_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.log_result)
                        return object;
                    return new $root.koinos.chain.log_result();
                };
    
                /**
                 * Creates a plain object from a log_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.log_result
                 * @static
                 * @param {koinos.chain.log_result} message log_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                log_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this log_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.log_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                log_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return log_result;
            })();
    
            chain.event_arguments = (function() {
    
                /**
                 * Properties of an event_arguments.
                 * @memberof koinos.chain
                 * @interface Ievent_arguments
                 * @property {string|null} [name] event_arguments name
                 * @property {Uint8Array|null} [data] event_arguments data
                 * @property {Array.<Uint8Array>|null} [impacted] event_arguments impacted
                 */
    
                /**
                 * Constructs a new event_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an event_arguments.
                 * @implements Ievent_arguments
                 * @constructor
                 * @param {koinos.chain.Ievent_arguments=} [properties] Properties to set
                 */
                function event_arguments(properties) {
                    this.impacted = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * event_arguments name.
                 * @member {string} name
                 * @memberof koinos.chain.event_arguments
                 * @instance
                 */
                event_arguments.prototype.name = "";
    
                /**
                 * event_arguments data.
                 * @member {Uint8Array} data
                 * @memberof koinos.chain.event_arguments
                 * @instance
                 */
                event_arguments.prototype.data = $util.newBuffer([]);
    
                /**
                 * event_arguments impacted.
                 * @member {Array.<Uint8Array>} impacted
                 * @memberof koinos.chain.event_arguments
                 * @instance
                 */
                event_arguments.prototype.impacted = $util.emptyArray;
    
                /**
                 * Creates a new event_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {koinos.chain.Ievent_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.event_arguments} event_arguments instance
                 */
                event_arguments.create = function create(properties) {
                    return new event_arguments(properties);
                };
    
                /**
                 * Encodes the specified event_arguments message. Does not implicitly {@link koinos.chain.event_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {koinos.chain.Ievent_arguments} message event_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                    if (message.impacted != null && message.impacted.length)
                        for (var i = 0; i < message.impacted.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.impacted[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified event_arguments message, length delimited. Does not implicitly {@link koinos.chain.event_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {koinos.chain.Ievent_arguments} message event_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an event_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.event_arguments} event_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.event_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.data = reader.bytes();
                            break;
                        case 3:
                            if (!(message.impacted && message.impacted.length))
                                message.impacted = [];
                            message.impacted.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an event_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.event_arguments} event_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an event_arguments message.
                 * @function verify
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                event_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    if (message.impacted != null && message.hasOwnProperty("impacted")) {
                        if (!Array.isArray(message.impacted))
                            return "impacted: array expected";
                        for (var i = 0; i < message.impacted.length; ++i)
                            if (!(message.impacted[i] && typeof message.impacted[i].length === "number" || $util.isString(message.impacted[i])))
                                return "impacted: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an event_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.event_arguments} event_arguments
                 */
                event_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.event_arguments)
                        return object;
                    var message = new $root.koinos.chain.event_arguments();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    if (object.impacted) {
                        if (!Array.isArray(object.impacted))
                            throw TypeError(".koinos.chain.event_arguments.impacted: array expected");
                        message.impacted = [];
                        for (var i = 0; i < object.impacted.length; ++i)
                            if (typeof object.impacted[i] === "string")
                                $util.base64.decode(object.impacted[i], message.impacted[i] = $util.newBuffer($util.base64.length(object.impacted[i])), 0);
                            else if (object.impacted[i].length)
                                message.impacted[i] = object.impacted[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an event_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.event_arguments
                 * @static
                 * @param {koinos.chain.event_arguments} message event_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                event_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.impacted = [];
                    if (options.defaults) {
                        object.name = "";
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    if (message.impacted && message.impacted.length) {
                        object.impacted = [];
                        for (var j = 0; j < message.impacted.length; ++j)
                            object.impacted[j] = options.bytes === String ? $util.base64.encode(message.impacted[j], 0, message.impacted[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.impacted[j]) : message.impacted[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this event_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.event_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                event_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return event_arguments;
            })();
    
            chain.event_result = (function() {
    
                /**
                 * Properties of an event_result.
                 * @memberof koinos.chain
                 * @interface Ievent_result
                 */
    
                /**
                 * Constructs a new event_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an event_result.
                 * @implements Ievent_result
                 * @constructor
                 * @param {koinos.chain.Ievent_result=} [properties] Properties to set
                 */
                function event_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new event_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {koinos.chain.Ievent_result=} [properties] Properties to set
                 * @returns {koinos.chain.event_result} event_result instance
                 */
                event_result.create = function create(properties) {
                    return new event_result(properties);
                };
    
                /**
                 * Encodes the specified event_result message. Does not implicitly {@link koinos.chain.event_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {koinos.chain.Ievent_result} message event_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified event_result message, length delimited. Does not implicitly {@link koinos.chain.event_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {koinos.chain.Ievent_result} message event_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                event_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an event_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.event_result} event_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.event_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an event_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.event_result} event_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                event_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an event_result message.
                 * @function verify
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                event_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an event_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.event_result} event_result
                 */
                event_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.event_result)
                        return object;
                    return new $root.koinos.chain.event_result();
                };
    
                /**
                 * Creates a plain object from an event_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.event_result
                 * @static
                 * @param {koinos.chain.event_result} message event_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                event_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this event_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.event_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                event_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return event_result;
            })();
    
            chain.hash_arguments = (function() {
    
                /**
                 * Properties of a hash_arguments.
                 * @memberof koinos.chain
                 * @interface Ihash_arguments
                 * @property {number|Long|null} [code] hash_arguments code
                 * @property {Uint8Array|null} [obj] hash_arguments obj
                 * @property {number|Long|null} [size] hash_arguments size
                 */
    
                /**
                 * Constructs a new hash_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a hash_arguments.
                 * @implements Ihash_arguments
                 * @constructor
                 * @param {koinos.chain.Ihash_arguments=} [properties] Properties to set
                 */
                function hash_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * hash_arguments code.
                 * @member {number|Long} code
                 * @memberof koinos.chain.hash_arguments
                 * @instance
                 */
                hash_arguments.prototype.code = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * hash_arguments obj.
                 * @member {Uint8Array} obj
                 * @memberof koinos.chain.hash_arguments
                 * @instance
                 */
                hash_arguments.prototype.obj = $util.newBuffer([]);
    
                /**
                 * hash_arguments size.
                 * @member {number|Long} size
                 * @memberof koinos.chain.hash_arguments
                 * @instance
                 */
                hash_arguments.prototype.size = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new hash_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {koinos.chain.Ihash_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.hash_arguments} hash_arguments instance
                 */
                hash_arguments.create = function create(properties) {
                    return new hash_arguments(properties);
                };
    
                /**
                 * Encodes the specified hash_arguments message. Does not implicitly {@link koinos.chain.hash_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {koinos.chain.Ihash_arguments} message hash_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                hash_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.code);
                    if (message.obj != null && Object.hasOwnProperty.call(message, "obj"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.obj);
                    if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.size);
                    return writer;
                };
    
                /**
                 * Encodes the specified hash_arguments message, length delimited. Does not implicitly {@link koinos.chain.hash_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {koinos.chain.Ihash_arguments} message hash_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                hash_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a hash_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.hash_arguments} hash_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                hash_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.hash_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.uint64();
                            break;
                        case 2:
                            message.obj = reader.bytes();
                            break;
                        case 3:
                            message.size = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a hash_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.hash_arguments} hash_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                hash_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a hash_arguments message.
                 * @function verify
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                hash_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isInteger(message.code) && !(message.code && $util.isInteger(message.code.low) && $util.isInteger(message.code.high)))
                            return "code: integer|Long expected";
                    if (message.obj != null && message.hasOwnProperty("obj"))
                        if (!(message.obj && typeof message.obj.length === "number" || $util.isString(message.obj)))
                            return "obj: buffer expected";
                    if (message.size != null && message.hasOwnProperty("size"))
                        if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                            return "size: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a hash_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.hash_arguments} hash_arguments
                 */
                hash_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.hash_arguments)
                        return object;
                    var message = new $root.koinos.chain.hash_arguments();
                    if (object.code != null)
                        if ($util.Long)
                            (message.code = $util.Long.fromValue(object.code)).unsigned = true;
                        else if (typeof object.code === "string")
                            message.code = parseInt(object.code, 10);
                        else if (typeof object.code === "number")
                            message.code = object.code;
                        else if (typeof object.code === "object")
                            message.code = new $util.LongBits(object.code.low >>> 0, object.code.high >>> 0).toNumber(true);
                    if (object.obj != null)
                        if (typeof object.obj === "string")
                            $util.base64.decode(object.obj, message.obj = $util.newBuffer($util.base64.length(object.obj)), 0);
                        else if (object.obj.length)
                            message.obj = object.obj;
                    if (object.size != null)
                        if ($util.Long)
                            (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                        else if (typeof object.size === "string")
                            message.size = parseInt(object.size, 10);
                        else if (typeof object.size === "number")
                            message.size = object.size;
                        else if (typeof object.size === "object")
                            message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a hash_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.hash_arguments
                 * @static
                 * @param {koinos.chain.hash_arguments} message hash_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                hash_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.code = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.code = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.obj = "";
                        else {
                            object.obj = [];
                            if (options.bytes !== Array)
                                object.obj = $util.newBuffer(object.obj);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.size = options.longs === String ? "0" : 0;
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (typeof message.code === "number")
                            object.code = options.longs === String ? String(message.code) : message.code;
                        else
                            object.code = options.longs === String ? $util.Long.prototype.toString.call(message.code) : options.longs === Number ? new $util.LongBits(message.code.low >>> 0, message.code.high >>> 0).toNumber(true) : message.code;
                    if (message.obj != null && message.hasOwnProperty("obj"))
                        object.obj = options.bytes === String ? $util.base64.encode(message.obj, 0, message.obj.length) : options.bytes === Array ? Array.prototype.slice.call(message.obj) : message.obj;
                    if (message.size != null && message.hasOwnProperty("size"))
                        if (typeof message.size === "number")
                            object.size = options.longs === String ? String(message.size) : message.size;
                        else
                            object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
                    return object;
                };
    
                /**
                 * Converts this hash_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.hash_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                hash_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return hash_arguments;
            })();
    
            chain.hash_result = (function() {
    
                /**
                 * Properties of a hash_result.
                 * @memberof koinos.chain
                 * @interface Ihash_result
                 * @property {Uint8Array|null} [value] hash_result value
                 */
    
                /**
                 * Constructs a new hash_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a hash_result.
                 * @implements Ihash_result
                 * @constructor
                 * @param {koinos.chain.Ihash_result=} [properties] Properties to set
                 */
                function hash_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * hash_result value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.hash_result
                 * @instance
                 */
                hash_result.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new hash_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {koinos.chain.Ihash_result=} [properties] Properties to set
                 * @returns {koinos.chain.hash_result} hash_result instance
                 */
                hash_result.create = function create(properties) {
                    return new hash_result(properties);
                };
    
                /**
                 * Encodes the specified hash_result message. Does not implicitly {@link koinos.chain.hash_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {koinos.chain.Ihash_result} message hash_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                hash_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified hash_result message, length delimited. Does not implicitly {@link koinos.chain.hash_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {koinos.chain.Ihash_result} message hash_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                hash_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a hash_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.hash_result} hash_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                hash_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.hash_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a hash_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.hash_result} hash_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                hash_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a hash_result message.
                 * @function verify
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                hash_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a hash_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.hash_result} hash_result
                 */
                hash_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.hash_result)
                        return object;
                    var message = new $root.koinos.chain.hash_result();
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a hash_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.hash_result
                 * @static
                 * @param {koinos.chain.hash_result} message hash_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                hash_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this hash_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.hash_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                hash_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return hash_result;
            })();
    
            chain.recover_public_key_arguments = (function() {
    
                /**
                 * Properties of a recover_public_key_arguments.
                 * @memberof koinos.chain
                 * @interface Irecover_public_key_arguments
                 * @property {koinos.chain.dsa|null} [type] recover_public_key_arguments type
                 * @property {Uint8Array|null} [signature] recover_public_key_arguments signature
                 * @property {Uint8Array|null} [digest] recover_public_key_arguments digest
                 */
    
                /**
                 * Constructs a new recover_public_key_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a recover_public_key_arguments.
                 * @implements Irecover_public_key_arguments
                 * @constructor
                 * @param {koinos.chain.Irecover_public_key_arguments=} [properties] Properties to set
                 */
                function recover_public_key_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * recover_public_key_arguments type.
                 * @member {koinos.chain.dsa} type
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @instance
                 */
                recover_public_key_arguments.prototype.type = 0;
    
                /**
                 * recover_public_key_arguments signature.
                 * @member {Uint8Array} signature
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @instance
                 */
                recover_public_key_arguments.prototype.signature = $util.newBuffer([]);
    
                /**
                 * recover_public_key_arguments digest.
                 * @member {Uint8Array} digest
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @instance
                 */
                recover_public_key_arguments.prototype.digest = $util.newBuffer([]);
    
                /**
                 * Creates a new recover_public_key_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {koinos.chain.Irecover_public_key_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.recover_public_key_arguments} recover_public_key_arguments instance
                 */
                recover_public_key_arguments.create = function create(properties) {
                    return new recover_public_key_arguments(properties);
                };
    
                /**
                 * Encodes the specified recover_public_key_arguments message. Does not implicitly {@link koinos.chain.recover_public_key_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {koinos.chain.Irecover_public_key_arguments} message recover_public_key_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                recover_public_key_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature);
                    if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.digest);
                    return writer;
                };
    
                /**
                 * Encodes the specified recover_public_key_arguments message, length delimited. Does not implicitly {@link koinos.chain.recover_public_key_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {koinos.chain.Irecover_public_key_arguments} message recover_public_key_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                recover_public_key_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a recover_public_key_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.recover_public_key_arguments} recover_public_key_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                recover_public_key_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.recover_public_key_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.signature = reader.bytes();
                            break;
                        case 3:
                            message.digest = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a recover_public_key_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.recover_public_key_arguments} recover_public_key_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                recover_public_key_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a recover_public_key_arguments message.
                 * @function verify
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                recover_public_key_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                            break;
                        }
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                            return "signature: buffer expected";
                    if (message.digest != null && message.hasOwnProperty("digest"))
                        if (!(message.digest && typeof message.digest.length === "number" || $util.isString(message.digest)))
                            return "digest: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a recover_public_key_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.recover_public_key_arguments} recover_public_key_arguments
                 */
                recover_public_key_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.recover_public_key_arguments)
                        return object;
                    var message = new $root.koinos.chain.recover_public_key_arguments();
                    switch (object.type) {
                    case "ecdsa_secp256k1":
                    case 0:
                        message.type = 0;
                        break;
                    }
                    if (object.signature != null)
                        if (typeof object.signature === "string")
                            $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                        else if (object.signature.length)
                            message.signature = object.signature;
                    if (object.digest != null)
                        if (typeof object.digest === "string")
                            $util.base64.decode(object.digest, message.digest = $util.newBuffer($util.base64.length(object.digest)), 0);
                        else if (object.digest.length)
                            message.digest = object.digest;
                    return message;
                };
    
                /**
                 * Creates a plain object from a recover_public_key_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @static
                 * @param {koinos.chain.recover_public_key_arguments} message recover_public_key_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                recover_public_key_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "ecdsa_secp256k1" : 0;
                        if (options.bytes === String)
                            object.signature = "";
                        else {
                            object.signature = [];
                            if (options.bytes !== Array)
                                object.signature = $util.newBuffer(object.signature);
                        }
                        if (options.bytes === String)
                            object.digest = "";
                        else {
                            object.digest = [];
                            if (options.bytes !== Array)
                                object.digest = $util.newBuffer(object.digest);
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.koinos.chain.dsa[message.type] : message.type;
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                    if (message.digest != null && message.hasOwnProperty("digest"))
                        object.digest = options.bytes === String ? $util.base64.encode(message.digest, 0, message.digest.length) : options.bytes === Array ? Array.prototype.slice.call(message.digest) : message.digest;
                    return object;
                };
    
                /**
                 * Converts this recover_public_key_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.recover_public_key_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                recover_public_key_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return recover_public_key_arguments;
            })();
    
            chain.recover_public_key_result = (function() {
    
                /**
                 * Properties of a recover_public_key_result.
                 * @memberof koinos.chain
                 * @interface Irecover_public_key_result
                 * @property {Uint8Array|null} [value] recover_public_key_result value
                 */
    
                /**
                 * Constructs a new recover_public_key_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a recover_public_key_result.
                 * @implements Irecover_public_key_result
                 * @constructor
                 * @param {koinos.chain.Irecover_public_key_result=} [properties] Properties to set
                 */
                function recover_public_key_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * recover_public_key_result value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.recover_public_key_result
                 * @instance
                 */
                recover_public_key_result.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new recover_public_key_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {koinos.chain.Irecover_public_key_result=} [properties] Properties to set
                 * @returns {koinos.chain.recover_public_key_result} recover_public_key_result instance
                 */
                recover_public_key_result.create = function create(properties) {
                    return new recover_public_key_result(properties);
                };
    
                /**
                 * Encodes the specified recover_public_key_result message. Does not implicitly {@link koinos.chain.recover_public_key_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {koinos.chain.Irecover_public_key_result} message recover_public_key_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                recover_public_key_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified recover_public_key_result message, length delimited. Does not implicitly {@link koinos.chain.recover_public_key_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {koinos.chain.Irecover_public_key_result} message recover_public_key_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                recover_public_key_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a recover_public_key_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.recover_public_key_result} recover_public_key_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                recover_public_key_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.recover_public_key_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a recover_public_key_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.recover_public_key_result} recover_public_key_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                recover_public_key_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a recover_public_key_result message.
                 * @function verify
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                recover_public_key_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a recover_public_key_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.recover_public_key_result} recover_public_key_result
                 */
                recover_public_key_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.recover_public_key_result)
                        return object;
                    var message = new $root.koinos.chain.recover_public_key_result();
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a recover_public_key_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.recover_public_key_result
                 * @static
                 * @param {koinos.chain.recover_public_key_result} message recover_public_key_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                recover_public_key_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this recover_public_key_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.recover_public_key_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                recover_public_key_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return recover_public_key_result;
            })();
    
            chain.verify_merkle_root_arguments = (function() {
    
                /**
                 * Properties of a verify_merkle_root_arguments.
                 * @memberof koinos.chain
                 * @interface Iverify_merkle_root_arguments
                 * @property {Uint8Array|null} [root] verify_merkle_root_arguments root
                 * @property {Array.<Uint8Array>|null} [hashes] verify_merkle_root_arguments hashes
                 */
    
                /**
                 * Constructs a new verify_merkle_root_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_merkle_root_arguments.
                 * @implements Iverify_merkle_root_arguments
                 * @constructor
                 * @param {koinos.chain.Iverify_merkle_root_arguments=} [properties] Properties to set
                 */
                function verify_merkle_root_arguments(properties) {
                    this.hashes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_merkle_root_arguments root.
                 * @member {Uint8Array} root
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @instance
                 */
                verify_merkle_root_arguments.prototype.root = $util.newBuffer([]);
    
                /**
                 * verify_merkle_root_arguments hashes.
                 * @member {Array.<Uint8Array>} hashes
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @instance
                 */
                verify_merkle_root_arguments.prototype.hashes = $util.emptyArray;
    
                /**
                 * Creates a new verify_merkle_root_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {koinos.chain.Iverify_merkle_root_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.verify_merkle_root_arguments} verify_merkle_root_arguments instance
                 */
                verify_merkle_root_arguments.create = function create(properties) {
                    return new verify_merkle_root_arguments(properties);
                };
    
                /**
                 * Encodes the specified verify_merkle_root_arguments message. Does not implicitly {@link koinos.chain.verify_merkle_root_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {koinos.chain.Iverify_merkle_root_arguments} message verify_merkle_root_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_merkle_root_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.root != null && Object.hasOwnProperty.call(message, "root"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.root);
                    if (message.hashes != null && message.hashes.length)
                        for (var i = 0; i < message.hashes.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.hashes[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_merkle_root_arguments message, length delimited. Does not implicitly {@link koinos.chain.verify_merkle_root_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {koinos.chain.Iverify_merkle_root_arguments} message verify_merkle_root_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_merkle_root_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_merkle_root_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_merkle_root_arguments} verify_merkle_root_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_merkle_root_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_merkle_root_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.root = reader.bytes();
                            break;
                        case 2:
                            if (!(message.hashes && message.hashes.length))
                                message.hashes = [];
                            message.hashes.push(reader.bytes());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_merkle_root_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_merkle_root_arguments} verify_merkle_root_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_merkle_root_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_merkle_root_arguments message.
                 * @function verify
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_merkle_root_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.root != null && message.hasOwnProperty("root"))
                        if (!(message.root && typeof message.root.length === "number" || $util.isString(message.root)))
                            return "root: buffer expected";
                    if (message.hashes != null && message.hasOwnProperty("hashes")) {
                        if (!Array.isArray(message.hashes))
                            return "hashes: array expected";
                        for (var i = 0; i < message.hashes.length; ++i)
                            if (!(message.hashes[i] && typeof message.hashes[i].length === "number" || $util.isString(message.hashes[i])))
                                return "hashes: buffer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a verify_merkle_root_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_merkle_root_arguments} verify_merkle_root_arguments
                 */
                verify_merkle_root_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_merkle_root_arguments)
                        return object;
                    var message = new $root.koinos.chain.verify_merkle_root_arguments();
                    if (object.root != null)
                        if (typeof object.root === "string")
                            $util.base64.decode(object.root, message.root = $util.newBuffer($util.base64.length(object.root)), 0);
                        else if (object.root.length)
                            message.root = object.root;
                    if (object.hashes) {
                        if (!Array.isArray(object.hashes))
                            throw TypeError(".koinos.chain.verify_merkle_root_arguments.hashes: array expected");
                        message.hashes = [];
                        for (var i = 0; i < object.hashes.length; ++i)
                            if (typeof object.hashes[i] === "string")
                                $util.base64.decode(object.hashes[i], message.hashes[i] = $util.newBuffer($util.base64.length(object.hashes[i])), 0);
                            else if (object.hashes[i].length)
                                message.hashes[i] = object.hashes[i];
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_merkle_root_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @static
                 * @param {koinos.chain.verify_merkle_root_arguments} message verify_merkle_root_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_merkle_root_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.hashes = [];
                    if (options.defaults)
                        if (options.bytes === String)
                            object.root = "";
                        else {
                            object.root = [];
                            if (options.bytes !== Array)
                                object.root = $util.newBuffer(object.root);
                        }
                    if (message.root != null && message.hasOwnProperty("root"))
                        object.root = options.bytes === String ? $util.base64.encode(message.root, 0, message.root.length) : options.bytes === Array ? Array.prototype.slice.call(message.root) : message.root;
                    if (message.hashes && message.hashes.length) {
                        object.hashes = [];
                        for (var j = 0; j < message.hashes.length; ++j)
                            object.hashes[j] = options.bytes === String ? $util.base64.encode(message.hashes[j], 0, message.hashes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.hashes[j]) : message.hashes[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this verify_merkle_root_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_merkle_root_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_merkle_root_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_merkle_root_arguments;
            })();
    
            chain.verify_merkle_root_result = (function() {
    
                /**
                 * Properties of a verify_merkle_root_result.
                 * @memberof koinos.chain
                 * @interface Iverify_merkle_root_result
                 * @property {boolean|null} [value] verify_merkle_root_result value
                 */
    
                /**
                 * Constructs a new verify_merkle_root_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_merkle_root_result.
                 * @implements Iverify_merkle_root_result
                 * @constructor
                 * @param {koinos.chain.Iverify_merkle_root_result=} [properties] Properties to set
                 */
                function verify_merkle_root_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_merkle_root_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @instance
                 */
                verify_merkle_root_result.prototype.value = false;
    
                /**
                 * Creates a new verify_merkle_root_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {koinos.chain.Iverify_merkle_root_result=} [properties] Properties to set
                 * @returns {koinos.chain.verify_merkle_root_result} verify_merkle_root_result instance
                 */
                verify_merkle_root_result.create = function create(properties) {
                    return new verify_merkle_root_result(properties);
                };
    
                /**
                 * Encodes the specified verify_merkle_root_result message. Does not implicitly {@link koinos.chain.verify_merkle_root_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {koinos.chain.Iverify_merkle_root_result} message verify_merkle_root_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_merkle_root_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_merkle_root_result message, length delimited. Does not implicitly {@link koinos.chain.verify_merkle_root_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {koinos.chain.Iverify_merkle_root_result} message verify_merkle_root_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_merkle_root_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_merkle_root_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_merkle_root_result} verify_merkle_root_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_merkle_root_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_merkle_root_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_merkle_root_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_merkle_root_result} verify_merkle_root_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_merkle_root_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_merkle_root_result message.
                 * @function verify
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_merkle_root_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a verify_merkle_root_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_merkle_root_result} verify_merkle_root_result
                 */
                verify_merkle_root_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_merkle_root_result)
                        return object;
                    var message = new $root.koinos.chain.verify_merkle_root_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_merkle_root_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @static
                 * @param {koinos.chain.verify_merkle_root_result} message verify_merkle_root_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_merkle_root_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this verify_merkle_root_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_merkle_root_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_merkle_root_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_merkle_root_result;
            })();
    
            chain.verify_signature_arguments = (function() {
    
                /**
                 * Properties of a verify_signature_arguments.
                 * @memberof koinos.chain
                 * @interface Iverify_signature_arguments
                 * @property {koinos.chain.dsa|null} [type] verify_signature_arguments type
                 * @property {Uint8Array|null} [public_key] verify_signature_arguments public_key
                 * @property {Uint8Array|null} [signature] verify_signature_arguments signature
                 * @property {Uint8Array|null} [digest] verify_signature_arguments digest
                 */
    
                /**
                 * Constructs a new verify_signature_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_signature_arguments.
                 * @implements Iverify_signature_arguments
                 * @constructor
                 * @param {koinos.chain.Iverify_signature_arguments=} [properties] Properties to set
                 */
                function verify_signature_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_signature_arguments type.
                 * @member {koinos.chain.dsa} type
                 * @memberof koinos.chain.verify_signature_arguments
                 * @instance
                 */
                verify_signature_arguments.prototype.type = 0;
    
                /**
                 * verify_signature_arguments public_key.
                 * @member {Uint8Array} public_key
                 * @memberof koinos.chain.verify_signature_arguments
                 * @instance
                 */
                verify_signature_arguments.prototype.public_key = $util.newBuffer([]);
    
                /**
                 * verify_signature_arguments signature.
                 * @member {Uint8Array} signature
                 * @memberof koinos.chain.verify_signature_arguments
                 * @instance
                 */
                verify_signature_arguments.prototype.signature = $util.newBuffer([]);
    
                /**
                 * verify_signature_arguments digest.
                 * @member {Uint8Array} digest
                 * @memberof koinos.chain.verify_signature_arguments
                 * @instance
                 */
                verify_signature_arguments.prototype.digest = $util.newBuffer([]);
    
                /**
                 * Creates a new verify_signature_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {koinos.chain.Iverify_signature_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.verify_signature_arguments} verify_signature_arguments instance
                 */
                verify_signature_arguments.create = function create(properties) {
                    return new verify_signature_arguments(properties);
                };
    
                /**
                 * Encodes the specified verify_signature_arguments message. Does not implicitly {@link koinos.chain.verify_signature_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {koinos.chain.Iverify_signature_arguments} message verify_signature_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_signature_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.public_key != null && Object.hasOwnProperty.call(message, "public_key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.public_key);
                    if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                    if (message.digest != null && Object.hasOwnProperty.call(message, "digest"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.digest);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_signature_arguments message, length delimited. Does not implicitly {@link koinos.chain.verify_signature_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {koinos.chain.Iverify_signature_arguments} message verify_signature_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_signature_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_signature_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_signature_arguments} verify_signature_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_signature_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_signature_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.public_key = reader.bytes();
                            break;
                        case 3:
                            message.signature = reader.bytes();
                            break;
                        case 4:
                            message.digest = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_signature_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_signature_arguments} verify_signature_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_signature_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_signature_arguments message.
                 * @function verify
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_signature_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                            break;
                        }
                    if (message.public_key != null && message.hasOwnProperty("public_key"))
                        if (!(message.public_key && typeof message.public_key.length === "number" || $util.isString(message.public_key)))
                            return "public_key: buffer expected";
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                            return "signature: buffer expected";
                    if (message.digest != null && message.hasOwnProperty("digest"))
                        if (!(message.digest && typeof message.digest.length === "number" || $util.isString(message.digest)))
                            return "digest: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a verify_signature_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_signature_arguments} verify_signature_arguments
                 */
                verify_signature_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_signature_arguments)
                        return object;
                    var message = new $root.koinos.chain.verify_signature_arguments();
                    switch (object.type) {
                    case "ecdsa_secp256k1":
                    case 0:
                        message.type = 0;
                        break;
                    }
                    if (object.public_key != null)
                        if (typeof object.public_key === "string")
                            $util.base64.decode(object.public_key, message.public_key = $util.newBuffer($util.base64.length(object.public_key)), 0);
                        else if (object.public_key.length)
                            message.public_key = object.public_key;
                    if (object.signature != null)
                        if (typeof object.signature === "string")
                            $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                        else if (object.signature.length)
                            message.signature = object.signature;
                    if (object.digest != null)
                        if (typeof object.digest === "string")
                            $util.base64.decode(object.digest, message.digest = $util.newBuffer($util.base64.length(object.digest)), 0);
                        else if (object.digest.length)
                            message.digest = object.digest;
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_signature_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_signature_arguments
                 * @static
                 * @param {koinos.chain.verify_signature_arguments} message verify_signature_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_signature_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "ecdsa_secp256k1" : 0;
                        if (options.bytes === String)
                            object.public_key = "";
                        else {
                            object.public_key = [];
                            if (options.bytes !== Array)
                                object.public_key = $util.newBuffer(object.public_key);
                        }
                        if (options.bytes === String)
                            object.signature = "";
                        else {
                            object.signature = [];
                            if (options.bytes !== Array)
                                object.signature = $util.newBuffer(object.signature);
                        }
                        if (options.bytes === String)
                            object.digest = "";
                        else {
                            object.digest = [];
                            if (options.bytes !== Array)
                                object.digest = $util.newBuffer(object.digest);
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.koinos.chain.dsa[message.type] : message.type;
                    if (message.public_key != null && message.hasOwnProperty("public_key"))
                        object.public_key = options.bytes === String ? $util.base64.encode(message.public_key, 0, message.public_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_key) : message.public_key;
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                    if (message.digest != null && message.hasOwnProperty("digest"))
                        object.digest = options.bytes === String ? $util.base64.encode(message.digest, 0, message.digest.length) : options.bytes === Array ? Array.prototype.slice.call(message.digest) : message.digest;
                    return object;
                };
    
                /**
                 * Converts this verify_signature_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_signature_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_signature_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_signature_arguments;
            })();
    
            chain.verify_signature_result = (function() {
    
                /**
                 * Properties of a verify_signature_result.
                 * @memberof koinos.chain
                 * @interface Iverify_signature_result
                 * @property {boolean|null} [value] verify_signature_result value
                 */
    
                /**
                 * Constructs a new verify_signature_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_signature_result.
                 * @implements Iverify_signature_result
                 * @constructor
                 * @param {koinos.chain.Iverify_signature_result=} [properties] Properties to set
                 */
                function verify_signature_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_signature_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.verify_signature_result
                 * @instance
                 */
                verify_signature_result.prototype.value = false;
    
                /**
                 * Creates a new verify_signature_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {koinos.chain.Iverify_signature_result=} [properties] Properties to set
                 * @returns {koinos.chain.verify_signature_result} verify_signature_result instance
                 */
                verify_signature_result.create = function create(properties) {
                    return new verify_signature_result(properties);
                };
    
                /**
                 * Encodes the specified verify_signature_result message. Does not implicitly {@link koinos.chain.verify_signature_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {koinos.chain.Iverify_signature_result} message verify_signature_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_signature_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_signature_result message, length delimited. Does not implicitly {@link koinos.chain.verify_signature_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {koinos.chain.Iverify_signature_result} message verify_signature_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_signature_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_signature_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_signature_result} verify_signature_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_signature_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_signature_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_signature_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_signature_result} verify_signature_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_signature_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_signature_result message.
                 * @function verify
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_signature_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a verify_signature_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_signature_result} verify_signature_result
                 */
                verify_signature_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_signature_result)
                        return object;
                    var message = new $root.koinos.chain.verify_signature_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_signature_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_signature_result
                 * @static
                 * @param {koinos.chain.verify_signature_result} message verify_signature_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_signature_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this verify_signature_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_signature_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_signature_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_signature_result;
            })();
    
            chain.verify_vrf_proof_arguments = (function() {
    
                /**
                 * Properties of a verify_vrf_proof_arguments.
                 * @memberof koinos.chain
                 * @interface Iverify_vrf_proof_arguments
                 * @property {koinos.chain.dsa|null} [type] verify_vrf_proof_arguments type
                 * @property {Uint8Array|null} [public_key] verify_vrf_proof_arguments public_key
                 * @property {Uint8Array|null} [proof] verify_vrf_proof_arguments proof
                 * @property {Uint8Array|null} [hash] verify_vrf_proof_arguments hash
                 * @property {Uint8Array|null} [message] verify_vrf_proof_arguments message
                 */
    
                /**
                 * Constructs a new verify_vrf_proof_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_vrf_proof_arguments.
                 * @implements Iverify_vrf_proof_arguments
                 * @constructor
                 * @param {koinos.chain.Iverify_vrf_proof_arguments=} [properties] Properties to set
                 */
                function verify_vrf_proof_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_vrf_proof_arguments type.
                 * @member {koinos.chain.dsa} type
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @instance
                 */
                verify_vrf_proof_arguments.prototype.type = 0;
    
                /**
                 * verify_vrf_proof_arguments public_key.
                 * @member {Uint8Array} public_key
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @instance
                 */
                verify_vrf_proof_arguments.prototype.public_key = $util.newBuffer([]);
    
                /**
                 * verify_vrf_proof_arguments proof.
                 * @member {Uint8Array} proof
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @instance
                 */
                verify_vrf_proof_arguments.prototype.proof = $util.newBuffer([]);
    
                /**
                 * verify_vrf_proof_arguments hash.
                 * @member {Uint8Array} hash
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @instance
                 */
                verify_vrf_proof_arguments.prototype.hash = $util.newBuffer([]);
    
                /**
                 * verify_vrf_proof_arguments message.
                 * @member {Uint8Array} message
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @instance
                 */
                verify_vrf_proof_arguments.prototype.message = $util.newBuffer([]);
    
                /**
                 * Creates a new verify_vrf_proof_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {koinos.chain.Iverify_vrf_proof_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.verify_vrf_proof_arguments} verify_vrf_proof_arguments instance
                 */
                verify_vrf_proof_arguments.create = function create(properties) {
                    return new verify_vrf_proof_arguments(properties);
                };
    
                /**
                 * Encodes the specified verify_vrf_proof_arguments message. Does not implicitly {@link koinos.chain.verify_vrf_proof_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {koinos.chain.Iverify_vrf_proof_arguments} message verify_vrf_proof_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_vrf_proof_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.public_key != null && Object.hasOwnProperty.call(message, "public_key"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.public_key);
                    if (message.proof != null && Object.hasOwnProperty.call(message, "proof"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.proof);
                    if (message.hash != null && Object.hasOwnProperty.call(message, "hash"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.hash);
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.message);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_vrf_proof_arguments message, length delimited. Does not implicitly {@link koinos.chain.verify_vrf_proof_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {koinos.chain.Iverify_vrf_proof_arguments} message verify_vrf_proof_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_vrf_proof_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_vrf_proof_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_vrf_proof_arguments} verify_vrf_proof_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_vrf_proof_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_vrf_proof_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.public_key = reader.bytes();
                            break;
                        case 3:
                            message.proof = reader.bytes();
                            break;
                        case 4:
                            message.hash = reader.bytes();
                            break;
                        case 5:
                            message.message = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_vrf_proof_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_vrf_proof_arguments} verify_vrf_proof_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_vrf_proof_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_vrf_proof_arguments message.
                 * @function verify
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_vrf_proof_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                            break;
                        }
                    if (message.public_key != null && message.hasOwnProperty("public_key"))
                        if (!(message.public_key && typeof message.public_key.length === "number" || $util.isString(message.public_key)))
                            return "public_key: buffer expected";
                    if (message.proof != null && message.hasOwnProperty("proof"))
                        if (!(message.proof && typeof message.proof.length === "number" || $util.isString(message.proof)))
                            return "proof: buffer expected";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                            return "hash: buffer expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!(message.message && typeof message.message.length === "number" || $util.isString(message.message)))
                            return "message: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a verify_vrf_proof_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_vrf_proof_arguments} verify_vrf_proof_arguments
                 */
                verify_vrf_proof_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_vrf_proof_arguments)
                        return object;
                    var message = new $root.koinos.chain.verify_vrf_proof_arguments();
                    switch (object.type) {
                    case "ecdsa_secp256k1":
                    case 0:
                        message.type = 0;
                        break;
                    }
                    if (object.public_key != null)
                        if (typeof object.public_key === "string")
                            $util.base64.decode(object.public_key, message.public_key = $util.newBuffer($util.base64.length(object.public_key)), 0);
                        else if (object.public_key.length)
                            message.public_key = object.public_key;
                    if (object.proof != null)
                        if (typeof object.proof === "string")
                            $util.base64.decode(object.proof, message.proof = $util.newBuffer($util.base64.length(object.proof)), 0);
                        else if (object.proof.length)
                            message.proof = object.proof;
                    if (object.hash != null)
                        if (typeof object.hash === "string")
                            $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                        else if (object.hash.length)
                            message.hash = object.hash;
                    if (object.message != null)
                        if (typeof object.message === "string")
                            $util.base64.decode(object.message, message.message = $util.newBuffer($util.base64.length(object.message)), 0);
                        else if (object.message.length)
                            message.message = object.message;
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_vrf_proof_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @static
                 * @param {koinos.chain.verify_vrf_proof_arguments} message verify_vrf_proof_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_vrf_proof_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "ecdsa_secp256k1" : 0;
                        if (options.bytes === String)
                            object.public_key = "";
                        else {
                            object.public_key = [];
                            if (options.bytes !== Array)
                                object.public_key = $util.newBuffer(object.public_key);
                        }
                        if (options.bytes === String)
                            object.proof = "";
                        else {
                            object.proof = [];
                            if (options.bytes !== Array)
                                object.proof = $util.newBuffer(object.proof);
                        }
                        if (options.bytes === String)
                            object.hash = "";
                        else {
                            object.hash = [];
                            if (options.bytes !== Array)
                                object.hash = $util.newBuffer(object.hash);
                        }
                        if (options.bytes === String)
                            object.message = "";
                        else {
                            object.message = [];
                            if (options.bytes !== Array)
                                object.message = $util.newBuffer(object.message);
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.koinos.chain.dsa[message.type] : message.type;
                    if (message.public_key != null && message.hasOwnProperty("public_key"))
                        object.public_key = options.bytes === String ? $util.base64.encode(message.public_key, 0, message.public_key.length) : options.bytes === Array ? Array.prototype.slice.call(message.public_key) : message.public_key;
                    if (message.proof != null && message.hasOwnProperty("proof"))
                        object.proof = options.bytes === String ? $util.base64.encode(message.proof, 0, message.proof.length) : options.bytes === Array ? Array.prototype.slice.call(message.proof) : message.proof;
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = options.bytes === String ? $util.base64.encode(message.message, 0, message.message.length) : options.bytes === Array ? Array.prototype.slice.call(message.message) : message.message;
                    return object;
                };
    
                /**
                 * Converts this verify_vrf_proof_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_vrf_proof_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_vrf_proof_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_vrf_proof_arguments;
            })();
    
            chain.verify_vrf_proof_result = (function() {
    
                /**
                 * Properties of a verify_vrf_proof_result.
                 * @memberof koinos.chain
                 * @interface Iverify_vrf_proof_result
                 * @property {boolean|null} [value] verify_vrf_proof_result value
                 */
    
                /**
                 * Constructs a new verify_vrf_proof_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a verify_vrf_proof_result.
                 * @implements Iverify_vrf_proof_result
                 * @constructor
                 * @param {koinos.chain.Iverify_vrf_proof_result=} [properties] Properties to set
                 */
                function verify_vrf_proof_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * verify_vrf_proof_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @instance
                 */
                verify_vrf_proof_result.prototype.value = false;
    
                /**
                 * Creates a new verify_vrf_proof_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {koinos.chain.Iverify_vrf_proof_result=} [properties] Properties to set
                 * @returns {koinos.chain.verify_vrf_proof_result} verify_vrf_proof_result instance
                 */
                verify_vrf_proof_result.create = function create(properties) {
                    return new verify_vrf_proof_result(properties);
                };
    
                /**
                 * Encodes the specified verify_vrf_proof_result message. Does not implicitly {@link koinos.chain.verify_vrf_proof_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {koinos.chain.Iverify_vrf_proof_result} message verify_vrf_proof_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_vrf_proof_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified verify_vrf_proof_result message, length delimited. Does not implicitly {@link koinos.chain.verify_vrf_proof_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {koinos.chain.Iverify_vrf_proof_result} message verify_vrf_proof_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                verify_vrf_proof_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a verify_vrf_proof_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.verify_vrf_proof_result} verify_vrf_proof_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_vrf_proof_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.verify_vrf_proof_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a verify_vrf_proof_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.verify_vrf_proof_result} verify_vrf_proof_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                verify_vrf_proof_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a verify_vrf_proof_result message.
                 * @function verify
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                verify_vrf_proof_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a verify_vrf_proof_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.verify_vrf_proof_result} verify_vrf_proof_result
                 */
                verify_vrf_proof_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.verify_vrf_proof_result)
                        return object;
                    var message = new $root.koinos.chain.verify_vrf_proof_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a verify_vrf_proof_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @static
                 * @param {koinos.chain.verify_vrf_proof_result} message verify_vrf_proof_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                verify_vrf_proof_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this verify_vrf_proof_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.verify_vrf_proof_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                verify_vrf_proof_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return verify_vrf_proof_result;
            })();
    
            chain.call_arguments = (function() {
    
                /**
                 * Properties of a call_arguments.
                 * @memberof koinos.chain
                 * @interface Icall_arguments
                 * @property {Uint8Array|null} [contract_id] call_arguments contract_id
                 * @property {number|null} [entry_point] call_arguments entry_point
                 * @property {Uint8Array|null} [args] call_arguments args
                 */
    
                /**
                 * Constructs a new call_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a call_arguments.
                 * @implements Icall_arguments
                 * @constructor
                 * @param {koinos.chain.Icall_arguments=} [properties] Properties to set
                 */
                function call_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * call_arguments contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.chain.call_arguments
                 * @instance
                 */
                call_arguments.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * call_arguments entry_point.
                 * @member {number} entry_point
                 * @memberof koinos.chain.call_arguments
                 * @instance
                 */
                call_arguments.prototype.entry_point = 0;
    
                /**
                 * call_arguments args.
                 * @member {Uint8Array} args
                 * @memberof koinos.chain.call_arguments
                 * @instance
                 */
                call_arguments.prototype.args = $util.newBuffer([]);
    
                /**
                 * Creates a new call_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {koinos.chain.Icall_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.call_arguments} call_arguments instance
                 */
                call_arguments.create = function create(properties) {
                    return new call_arguments(properties);
                };
    
                /**
                 * Encodes the specified call_arguments message. Does not implicitly {@link koinos.chain.call_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {koinos.chain.Icall_arguments} message call_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.entry_point != null && Object.hasOwnProperty.call(message, "entry_point"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entry_point);
                    if (message.args != null && Object.hasOwnProperty.call(message, "args"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.args);
                    return writer;
                };
    
                /**
                 * Encodes the specified call_arguments message, length delimited. Does not implicitly {@link koinos.chain.call_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {koinos.chain.Icall_arguments} message call_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a call_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.call_arguments} call_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.call_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.entry_point = reader.uint32();
                            break;
                        case 3:
                            message.args = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a call_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.call_arguments} call_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a call_arguments message.
                 * @function verify
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                call_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        if (!$util.isInteger(message.entry_point))
                            return "entry_point: integer expected";
                    if (message.args != null && message.hasOwnProperty("args"))
                        if (!(message.args && typeof message.args.length === "number" || $util.isString(message.args)))
                            return "args: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a call_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.call_arguments} call_arguments
                 */
                call_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.call_arguments)
                        return object;
                    var message = new $root.koinos.chain.call_arguments();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.entry_point != null)
                        message.entry_point = object.entry_point >>> 0;
                    if (object.args != null)
                        if (typeof object.args === "string")
                            $util.base64.decode(object.args, message.args = $util.newBuffer($util.base64.length(object.args)), 0);
                        else if (object.args.length)
                            message.args = object.args;
                    return message;
                };
    
                /**
                 * Creates a plain object from a call_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.call_arguments
                 * @static
                 * @param {koinos.chain.call_arguments} message call_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                call_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        object.entry_point = 0;
                        if (options.bytes === String)
                            object.args = "";
                        else {
                            object.args = [];
                            if (options.bytes !== Array)
                                object.args = $util.newBuffer(object.args);
                        }
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        object.entry_point = message.entry_point;
                    if (message.args != null && message.hasOwnProperty("args"))
                        object.args = options.bytes === String ? $util.base64.encode(message.args, 0, message.args.length) : options.bytes === Array ? Array.prototype.slice.call(message.args) : message.args;
                    return object;
                };
    
                /**
                 * Converts this call_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.call_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                call_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return call_arguments;
            })();
    
            chain.call_result = (function() {
    
                /**
                 * Properties of a call_result.
                 * @memberof koinos.chain
                 * @interface Icall_result
                 * @property {Uint8Array|null} [value] call_result value
                 */
    
                /**
                 * Constructs a new call_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a call_result.
                 * @implements Icall_result
                 * @constructor
                 * @param {koinos.chain.Icall_result=} [properties] Properties to set
                 */
                function call_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * call_result value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.call_result
                 * @instance
                 */
                call_result.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new call_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {koinos.chain.Icall_result=} [properties] Properties to set
                 * @returns {koinos.chain.call_result} call_result instance
                 */
                call_result.create = function create(properties) {
                    return new call_result(properties);
                };
    
                /**
                 * Encodes the specified call_result message. Does not implicitly {@link koinos.chain.call_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {koinos.chain.Icall_result} message call_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified call_result message, length delimited. Does not implicitly {@link koinos.chain.call_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {koinos.chain.Icall_result} message call_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a call_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.call_result} call_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.call_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a call_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.call_result} call_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a call_result message.
                 * @function verify
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                call_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a call_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.call_result} call_result
                 */
                call_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.call_result)
                        return object;
                    var message = new $root.koinos.chain.call_result();
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a call_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.call_result
                 * @static
                 * @param {koinos.chain.call_result} message call_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                call_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this call_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.call_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                call_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return call_result;
            })();
    
            chain.get_arguments_arguments = (function() {
    
                /**
                 * Properties of a get_arguments_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_arguments_arguments
                 */
    
                /**
                 * Constructs a new get_arguments_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_arguments_arguments.
                 * @implements Iget_arguments_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_arguments_arguments=} [properties] Properties to set
                 */
                function get_arguments_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_arguments_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {koinos.chain.Iget_arguments_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_arguments_arguments} get_arguments_arguments instance
                 */
                get_arguments_arguments.create = function create(properties) {
                    return new get_arguments_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_arguments_arguments message. Does not implicitly {@link koinos.chain.get_arguments_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {koinos.chain.Iget_arguments_arguments} message get_arguments_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_arguments_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_arguments_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_arguments_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {koinos.chain.Iget_arguments_arguments} message get_arguments_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_arguments_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_arguments_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_arguments_arguments} get_arguments_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_arguments_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_arguments_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_arguments_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_arguments_arguments} get_arguments_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_arguments_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_arguments_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_arguments_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_arguments_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_arguments_arguments} get_arguments_arguments
                 */
                get_arguments_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_arguments_arguments)
                        return object;
                    return new $root.koinos.chain.get_arguments_arguments();
                };
    
                /**
                 * Creates a plain object from a get_arguments_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_arguments_arguments
                 * @static
                 * @param {koinos.chain.get_arguments_arguments} message get_arguments_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_arguments_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_arguments_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_arguments_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_arguments_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_arguments_arguments;
            })();
    
            chain.get_arguments_result = (function() {
    
                /**
                 * Properties of a get_arguments_result.
                 * @memberof koinos.chain
                 * @interface Iget_arguments_result
                 * @property {koinos.chain.Iargument_data|null} [value] get_arguments_result value
                 */
    
                /**
                 * Constructs a new get_arguments_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_arguments_result.
                 * @implements Iget_arguments_result
                 * @constructor
                 * @param {koinos.chain.Iget_arguments_result=} [properties] Properties to set
                 */
                function get_arguments_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_arguments_result value.
                 * @member {koinos.chain.Iargument_data|null|undefined} value
                 * @memberof koinos.chain.get_arguments_result
                 * @instance
                 */
                get_arguments_result.prototype.value = null;
    
                /**
                 * Creates a new get_arguments_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {koinos.chain.Iget_arguments_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_arguments_result} get_arguments_result instance
                 */
                get_arguments_result.create = function create(properties) {
                    return new get_arguments_result(properties);
                };
    
                /**
                 * Encodes the specified get_arguments_result message. Does not implicitly {@link koinos.chain.get_arguments_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {koinos.chain.Iget_arguments_result} message get_arguments_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_arguments_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.argument_data.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_arguments_result message, length delimited. Does not implicitly {@link koinos.chain.get_arguments_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {koinos.chain.Iget_arguments_result} message get_arguments_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_arguments_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_arguments_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_arguments_result} get_arguments_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_arguments_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_arguments_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.argument_data.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_arguments_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_arguments_result} get_arguments_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_arguments_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_arguments_result message.
                 * @function verify
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_arguments_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.argument_data.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_arguments_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_arguments_result} get_arguments_result
                 */
                get_arguments_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_arguments_result)
                        return object;
                    var message = new $root.koinos.chain.get_arguments_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_arguments_result.value: object expected");
                        message.value = $root.koinos.chain.argument_data.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_arguments_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_arguments_result
                 * @static
                 * @param {koinos.chain.get_arguments_result} message get_arguments_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_arguments_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.argument_data.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_arguments_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_arguments_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_arguments_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_arguments_result;
            })();
    
            chain.exit_arguments = (function() {
    
                /**
                 * Properties of an exit_arguments.
                 * @memberof koinos.chain
                 * @interface Iexit_arguments
                 * @property {number|null} [code] exit_arguments code
                 * @property {koinos.chain.Iresult|null} [res] exit_arguments res
                 */
    
                /**
                 * Constructs a new exit_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an exit_arguments.
                 * @implements Iexit_arguments
                 * @constructor
                 * @param {koinos.chain.Iexit_arguments=} [properties] Properties to set
                 */
                function exit_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * exit_arguments code.
                 * @member {number} code
                 * @memberof koinos.chain.exit_arguments
                 * @instance
                 */
                exit_arguments.prototype.code = 0;
    
                /**
                 * exit_arguments res.
                 * @member {koinos.chain.Iresult|null|undefined} res
                 * @memberof koinos.chain.exit_arguments
                 * @instance
                 */
                exit_arguments.prototype.res = null;
    
                /**
                 * Creates a new exit_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {koinos.chain.Iexit_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.exit_arguments} exit_arguments instance
                 */
                exit_arguments.create = function create(properties) {
                    return new exit_arguments(properties);
                };
    
                /**
                 * Encodes the specified exit_arguments message. Does not implicitly {@link koinos.chain.exit_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {koinos.chain.Iexit_arguments} message exit_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                exit_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                    if (message.res != null && Object.hasOwnProperty.call(message, "res"))
                        $root.koinos.chain.result.encode(message.res, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified exit_arguments message, length delimited. Does not implicitly {@link koinos.chain.exit_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {koinos.chain.Iexit_arguments} message exit_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                exit_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an exit_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.exit_arguments} exit_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                exit_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.exit_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.int32();
                            break;
                        case 2:
                            message.res = $root.koinos.chain.result.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an exit_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.exit_arguments} exit_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                exit_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an exit_arguments message.
                 * @function verify
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                exit_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isInteger(message.code))
                            return "code: integer expected";
                    if (message.res != null && message.hasOwnProperty("res")) {
                        var error = $root.koinos.chain.result.verify(message.res);
                        if (error)
                            return "res." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an exit_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.exit_arguments} exit_arguments
                 */
                exit_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.exit_arguments)
                        return object;
                    var message = new $root.koinos.chain.exit_arguments();
                    if (object.code != null)
                        message.code = object.code | 0;
                    if (object.res != null) {
                        if (typeof object.res !== "object")
                            throw TypeError(".koinos.chain.exit_arguments.res: object expected");
                        message.res = $root.koinos.chain.result.fromObject(object.res);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an exit_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.exit_arguments
                 * @static
                 * @param {koinos.chain.exit_arguments} message exit_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                exit_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.code = 0;
                        object.res = null;
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.res != null && message.hasOwnProperty("res"))
                        object.res = $root.koinos.chain.result.toObject(message.res, options);
                    return object;
                };
    
                /**
                 * Converts this exit_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.exit_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                exit_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return exit_arguments;
            })();
    
            chain.exit_result = (function() {
    
                /**
                 * Properties of an exit_result.
                 * @memberof koinos.chain
                 * @interface Iexit_result
                 */
    
                /**
                 * Constructs a new exit_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an exit_result.
                 * @implements Iexit_result
                 * @constructor
                 * @param {koinos.chain.Iexit_result=} [properties] Properties to set
                 */
                function exit_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new exit_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {koinos.chain.Iexit_result=} [properties] Properties to set
                 * @returns {koinos.chain.exit_result} exit_result instance
                 */
                exit_result.create = function create(properties) {
                    return new exit_result(properties);
                };
    
                /**
                 * Encodes the specified exit_result message. Does not implicitly {@link koinos.chain.exit_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {koinos.chain.Iexit_result} message exit_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                exit_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified exit_result message, length delimited. Does not implicitly {@link koinos.chain.exit_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {koinos.chain.Iexit_result} message exit_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                exit_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an exit_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.exit_result} exit_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                exit_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.exit_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an exit_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.exit_result} exit_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                exit_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an exit_result message.
                 * @function verify
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                exit_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an exit_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.exit_result} exit_result
                 */
                exit_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.exit_result)
                        return object;
                    return new $root.koinos.chain.exit_result();
                };
    
                /**
                 * Creates a plain object from an exit_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.exit_result
                 * @static
                 * @param {koinos.chain.exit_result} message exit_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                exit_result.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this exit_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.exit_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                exit_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return exit_result;
            })();
    
            chain.get_contract_id_arguments = (function() {
    
                /**
                 * Properties of a get_contract_id_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_contract_id_arguments
                 */
    
                /**
                 * Constructs a new get_contract_id_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_contract_id_arguments.
                 * @implements Iget_contract_id_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_contract_id_arguments=} [properties] Properties to set
                 */
                function get_contract_id_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_contract_id_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {koinos.chain.Iget_contract_id_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_contract_id_arguments} get_contract_id_arguments instance
                 */
                get_contract_id_arguments.create = function create(properties) {
                    return new get_contract_id_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_contract_id_arguments message. Does not implicitly {@link koinos.chain.get_contract_id_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {koinos.chain.Iget_contract_id_arguments} message get_contract_id_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_contract_id_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_contract_id_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_contract_id_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {koinos.chain.Iget_contract_id_arguments} message get_contract_id_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_contract_id_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_contract_id_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_contract_id_arguments} get_contract_id_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_contract_id_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_contract_id_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_contract_id_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_contract_id_arguments} get_contract_id_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_contract_id_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_contract_id_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_contract_id_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_contract_id_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_contract_id_arguments} get_contract_id_arguments
                 */
                get_contract_id_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_contract_id_arguments)
                        return object;
                    return new $root.koinos.chain.get_contract_id_arguments();
                };
    
                /**
                 * Creates a plain object from a get_contract_id_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @static
                 * @param {koinos.chain.get_contract_id_arguments} message get_contract_id_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_contract_id_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_contract_id_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_contract_id_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_contract_id_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_contract_id_arguments;
            })();
    
            chain.get_contract_id_result = (function() {
    
                /**
                 * Properties of a get_contract_id_result.
                 * @memberof koinos.chain
                 * @interface Iget_contract_id_result
                 * @property {Uint8Array|null} [value] get_contract_id_result value
                 */
    
                /**
                 * Constructs a new get_contract_id_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_contract_id_result.
                 * @implements Iget_contract_id_result
                 * @constructor
                 * @param {koinos.chain.Iget_contract_id_result=} [properties] Properties to set
                 */
                function get_contract_id_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_contract_id_result value.
                 * @member {Uint8Array} value
                 * @memberof koinos.chain.get_contract_id_result
                 * @instance
                 */
                get_contract_id_result.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new get_contract_id_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {koinos.chain.Iget_contract_id_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_contract_id_result} get_contract_id_result instance
                 */
                get_contract_id_result.create = function create(properties) {
                    return new get_contract_id_result(properties);
                };
    
                /**
                 * Encodes the specified get_contract_id_result message. Does not implicitly {@link koinos.chain.get_contract_id_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {koinos.chain.Iget_contract_id_result} message get_contract_id_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_contract_id_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified get_contract_id_result message, length delimited. Does not implicitly {@link koinos.chain.get_contract_id_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {koinos.chain.Iget_contract_id_result} message get_contract_id_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_contract_id_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_contract_id_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_contract_id_result} get_contract_id_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_contract_id_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_contract_id_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_contract_id_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_contract_id_result} get_contract_id_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_contract_id_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_contract_id_result message.
                 * @function verify
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_contract_id_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a get_contract_id_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_contract_id_result} get_contract_id_result
                 */
                get_contract_id_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_contract_id_result)
                        return object;
                    var message = new $root.koinos.chain.get_contract_id_result();
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_contract_id_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_contract_id_result
                 * @static
                 * @param {koinos.chain.get_contract_id_result} message get_contract_id_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_contract_id_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this get_contract_id_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_contract_id_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_contract_id_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_contract_id_result;
            })();
    
            chain.get_caller_arguments = (function() {
    
                /**
                 * Properties of a get_caller_arguments.
                 * @memberof koinos.chain
                 * @interface Iget_caller_arguments
                 */
    
                /**
                 * Constructs a new get_caller_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_caller_arguments.
                 * @implements Iget_caller_arguments
                 * @constructor
                 * @param {koinos.chain.Iget_caller_arguments=} [properties] Properties to set
                 */
                function get_caller_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new get_caller_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {koinos.chain.Iget_caller_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.get_caller_arguments} get_caller_arguments instance
                 */
                get_caller_arguments.create = function create(properties) {
                    return new get_caller_arguments(properties);
                };
    
                /**
                 * Encodes the specified get_caller_arguments message. Does not implicitly {@link koinos.chain.get_caller_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {koinos.chain.Iget_caller_arguments} message get_caller_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_caller_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_caller_arguments message, length delimited. Does not implicitly {@link koinos.chain.get_caller_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {koinos.chain.Iget_caller_arguments} message get_caller_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_caller_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_caller_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_caller_arguments} get_caller_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_caller_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_caller_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_caller_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_caller_arguments} get_caller_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_caller_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_caller_arguments message.
                 * @function verify
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_caller_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a get_caller_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_caller_arguments} get_caller_arguments
                 */
                get_caller_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_caller_arguments)
                        return object;
                    return new $root.koinos.chain.get_caller_arguments();
                };
    
                /**
                 * Creates a plain object from a get_caller_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_caller_arguments
                 * @static
                 * @param {koinos.chain.get_caller_arguments} message get_caller_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_caller_arguments.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this get_caller_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_caller_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_caller_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_caller_arguments;
            })();
    
            chain.get_caller_result = (function() {
    
                /**
                 * Properties of a get_caller_result.
                 * @memberof koinos.chain
                 * @interface Iget_caller_result
                 * @property {koinos.chain.Icaller_data|null} [value] get_caller_result value
                 */
    
                /**
                 * Constructs a new get_caller_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a get_caller_result.
                 * @implements Iget_caller_result
                 * @constructor
                 * @param {koinos.chain.Iget_caller_result=} [properties] Properties to set
                 */
                function get_caller_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * get_caller_result value.
                 * @member {koinos.chain.Icaller_data|null|undefined} value
                 * @memberof koinos.chain.get_caller_result
                 * @instance
                 */
                get_caller_result.prototype.value = null;
    
                /**
                 * Creates a new get_caller_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {koinos.chain.Iget_caller_result=} [properties] Properties to set
                 * @returns {koinos.chain.get_caller_result} get_caller_result instance
                 */
                get_caller_result.create = function create(properties) {
                    return new get_caller_result(properties);
                };
    
                /**
                 * Encodes the specified get_caller_result message. Does not implicitly {@link koinos.chain.get_caller_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {koinos.chain.Iget_caller_result} message get_caller_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_caller_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        $root.koinos.chain.caller_data.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified get_caller_result message, length delimited. Does not implicitly {@link koinos.chain.get_caller_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {koinos.chain.Iget_caller_result} message get_caller_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                get_caller_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a get_caller_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.get_caller_result} get_caller_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_caller_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.get_caller_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = $root.koinos.chain.caller_data.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a get_caller_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.get_caller_result} get_caller_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                get_caller_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a get_caller_result message.
                 * @function verify
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                get_caller_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        var error = $root.koinos.chain.caller_data.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a get_caller_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.get_caller_result} get_caller_result
                 */
                get_caller_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.get_caller_result)
                        return object;
                    var message = new $root.koinos.chain.get_caller_result();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".koinos.chain.get_caller_result.value: object expected");
                        message.value = $root.koinos.chain.caller_data.fromObject(object.value);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a get_caller_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.get_caller_result
                 * @static
                 * @param {koinos.chain.get_caller_result} message get_caller_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                get_caller_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.koinos.chain.caller_data.toObject(message.value, options);
                    return object;
                };
    
                /**
                 * Converts this get_caller_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.get_caller_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                get_caller_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return get_caller_result;
            })();
    
            chain.check_authority_arguments = (function() {
    
                /**
                 * Properties of a check_authority_arguments.
                 * @memberof koinos.chain
                 * @interface Icheck_authority_arguments
                 * @property {koinos.chain.authorization_type|null} [type] check_authority_arguments type
                 * @property {Uint8Array|null} [account] check_authority_arguments account
                 * @property {Uint8Array|null} [data] check_authority_arguments data
                 */
    
                /**
                 * Constructs a new check_authority_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents a check_authority_arguments.
                 * @implements Icheck_authority_arguments
                 * @constructor
                 * @param {koinos.chain.Icheck_authority_arguments=} [properties] Properties to set
                 */
                function check_authority_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * check_authority_arguments type.
                 * @member {koinos.chain.authorization_type} type
                 * @memberof koinos.chain.check_authority_arguments
                 * @instance
                 */
                check_authority_arguments.prototype.type = 0;
    
                /**
                 * check_authority_arguments account.
                 * @member {Uint8Array} account
                 * @memberof koinos.chain.check_authority_arguments
                 * @instance
                 */
                check_authority_arguments.prototype.account = $util.newBuffer([]);
    
                /**
                 * check_authority_arguments data.
                 * @member {Uint8Array} data
                 * @memberof koinos.chain.check_authority_arguments
                 * @instance
                 */
                check_authority_arguments.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new check_authority_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {koinos.chain.Icheck_authority_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.check_authority_arguments} check_authority_arguments instance
                 */
                check_authority_arguments.create = function create(properties) {
                    return new check_authority_arguments(properties);
                };
    
                /**
                 * Encodes the specified check_authority_arguments message. Does not implicitly {@link koinos.chain.check_authority_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {koinos.chain.Icheck_authority_arguments} message check_authority_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_authority_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.account);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Encodes the specified check_authority_arguments message, length delimited. Does not implicitly {@link koinos.chain.check_authority_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {koinos.chain.Icheck_authority_arguments} message check_authority_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_authority_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a check_authority_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.check_authority_arguments} check_authority_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_authority_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.check_authority_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.account = reader.bytes();
                            break;
                        case 3:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a check_authority_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.check_authority_arguments} check_authority_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_authority_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a check_authority_arguments message.
                 * @function verify
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                check_authority_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.account != null && message.hasOwnProperty("account"))
                        if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                            return "account: buffer expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a check_authority_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.check_authority_arguments} check_authority_arguments
                 */
                check_authority_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.check_authority_arguments)
                        return object;
                    var message = new $root.koinos.chain.check_authority_arguments();
                    switch (object.type) {
                    case "contract_call":
                    case 0:
                        message.type = 0;
                        break;
                    case "transaction_application":
                    case 1:
                        message.type = 1;
                        break;
                    case "contract_upload":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.account != null)
                        if (typeof object.account === "string")
                            $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                        else if (object.account.length)
                            message.account = object.account;
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };
    
                /**
                 * Creates a plain object from a check_authority_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.check_authority_arguments
                 * @static
                 * @param {koinos.chain.check_authority_arguments} message check_authority_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                check_authority_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "contract_call" : 0;
                        if (options.bytes === String)
                            object.account = "";
                        else {
                            object.account = [];
                            if (options.bytes !== Array)
                                object.account = $util.newBuffer(object.account);
                        }
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.koinos.chain.authorization_type[message.type] : message.type;
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };
    
                /**
                 * Converts this check_authority_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.check_authority_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                check_authority_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return check_authority_arguments;
            })();
    
            chain.check_authority_result = (function() {
    
                /**
                 * Properties of a check_authority_result.
                 * @memberof koinos.chain
                 * @interface Icheck_authority_result
                 * @property {boolean|null} [value] check_authority_result value
                 */
    
                /**
                 * Constructs a new check_authority_result.
                 * @memberof koinos.chain
                 * @classdesc Represents a check_authority_result.
                 * @implements Icheck_authority_result
                 * @constructor
                 * @param {koinos.chain.Icheck_authority_result=} [properties] Properties to set
                 */
                function check_authority_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * check_authority_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.check_authority_result
                 * @instance
                 */
                check_authority_result.prototype.value = false;
    
                /**
                 * Creates a new check_authority_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {koinos.chain.Icheck_authority_result=} [properties] Properties to set
                 * @returns {koinos.chain.check_authority_result} check_authority_result instance
                 */
                check_authority_result.create = function create(properties) {
                    return new check_authority_result(properties);
                };
    
                /**
                 * Encodes the specified check_authority_result message. Does not implicitly {@link koinos.chain.check_authority_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {koinos.chain.Icheck_authority_result} message check_authority_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_authority_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified check_authority_result message, length delimited. Does not implicitly {@link koinos.chain.check_authority_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {koinos.chain.Icheck_authority_result} message check_authority_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                check_authority_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a check_authority_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.check_authority_result} check_authority_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_authority_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.check_authority_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a check_authority_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.check_authority_result} check_authority_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                check_authority_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a check_authority_result message.
                 * @function verify
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                check_authority_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a check_authority_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.check_authority_result} check_authority_result
                 */
                check_authority_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.check_authority_result)
                        return object;
                    var message = new $root.koinos.chain.check_authority_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a check_authority_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.check_authority_result
                 * @static
                 * @param {koinos.chain.check_authority_result} message check_authority_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                check_authority_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this check_authority_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.check_authority_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                check_authority_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return check_authority_result;
            })();
    
            /**
             * system_space_id enum.
             * @name koinos.chain.system_space_id
             * @enum {number}
             * @property {number} metadata=0 metadata value
             * @property {number} system_call_dispatch=1 system_call_dispatch value
             * @property {number} contract_bytecode=2 contract_bytecode value
             * @property {number} contract_metadata=3 contract_metadata value
             * @property {number} transaction_nonce=4 transaction_nonce value
             */
            chain.system_space_id = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "metadata"] = 0;
                values[valuesById[1] = "system_call_dispatch"] = 1;
                values[valuesById[2] = "contract_bytecode"] = 2;
                values[valuesById[3] = "contract_metadata"] = 3;
                values[valuesById[4] = "transaction_nonce"] = 4;
                return values;
            })();
    
            /**
             * authorization_type enum.
             * @name koinos.chain.authorization_type
             * @enum {number}
             * @property {number} contract_call=0 contract_call value
             * @property {number} transaction_application=1 transaction_application value
             * @property {number} contract_upload=2 contract_upload value
             */
            chain.authorization_type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "contract_call"] = 0;
                values[valuesById[1] = "transaction_application"] = 1;
                values[valuesById[2] = "contract_upload"] = 2;
                return values;
            })();
    
            chain.call_data = (function() {
    
                /**
                 * Properties of a call_data.
                 * @memberof koinos.chain
                 * @interface Icall_data
                 * @property {Uint8Array|null} [contract_id] call_data contract_id
                 * @property {number|null} [entry_point] call_data entry_point
                 * @property {Uint8Array|null} [caller] call_data caller
                 * @property {Uint8Array|null} [data] call_data data
                 */
    
                /**
                 * Constructs a new call_data.
                 * @memberof koinos.chain
                 * @classdesc Represents a call_data.
                 * @implements Icall_data
                 * @constructor
                 * @param {koinos.chain.Icall_data=} [properties] Properties to set
                 */
                function call_data(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * call_data contract_id.
                 * @member {Uint8Array} contract_id
                 * @memberof koinos.chain.call_data
                 * @instance
                 */
                call_data.prototype.contract_id = $util.newBuffer([]);
    
                /**
                 * call_data entry_point.
                 * @member {number} entry_point
                 * @memberof koinos.chain.call_data
                 * @instance
                 */
                call_data.prototype.entry_point = 0;
    
                /**
                 * call_data caller.
                 * @member {Uint8Array} caller
                 * @memberof koinos.chain.call_data
                 * @instance
                 */
                call_data.prototype.caller = $util.newBuffer([]);
    
                /**
                 * call_data data.
                 * @member {Uint8Array} data
                 * @memberof koinos.chain.call_data
                 * @instance
                 */
                call_data.prototype.data = $util.newBuffer([]);
    
                /**
                 * Creates a new call_data instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {koinos.chain.Icall_data=} [properties] Properties to set
                 * @returns {koinos.chain.call_data} call_data instance
                 */
                call_data.create = function create(properties) {
                    return new call_data(properties);
                };
    
                /**
                 * Encodes the specified call_data message. Does not implicitly {@link koinos.chain.call_data.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {koinos.chain.Icall_data} message call_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_data.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.contract_id != null && Object.hasOwnProperty.call(message, "contract_id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contract_id);
                    if (message.entry_point != null && Object.hasOwnProperty.call(message, "entry_point"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.entry_point);
                    if (message.caller != null && Object.hasOwnProperty.call(message, "caller"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.caller);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
                    return writer;
                };
    
                /**
                 * Encodes the specified call_data message, length delimited. Does not implicitly {@link koinos.chain.call_data.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {koinos.chain.Icall_data} message call_data message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                call_data.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a call_data message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.call_data} call_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_data.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.call_data();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.contract_id = reader.bytes();
                            break;
                        case 2:
                            message.entry_point = reader.uint32();
                            break;
                        case 3:
                            message.caller = reader.bytes();
                            break;
                        case 4:
                            message.data = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a call_data message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.call_data} call_data
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                call_data.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a call_data message.
                 * @function verify
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                call_data.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        if (!(message.contract_id && typeof message.contract_id.length === "number" || $util.isString(message.contract_id)))
                            return "contract_id: buffer expected";
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        if (!$util.isInteger(message.entry_point))
                            return "entry_point: integer expected";
                    if (message.caller != null && message.hasOwnProperty("caller"))
                        if (!(message.caller && typeof message.caller.length === "number" || $util.isString(message.caller)))
                            return "caller: buffer expected";
                    if (message.data != null && message.hasOwnProperty("data"))
                        if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                            return "data: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a call_data message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.call_data} call_data
                 */
                call_data.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.call_data)
                        return object;
                    var message = new $root.koinos.chain.call_data();
                    if (object.contract_id != null)
                        if (typeof object.contract_id === "string")
                            $util.base64.decode(object.contract_id, message.contract_id = $util.newBuffer($util.base64.length(object.contract_id)), 0);
                        else if (object.contract_id.length)
                            message.contract_id = object.contract_id;
                    if (object.entry_point != null)
                        message.entry_point = object.entry_point >>> 0;
                    if (object.caller != null)
                        if (typeof object.caller === "string")
                            $util.base64.decode(object.caller, message.caller = $util.newBuffer($util.base64.length(object.caller)), 0);
                        else if (object.caller.length)
                            message.caller = object.caller;
                    if (object.data != null)
                        if (typeof object.data === "string")
                            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                        else if (object.data.length)
                            message.data = object.data;
                    return message;
                };
    
                /**
                 * Creates a plain object from a call_data message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.call_data
                 * @static
                 * @param {koinos.chain.call_data} message call_data
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                call_data.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.contract_id = "";
                        else {
                            object.contract_id = [];
                            if (options.bytes !== Array)
                                object.contract_id = $util.newBuffer(object.contract_id);
                        }
                        object.entry_point = 0;
                        if (options.bytes === String)
                            object.caller = "";
                        else {
                            object.caller = [];
                            if (options.bytes !== Array)
                                object.caller = $util.newBuffer(object.caller);
                        }
                        if (options.bytes === String)
                            object.data = "";
                        else {
                            object.data = [];
                            if (options.bytes !== Array)
                                object.data = $util.newBuffer(object.data);
                        }
                    }
                    if (message.contract_id != null && message.hasOwnProperty("contract_id"))
                        object.contract_id = options.bytes === String ? $util.base64.encode(message.contract_id, 0, message.contract_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_id) : message.contract_id;
                    if (message.entry_point != null && message.hasOwnProperty("entry_point"))
                        object.entry_point = message.entry_point;
                    if (message.caller != null && message.hasOwnProperty("caller"))
                        object.caller = options.bytes === String ? $util.base64.encode(message.caller, 0, message.caller.length) : options.bytes === Array ? Array.prototype.slice.call(message.caller) : message.caller;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                    return object;
                };
    
                /**
                 * Converts this call_data to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.call_data
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                call_data.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return call_data;
            })();
    
            chain.authorize_arguments = (function() {
    
                /**
                 * Properties of an authorize_arguments.
                 * @memberof koinos.chain
                 * @interface Iauthorize_arguments
                 * @property {koinos.chain.authorization_type|null} [type] authorize_arguments type
                 * @property {koinos.chain.Icall_data|null} [call] authorize_arguments call
                 */
    
                /**
                 * Constructs a new authorize_arguments.
                 * @memberof koinos.chain
                 * @classdesc Represents an authorize_arguments.
                 * @implements Iauthorize_arguments
                 * @constructor
                 * @param {koinos.chain.Iauthorize_arguments=} [properties] Properties to set
                 */
                function authorize_arguments(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * authorize_arguments type.
                 * @member {koinos.chain.authorization_type} type
                 * @memberof koinos.chain.authorize_arguments
                 * @instance
                 */
                authorize_arguments.prototype.type = 0;
    
                /**
                 * authorize_arguments call.
                 * @member {koinos.chain.Icall_data|null|undefined} call
                 * @memberof koinos.chain.authorize_arguments
                 * @instance
                 */
                authorize_arguments.prototype.call = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * authorize_arguments _call.
                 * @member {"call"|undefined} _call
                 * @memberof koinos.chain.authorize_arguments
                 * @instance
                 */
                Object.defineProperty(authorize_arguments.prototype, "_call", {
                    get: $util.oneOfGetter($oneOfFields = ["call"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new authorize_arguments instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {koinos.chain.Iauthorize_arguments=} [properties] Properties to set
                 * @returns {koinos.chain.authorize_arguments} authorize_arguments instance
                 */
                authorize_arguments.create = function create(properties) {
                    return new authorize_arguments(properties);
                };
    
                /**
                 * Encodes the specified authorize_arguments message. Does not implicitly {@link koinos.chain.authorize_arguments.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {koinos.chain.Iauthorize_arguments} message authorize_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                authorize_arguments.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.call != null && Object.hasOwnProperty.call(message, "call"))
                        $root.koinos.chain.call_data.encode(message.call, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified authorize_arguments message, length delimited. Does not implicitly {@link koinos.chain.authorize_arguments.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {koinos.chain.Iauthorize_arguments} message authorize_arguments message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                authorize_arguments.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an authorize_arguments message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.authorize_arguments} authorize_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                authorize_arguments.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.authorize_arguments();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.call = $root.koinos.chain.call_data.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an authorize_arguments message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.authorize_arguments} authorize_arguments
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                authorize_arguments.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an authorize_arguments message.
                 * @function verify
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                authorize_arguments.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.call != null && message.hasOwnProperty("call")) {
                        properties._call = 1;
                        {
                            var error = $root.koinos.chain.call_data.verify(message.call);
                            if (error)
                                return "call." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an authorize_arguments message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.authorize_arguments} authorize_arguments
                 */
                authorize_arguments.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.authorize_arguments)
                        return object;
                    var message = new $root.koinos.chain.authorize_arguments();
                    switch (object.type) {
                    case "contract_call":
                    case 0:
                        message.type = 0;
                        break;
                    case "transaction_application":
                    case 1:
                        message.type = 1;
                        break;
                    case "contract_upload":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.call != null) {
                        if (typeof object.call !== "object")
                            throw TypeError(".koinos.chain.authorize_arguments.call: object expected");
                        message.call = $root.koinos.chain.call_data.fromObject(object.call);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an authorize_arguments message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.authorize_arguments
                 * @static
                 * @param {koinos.chain.authorize_arguments} message authorize_arguments
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                authorize_arguments.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.type = options.enums === String ? "contract_call" : 0;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.koinos.chain.authorization_type[message.type] : message.type;
                    if (message.call != null && message.hasOwnProperty("call")) {
                        object.call = $root.koinos.chain.call_data.toObject(message.call, options);
                        if (options.oneofs)
                            object._call = "call";
                    }
                    return object;
                };
    
                /**
                 * Converts this authorize_arguments to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.authorize_arguments
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                authorize_arguments.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return authorize_arguments;
            })();
    
            chain.authorize_result = (function() {
    
                /**
                 * Properties of an authorize_result.
                 * @memberof koinos.chain
                 * @interface Iauthorize_result
                 * @property {boolean|null} [value] authorize_result value
                 */
    
                /**
                 * Constructs a new authorize_result.
                 * @memberof koinos.chain
                 * @classdesc Represents an authorize_result.
                 * @implements Iauthorize_result
                 * @constructor
                 * @param {koinos.chain.Iauthorize_result=} [properties] Properties to set
                 */
                function authorize_result(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * authorize_result value.
                 * @member {boolean} value
                 * @memberof koinos.chain.authorize_result
                 * @instance
                 */
                authorize_result.prototype.value = false;
    
                /**
                 * Creates a new authorize_result instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {koinos.chain.Iauthorize_result=} [properties] Properties to set
                 * @returns {koinos.chain.authorize_result} authorize_result instance
                 */
                authorize_result.create = function create(properties) {
                    return new authorize_result(properties);
                };
    
                /**
                 * Encodes the specified authorize_result message. Does not implicitly {@link koinos.chain.authorize_result.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {koinos.chain.Iauthorize_result} message authorize_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                authorize_result.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified authorize_result message, length delimited. Does not implicitly {@link koinos.chain.authorize_result.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {koinos.chain.Iauthorize_result} message authorize_result message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                authorize_result.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an authorize_result message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.authorize_result} authorize_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                authorize_result.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.authorize_result();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.value = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an authorize_result message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.authorize_result} authorize_result
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                authorize_result.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an authorize_result message.
                 * @function verify
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                authorize_result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "boolean")
                            return "value: boolean expected";
                    return null;
                };
    
                /**
                 * Creates an authorize_result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.authorize_result} authorize_result
                 */
                authorize_result.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.authorize_result)
                        return object;
                    var message = new $root.koinos.chain.authorize_result();
                    if (object.value != null)
                        message.value = Boolean(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an authorize_result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.authorize_result
                 * @static
                 * @param {koinos.chain.authorize_result} message authorize_result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                authorize_result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.value = false;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };
    
                /**
                 * Converts this authorize_result to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.authorize_result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                authorize_result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return authorize_result;
            })();
    
            chain.value_type = (function() {
    
                /**
                 * Properties of a value_type.
                 * @memberof koinos.chain
                 * @interface Ivalue_type
                 * @property {google.protobuf.IAny|null} [message_value] value_type message_value
                 * @property {number|null} [double_value] value_type double_value
                 * @property {number|null} [float_value] value_type float_value
                 * @property {number|null} [int32_value] value_type int32_value
                 * @property {number|Long|null} [int64_value] value_type int64_value
                 * @property {number|null} [uint32_value] value_type uint32_value
                 * @property {number|Long|null} [uint64_value] value_type uint64_value
                 * @property {number|null} [sint32_value] value_type sint32_value
                 * @property {number|Long|null} [sint64_value] value_type sint64_value
                 * @property {number|null} [fixed32_value] value_type fixed32_value
                 * @property {number|Long|null} [fixed64_value] value_type fixed64_value
                 * @property {number|null} [sfixed32_value] value_type sfixed32_value
                 * @property {number|Long|null} [sfixed64_value] value_type sfixed64_value
                 * @property {boolean|null} [bool_value] value_type bool_value
                 * @property {string|null} [string_value] value_type string_value
                 * @property {Uint8Array|null} [bytes_value] value_type bytes_value
                 */
    
                /**
                 * Constructs a new value_type.
                 * @memberof koinos.chain
                 * @classdesc Represents a value_type.
                 * @implements Ivalue_type
                 * @constructor
                 * @param {koinos.chain.Ivalue_type=} [properties] Properties to set
                 */
                function value_type(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * value_type message_value.
                 * @member {google.protobuf.IAny|null|undefined} message_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.message_value = null;
    
                /**
                 * value_type double_value.
                 * @member {number|null|undefined} double_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.double_value = null;
    
                /**
                 * value_type float_value.
                 * @member {number|null|undefined} float_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.float_value = null;
    
                /**
                 * value_type int32_value.
                 * @member {number|null|undefined} int32_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.int32_value = null;
    
                /**
                 * value_type int64_value.
                 * @member {number|Long|null|undefined} int64_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.int64_value = null;
    
                /**
                 * value_type uint32_value.
                 * @member {number|null|undefined} uint32_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.uint32_value = null;
    
                /**
                 * value_type uint64_value.
                 * @member {number|Long|null|undefined} uint64_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.uint64_value = null;
    
                /**
                 * value_type sint32_value.
                 * @member {number|null|undefined} sint32_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.sint32_value = null;
    
                /**
                 * value_type sint64_value.
                 * @member {number|Long|null|undefined} sint64_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.sint64_value = null;
    
                /**
                 * value_type fixed32_value.
                 * @member {number|null|undefined} fixed32_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.fixed32_value = null;
    
                /**
                 * value_type fixed64_value.
                 * @member {number|Long|null|undefined} fixed64_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.fixed64_value = null;
    
                /**
                 * value_type sfixed32_value.
                 * @member {number|null|undefined} sfixed32_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.sfixed32_value = null;
    
                /**
                 * value_type sfixed64_value.
                 * @member {number|Long|null|undefined} sfixed64_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.sfixed64_value = null;
    
                /**
                 * value_type bool_value.
                 * @member {boolean|null|undefined} bool_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.bool_value = null;
    
                /**
                 * value_type string_value.
                 * @member {string|null|undefined} string_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.string_value = null;
    
                /**
                 * value_type bytes_value.
                 * @member {Uint8Array|null|undefined} bytes_value
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                value_type.prototype.bytes_value = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * value_type kind.
                 * @member {"message_value"|"double_value"|"float_value"|"int32_value"|"int64_value"|"uint32_value"|"uint64_value"|"sint32_value"|"sint64_value"|"fixed32_value"|"fixed64_value"|"sfixed32_value"|"sfixed64_value"|"bool_value"|"string_value"|"bytes_value"|undefined} kind
                 * @memberof koinos.chain.value_type
                 * @instance
                 */
                Object.defineProperty(value_type.prototype, "kind", {
                    get: $util.oneOfGetter($oneOfFields = ["message_value", "double_value", "float_value", "int32_value", "int64_value", "uint32_value", "uint64_value", "sint32_value", "sint64_value", "fixed32_value", "fixed64_value", "sfixed32_value", "sfixed64_value", "bool_value", "string_value", "bytes_value"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new value_type instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {koinos.chain.Ivalue_type=} [properties] Properties to set
                 * @returns {koinos.chain.value_type} value_type instance
                 */
                value_type.create = function create(properties) {
                    return new value_type(properties);
                };
    
                /**
                 * Encodes the specified value_type message. Does not implicitly {@link koinos.chain.value_type.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {koinos.chain.Ivalue_type} message value_type message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                value_type.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_value != null && Object.hasOwnProperty.call(message, "message_value"))
                        $root.google.protobuf.Any.encode(message.message_value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.double_value);
                    if (message.float_value != null && Object.hasOwnProperty.call(message, "float_value"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.float_value);
                    if (message.int32_value != null && Object.hasOwnProperty.call(message, "int32_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.int32_value);
                    if (message.int64_value != null && Object.hasOwnProperty.call(message, "int64_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.int64_value);
                    if (message.uint32_value != null && Object.hasOwnProperty.call(message, "uint32_value"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uint32_value);
                    if (message.uint64_value != null && Object.hasOwnProperty.call(message, "uint64_value"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.uint64_value);
                    if (message.sint32_value != null && Object.hasOwnProperty.call(message, "sint32_value"))
                        writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.sint32_value);
                    if (message.sint64_value != null && Object.hasOwnProperty.call(message, "sint64_value"))
                        writer.uint32(/* id 9, wireType 0 =*/72).sint64(message.sint64_value);
                    if (message.fixed32_value != null && Object.hasOwnProperty.call(message, "fixed32_value"))
                        writer.uint32(/* id 10, wireType 5 =*/85).fixed32(message.fixed32_value);
                    if (message.fixed64_value != null && Object.hasOwnProperty.call(message, "fixed64_value"))
                        writer.uint32(/* id 11, wireType 1 =*/89).fixed64(message.fixed64_value);
                    if (message.sfixed32_value != null && Object.hasOwnProperty.call(message, "sfixed32_value"))
                        writer.uint32(/* id 12, wireType 5 =*/101).sfixed32(message.sfixed32_value);
                    if (message.sfixed64_value != null && Object.hasOwnProperty.call(message, "sfixed64_value"))
                        writer.uint32(/* id 13, wireType 1 =*/105).sfixed64(message.sfixed64_value);
                    if (message.bool_value != null && Object.hasOwnProperty.call(message, "bool_value"))
                        writer.uint32(/* id 14, wireType 0 =*/112).bool(message.bool_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 15, wireType 2 =*/122).string(message.string_value);
                    if (message.bytes_value != null && Object.hasOwnProperty.call(message, "bytes_value"))
                        writer.uint32(/* id 16, wireType 2 =*/130).bytes(message.bytes_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified value_type message, length delimited. Does not implicitly {@link koinos.chain.value_type.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {koinos.chain.Ivalue_type} message value_type message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                value_type.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a value_type message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.value_type} value_type
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                value_type.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.value_type();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_value = $root.google.protobuf.Any.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.double_value = reader.double();
                            break;
                        case 3:
                            message.float_value = reader.float();
                            break;
                        case 4:
                            message.int32_value = reader.int32();
                            break;
                        case 5:
                            message.int64_value = reader.int64();
                            break;
                        case 6:
                            message.uint32_value = reader.uint32();
                            break;
                        case 7:
                            message.uint64_value = reader.uint64();
                            break;
                        case 8:
                            message.sint32_value = reader.sint32();
                            break;
                        case 9:
                            message.sint64_value = reader.sint64();
                            break;
                        case 10:
                            message.fixed32_value = reader.fixed32();
                            break;
                        case 11:
                            message.fixed64_value = reader.fixed64();
                            break;
                        case 12:
                            message.sfixed32_value = reader.sfixed32();
                            break;
                        case 13:
                            message.sfixed64_value = reader.sfixed64();
                            break;
                        case 14:
                            message.bool_value = reader.bool();
                            break;
                        case 15:
                            message.string_value = reader.string();
                            break;
                        case 16:
                            message.bytes_value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a value_type message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.value_type} value_type
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                value_type.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a value_type message.
                 * @function verify
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                value_type.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.message_value != null && message.hasOwnProperty("message_value")) {
                        properties.kind = 1;
                        {
                            var error = $root.google.protobuf.Any.verify(message.message_value);
                            if (error)
                                return "message_value." + error;
                        }
                    }
                    if (message.double_value != null && message.hasOwnProperty("double_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    }
                    if (message.float_value != null && message.hasOwnProperty("float_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (typeof message.float_value !== "number")
                            return "float_value: number expected";
                    }
                    if (message.int32_value != null && message.hasOwnProperty("int32_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.int32_value))
                            return "int32_value: integer expected";
                    }
                    if (message.int64_value != null && message.hasOwnProperty("int64_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.int64_value) && !(message.int64_value && $util.isInteger(message.int64_value.low) && $util.isInteger(message.int64_value.high)))
                            return "int64_value: integer|Long expected";
                    }
                    if (message.uint32_value != null && message.hasOwnProperty("uint32_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.uint32_value))
                            return "uint32_value: integer expected";
                    }
                    if (message.uint64_value != null && message.hasOwnProperty("uint64_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.uint64_value) && !(message.uint64_value && $util.isInteger(message.uint64_value.low) && $util.isInteger(message.uint64_value.high)))
                            return "uint64_value: integer|Long expected";
                    }
                    if (message.sint32_value != null && message.hasOwnProperty("sint32_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.sint32_value))
                            return "sint32_value: integer expected";
                    }
                    if (message.sint64_value != null && message.hasOwnProperty("sint64_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.sint64_value) && !(message.sint64_value && $util.isInteger(message.sint64_value.low) && $util.isInteger(message.sint64_value.high)))
                            return "sint64_value: integer|Long expected";
                    }
                    if (message.fixed32_value != null && message.hasOwnProperty("fixed32_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.fixed32_value))
                            return "fixed32_value: integer expected";
                    }
                    if (message.fixed64_value != null && message.hasOwnProperty("fixed64_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.fixed64_value) && !(message.fixed64_value && $util.isInteger(message.fixed64_value.low) && $util.isInteger(message.fixed64_value.high)))
                            return "fixed64_value: integer|Long expected";
                    }
                    if (message.sfixed32_value != null && message.hasOwnProperty("sfixed32_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.sfixed32_value))
                            return "sfixed32_value: integer expected";
                    }
                    if (message.sfixed64_value != null && message.hasOwnProperty("sfixed64_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isInteger(message.sfixed64_value) && !(message.sfixed64_value && $util.isInteger(message.sfixed64_value.low) && $util.isInteger(message.sfixed64_value.high)))
                            return "sfixed64_value: integer|Long expected";
                    }
                    if (message.bool_value != null && message.hasOwnProperty("bool_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (typeof message.bool_value !== "boolean")
                            return "bool_value: boolean expected";
                    }
                    if (message.string_value != null && message.hasOwnProperty("string_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isString(message.string_value))
                            return "string_value: string expected";
                    }
                    if (message.bytes_value != null && message.hasOwnProperty("bytes_value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!(message.bytes_value && typeof message.bytes_value.length === "number" || $util.isString(message.bytes_value)))
                            return "bytes_value: buffer expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a value_type message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.value_type} value_type
                 */
                value_type.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.value_type)
                        return object;
                    var message = new $root.koinos.chain.value_type();
                    if (object.message_value != null) {
                        if (typeof object.message_value !== "object")
                            throw TypeError(".koinos.chain.value_type.message_value: object expected");
                        message.message_value = $root.google.protobuf.Any.fromObject(object.message_value);
                    }
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.float_value != null)
                        message.float_value = Number(object.float_value);
                    if (object.int32_value != null)
                        message.int32_value = object.int32_value | 0;
                    if (object.int64_value != null)
                        if ($util.Long)
                            (message.int64_value = $util.Long.fromValue(object.int64_value)).unsigned = false;
                        else if (typeof object.int64_value === "string")
                            message.int64_value = parseInt(object.int64_value, 10);
                        else if (typeof object.int64_value === "number")
                            message.int64_value = object.int64_value;
                        else if (typeof object.int64_value === "object")
                            message.int64_value = new $util.LongBits(object.int64_value.low >>> 0, object.int64_value.high >>> 0).toNumber();
                    if (object.uint32_value != null)
                        message.uint32_value = object.uint32_value >>> 0;
                    if (object.uint64_value != null)
                        if ($util.Long)
                            (message.uint64_value = $util.Long.fromValue(object.uint64_value)).unsigned = true;
                        else if (typeof object.uint64_value === "string")
                            message.uint64_value = parseInt(object.uint64_value, 10);
                        else if (typeof object.uint64_value === "number")
                            message.uint64_value = object.uint64_value;
                        else if (typeof object.uint64_value === "object")
                            message.uint64_value = new $util.LongBits(object.uint64_value.low >>> 0, object.uint64_value.high >>> 0).toNumber(true);
                    if (object.sint32_value != null)
                        message.sint32_value = object.sint32_value | 0;
                    if (object.sint64_value != null)
                        if ($util.Long)
                            (message.sint64_value = $util.Long.fromValue(object.sint64_value)).unsigned = false;
                        else if (typeof object.sint64_value === "string")
                            message.sint64_value = parseInt(object.sint64_value, 10);
                        else if (typeof object.sint64_value === "number")
                            message.sint64_value = object.sint64_value;
                        else if (typeof object.sint64_value === "object")
                            message.sint64_value = new $util.LongBits(object.sint64_value.low >>> 0, object.sint64_value.high >>> 0).toNumber();
                    if (object.fixed32_value != null)
                        message.fixed32_value = object.fixed32_value >>> 0;
                    if (object.fixed64_value != null)
                        if ($util.Long)
                            (message.fixed64_value = $util.Long.fromValue(object.fixed64_value)).unsigned = false;
                        else if (typeof object.fixed64_value === "string")
                            message.fixed64_value = parseInt(object.fixed64_value, 10);
                        else if (typeof object.fixed64_value === "number")
                            message.fixed64_value = object.fixed64_value;
                        else if (typeof object.fixed64_value === "object")
                            message.fixed64_value = new $util.LongBits(object.fixed64_value.low >>> 0, object.fixed64_value.high >>> 0).toNumber();
                    if (object.sfixed32_value != null)
                        message.sfixed32_value = object.sfixed32_value | 0;
                    if (object.sfixed64_value != null)
                        if ($util.Long)
                            (message.sfixed64_value = $util.Long.fromValue(object.sfixed64_value)).unsigned = false;
                        else if (typeof object.sfixed64_value === "string")
                            message.sfixed64_value = parseInt(object.sfixed64_value, 10);
                        else if (typeof object.sfixed64_value === "number")
                            message.sfixed64_value = object.sfixed64_value;
                        else if (typeof object.sfixed64_value === "object")
                            message.sfixed64_value = new $util.LongBits(object.sfixed64_value.low >>> 0, object.sfixed64_value.high >>> 0).toNumber();
                    if (object.bool_value != null)
                        message.bool_value = Boolean(object.bool_value);
                    if (object.string_value != null)
                        message.string_value = String(object.string_value);
                    if (object.bytes_value != null)
                        if (typeof object.bytes_value === "string")
                            $util.base64.decode(object.bytes_value, message.bytes_value = $util.newBuffer($util.base64.length(object.bytes_value)), 0);
                        else if (object.bytes_value.length)
                            message.bytes_value = object.bytes_value;
                    return message;
                };
    
                /**
                 * Creates a plain object from a value_type message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.value_type
                 * @static
                 * @param {koinos.chain.value_type} message value_type
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                value_type.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.message_value != null && message.hasOwnProperty("message_value")) {
                        object.message_value = $root.google.protobuf.Any.toObject(message.message_value, options);
                        if (options.oneofs)
                            object.kind = "message_value";
                    }
                    if (message.double_value != null && message.hasOwnProperty("double_value")) {
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                        if (options.oneofs)
                            object.kind = "double_value";
                    }
                    if (message.float_value != null && message.hasOwnProperty("float_value")) {
                        object.float_value = options.json && !isFinite(message.float_value) ? String(message.float_value) : message.float_value;
                        if (options.oneofs)
                            object.kind = "float_value";
                    }
                    if (message.int32_value != null && message.hasOwnProperty("int32_value")) {
                        object.int32_value = message.int32_value;
                        if (options.oneofs)
                            object.kind = "int32_value";
                    }
                    if (message.int64_value != null && message.hasOwnProperty("int64_value")) {
                        if (typeof message.int64_value === "number")
                            object.int64_value = options.longs === String ? String(message.int64_value) : message.int64_value;
                        else
                            object.int64_value = options.longs === String ? $util.Long.prototype.toString.call(message.int64_value) : options.longs === Number ? new $util.LongBits(message.int64_value.low >>> 0, message.int64_value.high >>> 0).toNumber() : message.int64_value;
                        if (options.oneofs)
                            object.kind = "int64_value";
                    }
                    if (message.uint32_value != null && message.hasOwnProperty("uint32_value")) {
                        object.uint32_value = message.uint32_value;
                        if (options.oneofs)
                            object.kind = "uint32_value";
                    }
                    if (message.uint64_value != null && message.hasOwnProperty("uint64_value")) {
                        if (typeof message.uint64_value === "number")
                            object.uint64_value = options.longs === String ? String(message.uint64_value) : message.uint64_value;
                        else
                            object.uint64_value = options.longs === String ? $util.Long.prototype.toString.call(message.uint64_value) : options.longs === Number ? new $util.LongBits(message.uint64_value.low >>> 0, message.uint64_value.high >>> 0).toNumber(true) : message.uint64_value;
                        if (options.oneofs)
                            object.kind = "uint64_value";
                    }
                    if (message.sint32_value != null && message.hasOwnProperty("sint32_value")) {
                        object.sint32_value = message.sint32_value;
                        if (options.oneofs)
                            object.kind = "sint32_value";
                    }
                    if (message.sint64_value != null && message.hasOwnProperty("sint64_value")) {
                        if (typeof message.sint64_value === "number")
                            object.sint64_value = options.longs === String ? String(message.sint64_value) : message.sint64_value;
                        else
                            object.sint64_value = options.longs === String ? $util.Long.prototype.toString.call(message.sint64_value) : options.longs === Number ? new $util.LongBits(message.sint64_value.low >>> 0, message.sint64_value.high >>> 0).toNumber() : message.sint64_value;
                        if (options.oneofs)
                            object.kind = "sint64_value";
                    }
                    if (message.fixed32_value != null && message.hasOwnProperty("fixed32_value")) {
                        object.fixed32_value = message.fixed32_value;
                        if (options.oneofs)
                            object.kind = "fixed32_value";
                    }
                    if (message.fixed64_value != null && message.hasOwnProperty("fixed64_value")) {
                        if (typeof message.fixed64_value === "number")
                            object.fixed64_value = options.longs === String ? String(message.fixed64_value) : message.fixed64_value;
                        else
                            object.fixed64_value = options.longs === String ? $util.Long.prototype.toString.call(message.fixed64_value) : options.longs === Number ? new $util.LongBits(message.fixed64_value.low >>> 0, message.fixed64_value.high >>> 0).toNumber() : message.fixed64_value;
                        if (options.oneofs)
                            object.kind = "fixed64_value";
                    }
                    if (message.sfixed32_value != null && message.hasOwnProperty("sfixed32_value")) {
                        object.sfixed32_value = message.sfixed32_value;
                        if (options.oneofs)
                            object.kind = "sfixed32_value";
                    }
                    if (message.sfixed64_value != null && message.hasOwnProperty("sfixed64_value")) {
                        if (typeof message.sfixed64_value === "number")
                            object.sfixed64_value = options.longs === String ? String(message.sfixed64_value) : message.sfixed64_value;
                        else
                            object.sfixed64_value = options.longs === String ? $util.Long.prototype.toString.call(message.sfixed64_value) : options.longs === Number ? new $util.LongBits(message.sfixed64_value.low >>> 0, message.sfixed64_value.high >>> 0).toNumber() : message.sfixed64_value;
                        if (options.oneofs)
                            object.kind = "sfixed64_value";
                    }
                    if (message.bool_value != null && message.hasOwnProperty("bool_value")) {
                        object.bool_value = message.bool_value;
                        if (options.oneofs)
                            object.kind = "bool_value";
                    }
                    if (message.string_value != null && message.hasOwnProperty("string_value")) {
                        object.string_value = message.string_value;
                        if (options.oneofs)
                            object.kind = "string_value";
                    }
                    if (message.bytes_value != null && message.hasOwnProperty("bytes_value")) {
                        object.bytes_value = options.bytes === String ? $util.base64.encode(message.bytes_value, 0, message.bytes_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytes_value) : message.bytes_value;
                        if (options.oneofs)
                            object.kind = "bytes_value";
                    }
                    return object;
                };
    
                /**
                 * Converts this value_type to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.value_type
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                value_type.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return value_type;
            })();
    
            chain.enum_type = (function() {
    
                /**
                 * Properties of an enum_type.
                 * @memberof koinos.chain
                 * @interface Ienum_type
                 * @property {string|null} [name] enum_type name
                 * @property {number|null} [number] enum_type number
                 */
    
                /**
                 * Constructs a new enum_type.
                 * @memberof koinos.chain
                 * @classdesc Represents an enum_type.
                 * @implements Ienum_type
                 * @constructor
                 * @param {koinos.chain.Ienum_type=} [properties] Properties to set
                 */
                function enum_type(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * enum_type name.
                 * @member {string} name
                 * @memberof koinos.chain.enum_type
                 * @instance
                 */
                enum_type.prototype.name = "";
    
                /**
                 * enum_type number.
                 * @member {number} number
                 * @memberof koinos.chain.enum_type
                 * @instance
                 */
                enum_type.prototype.number = 0;
    
                /**
                 * Creates a new enum_type instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {koinos.chain.Ienum_type=} [properties] Properties to set
                 * @returns {koinos.chain.enum_type} enum_type instance
                 */
                enum_type.create = function create(properties) {
                    return new enum_type(properties);
                };
    
                /**
                 * Encodes the specified enum_type message. Does not implicitly {@link koinos.chain.enum_type.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {koinos.chain.Ienum_type} message enum_type message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                enum_type.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    return writer;
                };
    
                /**
                 * Encodes the specified enum_type message, length delimited. Does not implicitly {@link koinos.chain.enum_type.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {koinos.chain.Ienum_type} message enum_type message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                enum_type.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an enum_type message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.enum_type} enum_type
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                enum_type.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.enum_type();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an enum_type message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.enum_type} enum_type
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                enum_type.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an enum_type message.
                 * @function verify
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                enum_type.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    return null;
                };
    
                /**
                 * Creates an enum_type message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.enum_type} enum_type
                 */
                enum_type.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.enum_type)
                        return object;
                    var message = new $root.koinos.chain.enum_type();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from an enum_type message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.enum_type
                 * @static
                 * @param {koinos.chain.enum_type} message enum_type
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                enum_type.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    return object;
                };
    
                /**
                 * Converts this enum_type to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.enum_type
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                enum_type.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return enum_type;
            })();
    
            chain.list_type = (function() {
    
                /**
                 * Properties of a list_type.
                 * @memberof koinos.chain
                 * @interface Ilist_type
                 * @property {Array.<koinos.chain.Ivalue_type>|null} [values] list_type values
                 */
    
                /**
                 * Constructs a new list_type.
                 * @memberof koinos.chain
                 * @classdesc Represents a list_type.
                 * @implements Ilist_type
                 * @constructor
                 * @param {koinos.chain.Ilist_type=} [properties] Properties to set
                 */
                function list_type(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * list_type values.
                 * @member {Array.<koinos.chain.Ivalue_type>} values
                 * @memberof koinos.chain.list_type
                 * @instance
                 */
                list_type.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new list_type instance using the specified properties.
                 * @function create
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {koinos.chain.Ilist_type=} [properties] Properties to set
                 * @returns {koinos.chain.list_type} list_type instance
                 */
                list_type.create = function create(properties) {
                    return new list_type(properties);
                };
    
                /**
                 * Encodes the specified list_type message. Does not implicitly {@link koinos.chain.list_type.verify|verify} messages.
                 * @function encode
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {koinos.chain.Ilist_type} message list_type message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                list_type.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            $root.koinos.chain.value_type.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified list_type message, length delimited. Does not implicitly {@link koinos.chain.list_type.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {koinos.chain.Ilist_type} message list_type message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                list_type.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a list_type message from the specified reader or buffer.
                 * @function decode
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {koinos.chain.list_type} list_type
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                list_type.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.koinos.chain.list_type();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.koinos.chain.value_type.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a list_type message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {koinos.chain.list_type} list_type
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                list_type.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a list_type message.
                 * @function verify
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                list_type.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i) {
                            var error = $root.koinos.chain.value_type.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a list_type message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {koinos.chain.list_type} list_type
                 */
                list_type.fromObject = function fromObject(object) {
                    if (object instanceof $root.koinos.chain.list_type)
                        return object;
                    var message = new $root.koinos.chain.list_type();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".koinos.chain.list_type.values: array expected");
                        message.values = [];
                        for (var i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".koinos.chain.list_type.values: object expected");
                            message.values[i] = $root.koinos.chain.value_type.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a list_type message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof koinos.chain.list_type
                 * @static
                 * @param {koinos.chain.list_type} message list_type
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                list_type.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (var j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.koinos.chain.value_type.toObject(message.values[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this list_type to JSON.
                 * @function toJSON
                 * @memberof koinos.chain.list_type
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                list_type.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return list_type;
            })();
    
            return chain;
        })();
    
        return koinos;
    })();
    
    $root.google = (function() {
    
        /**
         * Namespace google.
         * @exports google
         * @namespace
         */
        var google = {};
    
        google.protobuf = (function() {
    
            /**
             * Namespace protobuf.
             * @memberof google
             * @namespace
             */
            var protobuf = {};
    
            protobuf.FileDescriptorSet = (function() {
    
                /**
                 * Properties of a FileDescriptorSet.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorSet
                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
                 */
    
                /**
                 * Constructs a new FileDescriptorSet.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorSet.
                 * @implements IFileDescriptorSet
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 */
                function FileDescriptorSet(properties) {
                    this.file = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorSet file.
                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 */
                FileDescriptorSet.prototype.file = $util.emptyArray;
    
                /**
                 * Creates a new FileDescriptorSet instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
                 */
                FileDescriptorSet.create = function create(properties) {
                    return new FileDescriptorSet(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.file != null && message.file.length)
                        for (var i = 0; i < message.file.length; ++i)
                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorSet message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.file != null && message.hasOwnProperty("file")) {
                        if (!Array.isArray(message.file))
                            return "file: array expected";
                        for (var i = 0; i < message.file.length; ++i) {
                            var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                            if (error)
                                return "file." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
                 */
                FileDescriptorSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorSet)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorSet();
                    if (object.file) {
                        if (!Array.isArray(object.file))
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                        message.file = [];
                        for (var i = 0; i < object.file.length; ++i) {
                            if (typeof object.file[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                            message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorSet
                 * @static
                 * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.file = [];
                    if (message.file && message.file.length) {
                        object.file = [];
                        for (var j = 0; j < message.file.length; ++j)
                            object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorSet to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorSet;
            })();
    
            protobuf.FileDescriptorProto = (function() {
    
                /**
                 * Properties of a FileDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFileDescriptorProto
                 * @property {string|null} [name] FileDescriptorProto name
                 * @property {string|null} ["package"] FileDescriptorProto package
                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
                 * @property {Array.<number>|null} [public_dependency] FileDescriptorProto public_dependency
                 * @property {Array.<number>|null} [weak_dependency] FileDescriptorProto weak_dependency
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [message_type] FileDescriptorProto message_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] FileDescriptorProto enum_type
                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
                 * @property {google.protobuf.ISourceCodeInfo|null} [source_code_info] FileDescriptorProto source_code_info
                 * @property {string|null} [syntax] FileDescriptorProto syntax
                 */
    
                /**
                 * Constructs a new FileDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileDescriptorProto.
                 * @implements IFileDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 */
                function FileDescriptorProto(properties) {
                    this.dependency = [];
                    this.public_dependency = [];
                    this.weak_dependency = [];
                    this.message_type = [];
                    this.enum_type = [];
                    this.service = [];
                    this.extension = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.name = "";
    
                /**
                 * FileDescriptorProto package.
                 * @member {string} package
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype["package"] = "";
    
                /**
                 * FileDescriptorProto dependency.
                 * @member {Array.<string>} dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto public_dependency.
                 * @member {Array.<number>} public_dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.public_dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto weak_dependency.
                 * @member {Array.<number>} weak_dependency
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.weak_dependency = $util.emptyArray;
    
                /**
                 * FileDescriptorProto message_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} message_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.message_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * FileDescriptorProto service.
                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.service = $util.emptyArray;
    
                /**
                 * FileDescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * FileDescriptorProto options.
                 * @member {google.protobuf.IFileOptions|null|undefined} options
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.options = null;
    
                /**
                 * FileDescriptorProto source_code_info.
                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} source_code_info
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.source_code_info = null;
    
                /**
                 * FileDescriptorProto syntax.
                 * @member {string} syntax
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 */
                FileDescriptorProto.prototype.syntax = "";
    
                /**
                 * Creates a new FileDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
                 */
                FileDescriptorProto.create = function create(properties) {
                    return new FileDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                    if (message.dependency != null && message.dependency.length)
                        for (var i = 0; i < message.dependency.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                    if (message.message_type != null && message.message_type.length)
                        for (var i = 0; i < message.message_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.message_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.service != null && message.service.length)
                        for (var i = 0; i < message.service.length; ++i)
                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.source_code_info != null && Object.hasOwnProperty.call(message, "source_code_info"))
                        $root.google.protobuf.SourceCodeInfo.encode(message.source_code_info, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.public_dependency != null && message.public_dependency.length)
                        for (var i = 0; i < message.public_dependency.length; ++i)
                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.public_dependency[i]);
                    if (message.weak_dependency != null && message.weak_dependency.length)
                        for (var i = 0; i < message.weak_dependency.length; ++i)
                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weak_dependency[i]);
                    if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                    return writer;
                };
    
                /**
                 * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 10:
                            if (!(message.public_dependency && message.public_dependency.length))
                                message.public_dependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.public_dependency.push(reader.int32());
                            } else
                                message.public_dependency.push(reader.int32());
                            break;
                        case 11:
                            if (!(message.weak_dependency && message.weak_dependency.length))
                                message.weak_dependency = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weak_dependency.push(reader.int32());
                            } else
                                message.weak_dependency.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.message_type && message.message_type.length))
                                message.message_type = [];
                            message.message_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.source_code_info = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.syntax = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        if (!$util.isString(message["package"]))
                            return "package: string expected";
                    if (message.dependency != null && message.hasOwnProperty("dependency")) {
                        if (!Array.isArray(message.dependency))
                            return "dependency: array expected";
                        for (var i = 0; i < message.dependency.length; ++i)
                            if (!$util.isString(message.dependency[i]))
                                return "dependency: string[] expected";
                    }
                    if (message.public_dependency != null && message.hasOwnProperty("public_dependency")) {
                        if (!Array.isArray(message.public_dependency))
                            return "public_dependency: array expected";
                        for (var i = 0; i < message.public_dependency.length; ++i)
                            if (!$util.isInteger(message.public_dependency[i]))
                                return "public_dependency: integer[] expected";
                    }
                    if (message.weak_dependency != null && message.hasOwnProperty("weak_dependency")) {
                        if (!Array.isArray(message.weak_dependency))
                            return "weak_dependency: array expected";
                        for (var i = 0; i < message.weak_dependency.length; ++i)
                            if (!$util.isInteger(message.weak_dependency[i]))
                                return "weak_dependency: integer[] expected";
                    }
                    if (message.message_type != null && message.hasOwnProperty("message_type")) {
                        if (!Array.isArray(message.message_type))
                            return "message_type: array expected";
                        for (var i = 0; i < message.message_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.message_type[i]);
                            if (error)
                                return "message_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.service != null && message.hasOwnProperty("service")) {
                        if (!Array.isArray(message.service))
                            return "service: array expected";
                        for (var i = 0; i < message.service.length; ++i) {
                            var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                            if (error)
                                return "service." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FileOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info")) {
                        var error = $root.google.protobuf.SourceCodeInfo.verify(message.source_code_info);
                        if (error)
                            return "source_code_info." + error;
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        if (!$util.isString(message.syntax))
                            return "syntax: string expected";
                    return null;
                };
    
                /**
                 * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
                 */
                FileDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FileDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object["package"] != null)
                        message["package"] = String(object["package"]);
                    if (object.dependency) {
                        if (!Array.isArray(object.dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                        message.dependency = [];
                        for (var i = 0; i < object.dependency.length; ++i)
                            message.dependency[i] = String(object.dependency[i]);
                    }
                    if (object.public_dependency) {
                        if (!Array.isArray(object.public_dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.public_dependency: array expected");
                        message.public_dependency = [];
                        for (var i = 0; i < object.public_dependency.length; ++i)
                            message.public_dependency[i] = object.public_dependency[i] | 0;
                    }
                    if (object.weak_dependency) {
                        if (!Array.isArray(object.weak_dependency))
                            throw TypeError(".google.protobuf.FileDescriptorProto.weak_dependency: array expected");
                        message.weak_dependency = [];
                        for (var i = 0; i < object.weak_dependency.length; ++i)
                            message.weak_dependency[i] = object.weak_dependency[i] | 0;
                    }
                    if (object.message_type) {
                        if (!Array.isArray(object.message_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.message_type: array expected");
                        message.message_type = [];
                        for (var i = 0; i < object.message_type.length; ++i) {
                            if (typeof object.message_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.message_type: object expected");
                            message.message_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.message_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.service) {
                        if (!Array.isArray(object.service))
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                        message.service = [];
                        for (var i = 0; i < object.service.length; ++i) {
                            if (typeof object.service[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                            message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                    }
                    if (object.source_code_info != null) {
                        if (typeof object.source_code_info !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.source_code_info: object expected");
                        message.source_code_info = $root.google.protobuf.SourceCodeInfo.fromObject(object.source_code_info);
                    }
                    if (object.syntax != null)
                        message.syntax = String(object.syntax);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileDescriptorProto
                 * @static
                 * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.dependency = [];
                        object.message_type = [];
                        object.enum_type = [];
                        object.service = [];
                        object.extension = [];
                        object.public_dependency = [];
                        object.weak_dependency = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object["package"] = "";
                        object.options = null;
                        object.source_code_info = null;
                        object.syntax = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message["package"] != null && message.hasOwnProperty("package"))
                        object["package"] = message["package"];
                    if (message.dependency && message.dependency.length) {
                        object.dependency = [];
                        for (var j = 0; j < message.dependency.length; ++j)
                            object.dependency[j] = message.dependency[j];
                    }
                    if (message.message_type && message.message_type.length) {
                        object.message_type = [];
                        for (var j = 0; j < message.message_type.length; ++j)
                            object.message_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.message_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.service && message.service.length) {
                        object.service = [];
                        for (var j = 0; j < message.service.length; ++j)
                            object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                    if (message.source_code_info != null && message.hasOwnProperty("source_code_info"))
                        object.source_code_info = $root.google.protobuf.SourceCodeInfo.toObject(message.source_code_info, options);
                    if (message.public_dependency && message.public_dependency.length) {
                        object.public_dependency = [];
                        for (var j = 0; j < message.public_dependency.length; ++j)
                            object.public_dependency[j] = message.public_dependency[j];
                    }
                    if (message.weak_dependency && message.weak_dependency.length) {
                        object.weak_dependency = [];
                        for (var j = 0; j < message.weak_dependency.length; ++j)
                            object.weak_dependency[j] = message.weak_dependency[j];
                    }
                    if (message.syntax != null && message.hasOwnProperty("syntax"))
                        object.syntax = message.syntax;
                    return object;
                };
    
                /**
                 * Converts this FileDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FileDescriptorProto;
            })();
    
            protobuf.DescriptorProto = (function() {
    
                /**
                 * Properties of a DescriptorProto.
                 * @memberof google.protobuf
                 * @interface IDescriptorProto
                 * @property {string|null} [name] DescriptorProto name
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nested_type] DescriptorProto nested_type
                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enum_type] DescriptorProto enum_type
                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extension_range] DescriptorProto extension_range
                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneof_decl] DescriptorProto oneof_decl
                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reserved_range] DescriptorProto reserved_range
                 * @property {Array.<string>|null} [reserved_name] DescriptorProto reserved_name
                 */
    
                /**
                 * Constructs a new DescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a DescriptorProto.
                 * @implements IDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 */
                function DescriptorProto(properties) {
                    this.field = [];
                    this.extension = [];
                    this.nested_type = [];
                    this.enum_type = [];
                    this.extension_range = [];
                    this.oneof_decl = [];
                    this.reserved_range = [];
                    this.reserved_name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.name = "";
    
                /**
                 * DescriptorProto field.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.field = $util.emptyArray;
    
                /**
                 * DescriptorProto extension.
                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension = $util.emptyArray;
    
                /**
                 * DescriptorProto nested_type.
                 * @member {Array.<google.protobuf.IDescriptorProto>} nested_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.nested_type = $util.emptyArray;
    
                /**
                 * DescriptorProto enum_type.
                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enum_type
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.enum_type = $util.emptyArray;
    
                /**
                 * DescriptorProto extension_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extension_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.extension_range = $util.emptyArray;
    
                /**
                 * DescriptorProto oneof_decl.
                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneof_decl
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.oneof_decl = $util.emptyArray;
    
                /**
                 * DescriptorProto options.
                 * @member {google.protobuf.IMessageOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.options = null;
    
                /**
                 * DescriptorProto reserved_range.
                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reserved_range
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reserved_range = $util.emptyArray;
    
                /**
                 * DescriptorProto reserved_name.
                 * @member {Array.<string>} reserved_name
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 */
                DescriptorProto.prototype.reserved_name = $util.emptyArray;
    
                /**
                 * Creates a new DescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
                 */
                DescriptorProto.create = function create(properties) {
                    return new DescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.field != null && message.field.length)
                        for (var i = 0; i < message.field.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.nested_type != null && message.nested_type.length)
                        for (var i = 0; i < message.nested_type.length; ++i)
                            $root.google.protobuf.DescriptorProto.encode(message.nested_type[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.enum_type != null && message.enum_type.length)
                        for (var i = 0; i < message.enum_type.length; ++i)
                            $root.google.protobuf.EnumDescriptorProto.encode(message.enum_type[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.extension_range != null && message.extension_range.length)
                        for (var i = 0; i < message.extension_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extension_range[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.extension != null && message.extension.length)
                        for (var i = 0; i < message.extension.length; ++i)
                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.oneof_decl != null && message.oneof_decl.length)
                        for (var i = 0; i < message.oneof_decl.length; ++i)
                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneof_decl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.reserved_range != null && message.reserved_range.length)
                        for (var i = 0; i < message.reserved_range.length; ++i)
                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reserved_range[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.reserved_name != null && message.reserved_name.length)
                        for (var i = 0; i < message.reserved_name.length; ++i)
                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reserved_name[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nested_type && message.nested_type.length))
                                message.nested_type = [];
                            message.nested_type.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enum_type && message.enum_type.length))
                                message.enum_type = [];
                            message.enum_type.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extension_range && message.extension_range.length))
                                message.extension_range = [];
                            message.extension_range.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.oneof_decl && message.oneof_decl.length))
                                message.oneof_decl = [];
                            message.oneof_decl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.reserved_range && message.reserved_range.length))
                                message.reserved_range = [];
                            message.reserved_range.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.reserved_name && message.reserved_name.length))
                                message.reserved_name = [];
                            message.reserved_name.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.field != null && message.hasOwnProperty("field")) {
                        if (!Array.isArray(message.field))
                            return "field: array expected";
                        for (var i = 0; i < message.field.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                            if (error)
                                return "field." + error;
                        }
                    }
                    if (message.extension != null && message.hasOwnProperty("extension")) {
                        if (!Array.isArray(message.extension))
                            return "extension: array expected";
                        for (var i = 0; i < message.extension.length; ++i) {
                            var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                            if (error)
                                return "extension." + error;
                        }
                    }
                    if (message.nested_type != null && message.hasOwnProperty("nested_type")) {
                        if (!Array.isArray(message.nested_type))
                            return "nested_type: array expected";
                        for (var i = 0; i < message.nested_type.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.verify(message.nested_type[i]);
                            if (error)
                                return "nested_type." + error;
                        }
                    }
                    if (message.enum_type != null && message.hasOwnProperty("enum_type")) {
                        if (!Array.isArray(message.enum_type))
                            return "enum_type: array expected";
                        for (var i = 0; i < message.enum_type.length; ++i) {
                            var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enum_type[i]);
                            if (error)
                                return "enum_type." + error;
                        }
                    }
                    if (message.extension_range != null && message.hasOwnProperty("extension_range")) {
                        if (!Array.isArray(message.extension_range))
                            return "extension_range: array expected";
                        for (var i = 0; i < message.extension_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extension_range[i]);
                            if (error)
                                return "extension_range." + error;
                        }
                    }
                    if (message.oneof_decl != null && message.hasOwnProperty("oneof_decl")) {
                        if (!Array.isArray(message.oneof_decl))
                            return "oneof_decl: array expected";
                        for (var i = 0; i < message.oneof_decl.length; ++i) {
                            var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneof_decl[i]);
                            if (error)
                                return "oneof_decl." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MessageOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.reserved_range != null && message.hasOwnProperty("reserved_range")) {
                        if (!Array.isArray(message.reserved_range))
                            return "reserved_range: array expected";
                        for (var i = 0; i < message.reserved_range.length; ++i) {
                            var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reserved_range[i]);
                            if (error)
                                return "reserved_range." + error;
                        }
                    }
                    if (message.reserved_name != null && message.hasOwnProperty("reserved_name")) {
                        if (!Array.isArray(message.reserved_name))
                            return "reserved_name: array expected";
                        for (var i = 0; i < message.reserved_name.length; ++i)
                            if (!$util.isString(message.reserved_name[i]))
                                return "reserved_name: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto} DescriptorProto
                 */
                DescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.field) {
                        if (!Array.isArray(object.field))
                            throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                        message.field = [];
                        for (var i = 0; i < object.field.length; ++i) {
                            if (typeof object.field[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                            message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                        }
                    }
                    if (object.extension) {
                        if (!Array.isArray(object.extension))
                            throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                        message.extension = [];
                        for (var i = 0; i < object.extension.length; ++i) {
                            if (typeof object.extension[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                            message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                        }
                    }
                    if (object.nested_type) {
                        if (!Array.isArray(object.nested_type))
                            throw TypeError(".google.protobuf.DescriptorProto.nested_type: array expected");
                        message.nested_type = [];
                        for (var i = 0; i < object.nested_type.length; ++i) {
                            if (typeof object.nested_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.nested_type: object expected");
                            message.nested_type[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nested_type[i]);
                        }
                    }
                    if (object.enum_type) {
                        if (!Array.isArray(object.enum_type))
                            throw TypeError(".google.protobuf.DescriptorProto.enum_type: array expected");
                        message.enum_type = [];
                        for (var i = 0; i < object.enum_type.length; ++i) {
                            if (typeof object.enum_type[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.enum_type: object expected");
                            message.enum_type[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enum_type[i]);
                        }
                    }
                    if (object.extension_range) {
                        if (!Array.isArray(object.extension_range))
                            throw TypeError(".google.protobuf.DescriptorProto.extension_range: array expected");
                        message.extension_range = [];
                        for (var i = 0; i < object.extension_range.length; ++i) {
                            if (typeof object.extension_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.extension_range: object expected");
                            message.extension_range[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extension_range[i]);
                        }
                    }
                    if (object.oneof_decl) {
                        if (!Array.isArray(object.oneof_decl))
                            throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: array expected");
                        message.oneof_decl = [];
                        for (var i = 0; i < object.oneof_decl.length; ++i) {
                            if (typeof object.oneof_decl[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.oneof_decl: object expected");
                            message.oneof_decl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneof_decl[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                    }
                    if (object.reserved_range) {
                        if (!Array.isArray(object.reserved_range))
                            throw TypeError(".google.protobuf.DescriptorProto.reserved_range: array expected");
                        message.reserved_range = [];
                        for (var i = 0; i < object.reserved_range.length; ++i) {
                            if (typeof object.reserved_range[i] !== "object")
                                throw TypeError(".google.protobuf.DescriptorProto.reserved_range: object expected");
                            message.reserved_range[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reserved_range[i]);
                        }
                    }
                    if (object.reserved_name) {
                        if (!Array.isArray(object.reserved_name))
                            throw TypeError(".google.protobuf.DescriptorProto.reserved_name: array expected");
                        message.reserved_name = [];
                        for (var i = 0; i < object.reserved_name.length; ++i)
                            message.reserved_name[i] = String(object.reserved_name[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto
                 * @static
                 * @param {google.protobuf.DescriptorProto} message DescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.field = [];
                        object.nested_type = [];
                        object.enum_type = [];
                        object.extension_range = [];
                        object.extension = [];
                        object.oneof_decl = [];
                        object.reserved_range = [];
                        object.reserved_name = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.field && message.field.length) {
                        object.field = [];
                        for (var j = 0; j < message.field.length; ++j)
                            object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                    }
                    if (message.nested_type && message.nested_type.length) {
                        object.nested_type = [];
                        for (var j = 0; j < message.nested_type.length; ++j)
                            object.nested_type[j] = $root.google.protobuf.DescriptorProto.toObject(message.nested_type[j], options);
                    }
                    if (message.enum_type && message.enum_type.length) {
                        object.enum_type = [];
                        for (var j = 0; j < message.enum_type.length; ++j)
                            object.enum_type[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enum_type[j], options);
                    }
                    if (message.extension_range && message.extension_range.length) {
                        object.extension_range = [];
                        for (var j = 0; j < message.extension_range.length; ++j)
                            object.extension_range[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extension_range[j], options);
                    }
                    if (message.extension && message.extension.length) {
                        object.extension = [];
                        for (var j = 0; j < message.extension.length; ++j)
                            object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                    if (message.oneof_decl && message.oneof_decl.length) {
                        object.oneof_decl = [];
                        for (var j = 0; j < message.oneof_decl.length; ++j)
                            object.oneof_decl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneof_decl[j], options);
                    }
                    if (message.reserved_range && message.reserved_range.length) {
                        object.reserved_range = [];
                        for (var j = 0; j < message.reserved_range.length; ++j)
                            object.reserved_range[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reserved_range[j], options);
                    }
                    if (message.reserved_name && message.reserved_name.length) {
                        object.reserved_name = [];
                        for (var j = 0; j < message.reserved_name.length; ++j)
                            object.reserved_name[j] = message.reserved_name[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                DescriptorProto.ExtensionRange = (function() {
    
                    /**
                     * Properties of an ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IExtensionRange
                     * @property {number|null} [start] ExtensionRange start
                     * @property {number|null} [end] ExtensionRange end
                     */
    
                    /**
                     * Constructs a new ExtensionRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents an ExtensionRange.
                     * @implements IExtensionRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     */
                    function ExtensionRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ExtensionRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.start = 0;
    
                    /**
                     * ExtensionRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     */
                    ExtensionRange.prototype.end = 0;
    
                    /**
                     * Creates a new ExtensionRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                     */
                    ExtensionRange.create = function create(properties) {
                        return new ExtensionRange(properties);
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an ExtensionRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExtensionRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                     */
                    ExtensionRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExtensionRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ExtensionRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ExtensionRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExtensionRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ExtensionRange;
                })();
    
                DescriptorProto.ReservedRange = (function() {
    
                    /**
                     * Properties of a ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @interface IReservedRange
                     * @property {number|null} [start] ReservedRange start
                     * @property {number|null} [end] ReservedRange end
                     */
    
                    /**
                     * Constructs a new ReservedRange.
                     * @memberof google.protobuf.DescriptorProto
                     * @classdesc Represents a ReservedRange.
                     * @implements IReservedRange
                     * @constructor
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     */
                    function ReservedRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * ReservedRange start.
                     * @member {number} start
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.start = 0;
    
                    /**
                     * ReservedRange end.
                     * @member {number} end
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     */
                    ReservedRange.prototype.end = 0;
    
                    /**
                     * Creates a new ReservedRange instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                     */
                    ReservedRange.create = function create(properties) {
                        return new ReservedRange(properties);
                    };
    
                    /**
                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a ReservedRange message.
                     * @function verify
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ReservedRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.start != null && message.hasOwnProperty("start"))
                            if (!$util.isInteger(message.start))
                                return "start: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                     */
                    ReservedRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                            return object;
                        var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                        if (object.start != null)
                            message.start = object.start | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @static
                     * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ReservedRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.start = 0;
                            object.end = 0;
                        }
                        if (message.start != null && message.hasOwnProperty("start"))
                            object.start = message.start;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this ReservedRange to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.DescriptorProto.ReservedRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ReservedRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ReservedRange;
                })();
    
                return DescriptorProto;
            })();
    
            protobuf.FieldDescriptorProto = (function() {
    
                /**
                 * Properties of a FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IFieldDescriptorProto
                 * @property {string|null} [name] FieldDescriptorProto name
                 * @property {number|null} [number] FieldDescriptorProto number
                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
                 * @property {string|null} [type_name] FieldDescriptorProto type_name
                 * @property {string|null} [extendee] FieldDescriptorProto extendee
                 * @property {string|null} [default_value] FieldDescriptorProto default_value
                 * @property {number|null} [oneof_index] FieldDescriptorProto oneof_index
                 * @property {string|null} [json_name] FieldDescriptorProto json_name
                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
                 */
    
                /**
                 * Constructs a new FieldDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldDescriptorProto.
                 * @implements IFieldDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 */
                function FieldDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.name = "";
    
                /**
                 * FieldDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.number = 0;
    
                /**
                 * FieldDescriptorProto label.
                 * @member {google.protobuf.FieldDescriptorProto.Label} label
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.label = 1;
    
                /**
                 * FieldDescriptorProto type.
                 * @member {google.protobuf.FieldDescriptorProto.Type} type
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type = 1;
    
                /**
                 * FieldDescriptorProto type_name.
                 * @member {string} type_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.type_name = "";
    
                /**
                 * FieldDescriptorProto extendee.
                 * @member {string} extendee
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.extendee = "";
    
                /**
                 * FieldDescriptorProto default_value.
                 * @member {string} default_value
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.default_value = "";
    
                /**
                 * FieldDescriptorProto oneof_index.
                 * @member {number} oneof_index
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.oneof_index = 0;
    
                /**
                 * FieldDescriptorProto json_name.
                 * @member {string} json_name
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.json_name = "";
    
                /**
                 * FieldDescriptorProto options.
                 * @member {google.protobuf.IFieldOptions|null|undefined} options
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 */
                FieldDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new FieldDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
                 */
                FieldDescriptorProto.create = function create(properties) {
                    return new FieldDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                    if (message.type_name != null && Object.hasOwnProperty.call(message, "type_name"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.type_name);
                    if (message.default_value != null && Object.hasOwnProperty.call(message, "default_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.default_value);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.oneof_index != null && Object.hasOwnProperty.call(message, "oneof_index"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneof_index);
                    if (message.json_name != null && Object.hasOwnProperty.call(message, "json_name"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.json_name);
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.type_name = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.default_value = reader.string();
                            break;
                        case 9:
                            message.oneof_index = reader.int32();
                            break;
                        case 10:
                            message.json_name = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        switch (message.label) {
                        default:
                            return "label: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                        case 14:
                        case 15:
                        case 16:
                        case 17:
                        case 18:
                            break;
                        }
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        if (!$util.isString(message.type_name))
                            return "type_name: string expected";
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        if (!$util.isString(message.extendee))
                            return "extendee: string expected";
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        if (!$util.isString(message.default_value))
                            return "default_value: string expected";
                    if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                        if (!$util.isInteger(message.oneof_index))
                            return "oneof_index: integer expected";
                    if (message.json_name != null && message.hasOwnProperty("json_name"))
                        if (!$util.isString(message.json_name))
                            return "json_name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.FieldOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
                 */
                FieldDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.FieldDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    switch (object.label) {
                    case "LABEL_OPTIONAL":
                    case 1:
                        message.label = 1;
                        break;
                    case "LABEL_REQUIRED":
                    case 2:
                        message.label = 2;
                        break;
                    case "LABEL_REPEATED":
                    case 3:
                        message.label = 3;
                        break;
                    }
                    switch (object.type) {
                    case "TYPE_DOUBLE":
                    case 1:
                        message.type = 1;
                        break;
                    case "TYPE_FLOAT":
                    case 2:
                        message.type = 2;
                        break;
                    case "TYPE_INT64":
                    case 3:
                        message.type = 3;
                        break;
                    case "TYPE_UINT64":
                    case 4:
                        message.type = 4;
                        break;
                    case "TYPE_INT32":
                    case 5:
                        message.type = 5;
                        break;
                    case "TYPE_FIXED64":
                    case 6:
                        message.type = 6;
                        break;
                    case "TYPE_FIXED32":
                    case 7:
                        message.type = 7;
                        break;
                    case "TYPE_BOOL":
                    case 8:
                        message.type = 8;
                        break;
                    case "TYPE_STRING":
                    case 9:
                        message.type = 9;
                        break;
                    case "TYPE_GROUP":
                    case 10:
                        message.type = 10;
                        break;
                    case "TYPE_MESSAGE":
                    case 11:
                        message.type = 11;
                        break;
                    case "TYPE_BYTES":
                    case 12:
                        message.type = 12;
                        break;
                    case "TYPE_UINT32":
                    case 13:
                        message.type = 13;
                        break;
                    case "TYPE_ENUM":
                    case 14:
                        message.type = 14;
                        break;
                    case "TYPE_SFIXED32":
                    case 15:
                        message.type = 15;
                        break;
                    case "TYPE_SFIXED64":
                    case 16:
                        message.type = 16;
                        break;
                    case "TYPE_SINT32":
                    case 17:
                        message.type = 17;
                        break;
                    case "TYPE_SINT64":
                    case 18:
                        message.type = 18;
                        break;
                    }
                    if (object.type_name != null)
                        message.type_name = String(object.type_name);
                    if (object.extendee != null)
                        message.extendee = String(object.extendee);
                    if (object.default_value != null)
                        message.default_value = String(object.default_value);
                    if (object.oneof_index != null)
                        message.oneof_index = object.oneof_index | 0;
                    if (object.json_name != null)
                        message.json_name = String(object.json_name);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @static
                 * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.extendee = "";
                        object.number = 0;
                        object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                        object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                        object.type_name = "";
                        object.default_value = "";
                        object.options = null;
                        object.oneof_index = 0;
                        object.json_name = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.extendee != null && message.hasOwnProperty("extendee"))
                        object.extendee = message.extendee;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                    if (message.type_name != null && message.hasOwnProperty("type_name"))
                        object.type_name = message.type_name;
                    if (message.default_value != null && message.hasOwnProperty("default_value"))
                        object.default_value = message.default_value;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                    if (message.oneof_index != null && message.hasOwnProperty("oneof_index"))
                        object.oneof_index = message.oneof_index;
                    if (message.json_name != null && message.hasOwnProperty("json_name"))
                        object.json_name = message.json_name;
                    return object;
                };
    
                /**
                 * Converts this FieldDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * Type enum.
                 * @name google.protobuf.FieldDescriptorProto.Type
                 * @enum {number}
                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
                 * @property {number} TYPE_INT64=3 TYPE_INT64 value
                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
                 * @property {number} TYPE_INT32=5 TYPE_INT32 value
                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value
                 * @property {number} TYPE_STRING=9 TYPE_STRING value
                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value
                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value
                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value
                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
                 */
                FieldDescriptorProto.Type = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                    values[valuesById[2] = "TYPE_FLOAT"] = 2;
                    values[valuesById[3] = "TYPE_INT64"] = 3;
                    values[valuesById[4] = "TYPE_UINT64"] = 4;
                    values[valuesById[5] = "TYPE_INT32"] = 5;
                    values[valuesById[6] = "TYPE_FIXED64"] = 6;
                    values[valuesById[7] = "TYPE_FIXED32"] = 7;
                    values[valuesById[8] = "TYPE_BOOL"] = 8;
                    values[valuesById[9] = "TYPE_STRING"] = 9;
                    values[valuesById[10] = "TYPE_GROUP"] = 10;
                    values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                    values[valuesById[12] = "TYPE_BYTES"] = 12;
                    values[valuesById[13] = "TYPE_UINT32"] = 13;
                    values[valuesById[14] = "TYPE_ENUM"] = 14;
                    values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                    values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                    values[valuesById[17] = "TYPE_SINT32"] = 17;
                    values[valuesById[18] = "TYPE_SINT64"] = 18;
                    return values;
                })();
    
                /**
                 * Label enum.
                 * @name google.protobuf.FieldDescriptorProto.Label
                 * @enum {number}
                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
                 */
                FieldDescriptorProto.Label = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                    values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                    values[valuesById[3] = "LABEL_REPEATED"] = 3;
                    return values;
                })();
    
                return FieldDescriptorProto;
            })();
    
            protobuf.OneofDescriptorProto = (function() {
    
                /**
                 * Properties of an OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IOneofDescriptorProto
                 * @property {string|null} [name] OneofDescriptorProto name
                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
                 */
    
                /**
                 * Constructs a new OneofDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofDescriptorProto.
                 * @implements IOneofDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 */
                function OneofDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.name = "";
    
                /**
                 * OneofDescriptorProto options.
                 * @member {google.protobuf.IOneofOptions|null|undefined} options
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 */
                OneofDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new OneofDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
                 */
                OneofDescriptorProto.create = function create(properties) {
                    return new OneofDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.OneofOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
                 */
                OneofDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.OneofDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @static
                 * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this OneofDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return OneofDescriptorProto;
            })();
    
            protobuf.EnumDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumDescriptorProto
                 * @property {string|null} [name] EnumDescriptorProto name
                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumDescriptorProto.
                 * @implements IEnumDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 */
                function EnumDescriptorProto(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.name = "";
    
                /**
                 * EnumDescriptorProto value.
                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.value = $util.emptyArray;
    
                /**
                 * EnumDescriptorProto options.
                 * @member {google.protobuf.IEnumOptions|null|undefined} options
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 */
                EnumDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
                 */
                EnumDescriptorProto.create = function create(properties) {
                    return new EnumDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
                 */
                EnumDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                            message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumDescriptorProto;
            })();
    
            protobuf.EnumValueDescriptorProto = (function() {
    
                /**
                 * Properties of an EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IEnumValueDescriptorProto
                 * @property {string|null} [name] EnumValueDescriptorProto name
                 * @property {number|null} [number] EnumValueDescriptorProto number
                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
                 */
    
                /**
                 * Constructs a new EnumValueDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueDescriptorProto.
                 * @implements IEnumValueDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 */
                function EnumValueDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.name = "";
    
                /**
                 * EnumValueDescriptorProto number.
                 * @member {number} number
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.number = 0;
    
                /**
                 * EnumValueDescriptorProto options.
                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 */
                EnumValueDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new EnumValueDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
                 */
                EnumValueDescriptorProto.create = function create(properties) {
                    return new EnumValueDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.number != null && message.hasOwnProperty("number"))
                        if (!$util.isInteger(message.number))
                            return "number: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
                 */
                EnumValueDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.EnumValueDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.number != null)
                        message.number = object.number | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @static
                 * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.number = 0;
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.number != null && message.hasOwnProperty("number"))
                        object.number = message.number;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this EnumValueDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueDescriptorProto;
            })();
    
            protobuf.ServiceDescriptorProto = (function() {
    
                /**
                 * Properties of a ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IServiceDescriptorProto
                 * @property {string|null} [name] ServiceDescriptorProto name
                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
                 */
    
                /**
                 * Constructs a new ServiceDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceDescriptorProto.
                 * @implements IServiceDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 */
                function ServiceDescriptorProto(properties) {
                    this.method = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.name = "";
    
                /**
                 * ServiceDescriptorProto method.
                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.method = $util.emptyArray;
    
                /**
                 * ServiceDescriptorProto options.
                 * @member {google.protobuf.IServiceOptions|null|undefined} options
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 */
                ServiceDescriptorProto.prototype.options = null;
    
                /**
                 * Creates a new ServiceDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
                 */
                ServiceDescriptorProto.create = function create(properties) {
                    return new ServiceDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.method != null && message.method.length)
                        for (var i = 0; i < message.method.length; ++i)
                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.method != null && message.hasOwnProperty("method")) {
                        if (!Array.isArray(message.method))
                            return "method: array expected";
                        for (var i = 0; i < message.method.length; ++i) {
                            var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                            if (error)
                                return "method." + error;
                        }
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
                 */
                ServiceDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.ServiceDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.method) {
                        if (!Array.isArray(object.method))
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                        message.method = [];
                        for (var i = 0; i < object.method.length; ++i) {
                            if (typeof object.method[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                            message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                        }
                    }
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @static
                 * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.method = [];
                    if (options.defaults) {
                        object.name = "";
                        object.options = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.method && message.method.length) {
                        object.method = [];
                        for (var j = 0; j < message.method.length; ++j)
                            object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                    }
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                    return object;
                };
    
                /**
                 * Converts this ServiceDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceDescriptorProto;
            })();
    
            protobuf.MethodDescriptorProto = (function() {
    
                /**
                 * Properties of a MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @interface IMethodDescriptorProto
                 * @property {string|null} [name] MethodDescriptorProto name
                 * @property {string|null} [input_type] MethodDescriptorProto input_type
                 * @property {string|null} [output_type] MethodDescriptorProto output_type
                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
                 * @property {boolean|null} [client_streaming] MethodDescriptorProto client_streaming
                 * @property {boolean|null} [server_streaming] MethodDescriptorProto server_streaming
                 */
    
                /**
                 * Constructs a new MethodDescriptorProto.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodDescriptorProto.
                 * @implements IMethodDescriptorProto
                 * @constructor
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 */
                function MethodDescriptorProto(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodDescriptorProto name.
                 * @member {string} name
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.name = "";
    
                /**
                 * MethodDescriptorProto input_type.
                 * @member {string} input_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.input_type = "";
    
                /**
                 * MethodDescriptorProto output_type.
                 * @member {string} output_type
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.output_type = "";
    
                /**
                 * MethodDescriptorProto options.
                 * @member {google.protobuf.IMethodOptions|null|undefined} options
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.options = null;
    
                /**
                 * MethodDescriptorProto client_streaming.
                 * @member {boolean} client_streaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.client_streaming = false;
    
                /**
                 * MethodDescriptorProto server_streaming.
                 * @member {boolean} server_streaming
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 */
                MethodDescriptorProto.prototype.server_streaming = false;
    
                /**
                 * Creates a new MethodDescriptorProto instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
                 */
                MethodDescriptorProto.create = function create(properties) {
                    return new MethodDescriptorProto(properties);
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input_type != null && Object.hasOwnProperty.call(message, "input_type"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.input_type);
                    if (message.output_type != null && Object.hasOwnProperty.call(message, "output_type"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.output_type);
                    if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.client_streaming != null && Object.hasOwnProperty.call(message, "client_streaming"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.client_streaming);
                    if (message.server_streaming != null && Object.hasOwnProperty.call(message, "server_streaming"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.server_streaming);
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.input_type = reader.string();
                            break;
                        case 3:
                            message.output_type = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.client_streaming = reader.bool();
                            break;
                        case 6:
                            message.server_streaming = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodDescriptorProto message.
                 * @function verify
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodDescriptorProto.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        if (!$util.isString(message.input_type))
                            return "input_type: string expected";
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        if (!$util.isString(message.output_type))
                            return "output_type: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        var error = $root.google.protobuf.MethodOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                        if (typeof message.client_streaming !== "boolean")
                            return "client_streaming: boolean expected";
                    if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                        if (typeof message.server_streaming !== "boolean")
                            return "server_streaming: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
                 */
                MethodDescriptorProto.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                        return object;
                    var message = new $root.google.protobuf.MethodDescriptorProto();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input_type != null)
                        message.input_type = String(object.input_type);
                    if (object.output_type != null)
                        message.output_type = String(object.output_type);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                        message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                    }
                    if (object.client_streaming != null)
                        message.client_streaming = Boolean(object.client_streaming);
                    if (object.server_streaming != null)
                        message.server_streaming = Boolean(object.server_streaming);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @static
                 * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodDescriptorProto.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.input_type = "";
                        object.output_type = "";
                        object.options = null;
                        object.client_streaming = false;
                        object.server_streaming = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input_type != null && message.hasOwnProperty("input_type"))
                        object.input_type = message.input_type;
                    if (message.output_type != null && message.hasOwnProperty("output_type"))
                        object.output_type = message.output_type;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                    if (message.client_streaming != null && message.hasOwnProperty("client_streaming"))
                        object.client_streaming = message.client_streaming;
                    if (message.server_streaming != null && message.hasOwnProperty("server_streaming"))
                        object.server_streaming = message.server_streaming;
                    return object;
                };
    
                /**
                 * Converts this MethodDescriptorProto to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodDescriptorProto
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodDescriptorProto.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodDescriptorProto;
            })();
    
            protobuf.FileOptions = (function() {
    
                /**
                 * Properties of a FileOptions.
                 * @memberof google.protobuf
                 * @interface IFileOptions
                 * @property {string|null} [java_package] FileOptions java_package
                 * @property {string|null} [java_outer_classname] FileOptions java_outer_classname
                 * @property {boolean|null} [java_multiple_files] FileOptions java_multiple_files
                 * @property {boolean|null} [java_generate_equals_and_hash] FileOptions java_generate_equals_and_hash
                 * @property {boolean|null} [java_string_check_utf8] FileOptions java_string_check_utf8
                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimize_for] FileOptions optimize_for
                 * @property {string|null} [go_package] FileOptions go_package
                 * @property {boolean|null} [cc_generic_services] FileOptions cc_generic_services
                 * @property {boolean|null} [java_generic_services] FileOptions java_generic_services
                 * @property {boolean|null} [py_generic_services] FileOptions py_generic_services
                 * @property {boolean|null} [deprecated] FileOptions deprecated
                 * @property {boolean|null} [cc_enable_arenas] FileOptions cc_enable_arenas
                 * @property {string|null} [objc_class_prefix] FileOptions objc_class_prefix
                 * @property {string|null} [csharp_namespace] FileOptions csharp_namespace
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FileOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new FileOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FileOptions.
                 * @implements IFileOptions
                 * @constructor
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 */
                function FileOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FileOptions java_package.
                 * @member {string} java_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_package = "";
    
                /**
                 * FileOptions java_outer_classname.
                 * @member {string} java_outer_classname
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_outer_classname = "";
    
                /**
                 * FileOptions java_multiple_files.
                 * @member {boolean} java_multiple_files
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_multiple_files = false;
    
                /**
                 * FileOptions java_generate_equals_and_hash.
                 * @member {boolean} java_generate_equals_and_hash
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generate_equals_and_hash = false;
    
                /**
                 * FileOptions java_string_check_utf8.
                 * @member {boolean} java_string_check_utf8
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_string_check_utf8 = false;
    
                /**
                 * FileOptions optimize_for.
                 * @member {google.protobuf.FileOptions.OptimizeMode} optimize_for
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.optimize_for = 1;
    
                /**
                 * FileOptions go_package.
                 * @member {string} go_package
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.go_package = "";
    
                /**
                 * FileOptions cc_generic_services.
                 * @member {boolean} cc_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_generic_services = false;
    
                /**
                 * FileOptions java_generic_services.
                 * @member {boolean} java_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.java_generic_services = false;
    
                /**
                 * FileOptions py_generic_services.
                 * @member {boolean} py_generic_services
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.py_generic_services = false;
    
                /**
                 * FileOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.deprecated = false;
    
                /**
                 * FileOptions cc_enable_arenas.
                 * @member {boolean} cc_enable_arenas
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.cc_enable_arenas = false;
    
                /**
                 * FileOptions objc_class_prefix.
                 * @member {string} objc_class_prefix
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.objc_class_prefix = "";
    
                /**
                 * FileOptions csharp_namespace.
                 * @member {string} csharp_namespace
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.csharp_namespace = "";
    
                /**
                 * FileOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 */
                FileOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new FileOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FileOptions} FileOptions instance
                 */
                FileOptions.create = function create(properties) {
                    return new FileOptions(properties);
                };
    
                /**
                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.java_package != null && Object.hasOwnProperty.call(message, "java_package"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.java_package);
                    if (message.java_outer_classname != null && Object.hasOwnProperty.call(message, "java_outer_classname"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.java_outer_classname);
                    if (message.optimize_for != null && Object.hasOwnProperty.call(message, "optimize_for"))
                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimize_for);
                    if (message.java_multiple_files != null && Object.hasOwnProperty.call(message, "java_multiple_files"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.java_multiple_files);
                    if (message.go_package != null && Object.hasOwnProperty.call(message, "go_package"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.go_package);
                    if (message.cc_generic_services != null && Object.hasOwnProperty.call(message, "cc_generic_services"))
                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.cc_generic_services);
                    if (message.java_generic_services != null && Object.hasOwnProperty.call(message, "java_generic_services"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.java_generic_services);
                    if (message.py_generic_services != null && Object.hasOwnProperty.call(message, "py_generic_services"))
                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.py_generic_services);
                    if (message.java_generate_equals_and_hash != null && Object.hasOwnProperty.call(message, "java_generate_equals_and_hash"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.java_generate_equals_and_hash);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                    if (message.java_string_check_utf8 != null && Object.hasOwnProperty.call(message, "java_string_check_utf8"))
                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.java_string_check_utf8);
                    if (message.cc_enable_arenas != null && Object.hasOwnProperty.call(message, "cc_enable_arenas"))
                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.cc_enable_arenas);
                    if (message.objc_class_prefix != null && Object.hasOwnProperty.call(message, "objc_class_prefix"))
                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objc_class_prefix);
                    if (message.csharp_namespace != null && Object.hasOwnProperty.call(message, "csharp_namespace"))
                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharp_namespace);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.java_package = reader.string();
                            break;
                        case 8:
                            message.java_outer_classname = reader.string();
                            break;
                        case 10:
                            message.java_multiple_files = reader.bool();
                            break;
                        case 20:
                            message.java_generate_equals_and_hash = reader.bool();
                            break;
                        case 27:
                            message.java_string_check_utf8 = reader.bool();
                            break;
                        case 9:
                            message.optimize_for = reader.int32();
                            break;
                        case 11:
                            message.go_package = reader.string();
                            break;
                        case 16:
                            message.cc_generic_services = reader.bool();
                            break;
                        case 17:
                            message.java_generic_services = reader.bool();
                            break;
                        case 18:
                            message.py_generic_services = reader.bool();
                            break;
                        case 23:
                            message.deprecated = reader.bool();
                            break;
                        case 31:
                            message.cc_enable_arenas = reader.bool();
                            break;
                        case 36:
                            message.objc_class_prefix = reader.string();
                            break;
                        case 37:
                            message.csharp_namespace = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FileOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FileOptions} FileOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FileOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FileOptions message.
                 * @function verify
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FileOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        if (!$util.isString(message.java_package))
                            return "java_package: string expected";
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        if (!$util.isString(message.java_outer_classname))
                            return "java_outer_classname: string expected";
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        if (typeof message.java_multiple_files !== "boolean")
                            return "java_multiple_files: boolean expected";
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        if (typeof message.java_generate_equals_and_hash !== "boolean")
                            return "java_generate_equals_and_hash: boolean expected";
                    if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                        if (typeof message.java_string_check_utf8 !== "boolean")
                            return "java_string_check_utf8: boolean expected";
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        switch (message.optimize_for) {
                        default:
                            return "optimize_for: enum value expected";
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.go_package != null && message.hasOwnProperty("go_package"))
                        if (!$util.isString(message.go_package))
                            return "go_package: string expected";
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        if (typeof message.cc_generic_services !== "boolean")
                            return "cc_generic_services: boolean expected";
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        if (typeof message.java_generic_services !== "boolean")
                            return "java_generic_services: boolean expected";
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        if (typeof message.py_generic_services !== "boolean")
                            return "py_generic_services: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                        if (typeof message.cc_enable_arenas !== "boolean")
                            return "cc_enable_arenas: boolean expected";
                    if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                        if (!$util.isString(message.objc_class_prefix))
                            return "objc_class_prefix: string expected";
                    if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                        if (!$util.isString(message.csharp_namespace))
                            return "csharp_namespace: string expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FileOptions} FileOptions
                 */
                FileOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FileOptions)
                        return object;
                    var message = new $root.google.protobuf.FileOptions();
                    if (object.java_package != null)
                        message.java_package = String(object.java_package);
                    if (object.java_outer_classname != null)
                        message.java_outer_classname = String(object.java_outer_classname);
                    if (object.java_multiple_files != null)
                        message.java_multiple_files = Boolean(object.java_multiple_files);
                    if (object.java_generate_equals_and_hash != null)
                        message.java_generate_equals_and_hash = Boolean(object.java_generate_equals_and_hash);
                    if (object.java_string_check_utf8 != null)
                        message.java_string_check_utf8 = Boolean(object.java_string_check_utf8);
                    switch (object.optimize_for) {
                    case "SPEED":
                    case 1:
                        message.optimize_for = 1;
                        break;
                    case "CODE_SIZE":
                    case 2:
                        message.optimize_for = 2;
                        break;
                    case "LITE_RUNTIME":
                    case 3:
                        message.optimize_for = 3;
                        break;
                    }
                    if (object.go_package != null)
                        message.go_package = String(object.go_package);
                    if (object.cc_generic_services != null)
                        message.cc_generic_services = Boolean(object.cc_generic_services);
                    if (object.java_generic_services != null)
                        message.java_generic_services = Boolean(object.java_generic_services);
                    if (object.py_generic_services != null)
                        message.py_generic_services = Boolean(object.py_generic_services);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.cc_enable_arenas != null)
                        message.cc_enable_arenas = Boolean(object.cc_enable_arenas);
                    if (object.objc_class_prefix != null)
                        message.objc_class_prefix = String(object.objc_class_prefix);
                    if (object.csharp_namespace != null)
                        message.csharp_namespace = String(object.csharp_namespace);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FileOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FileOptions
                 * @static
                 * @param {google.protobuf.FileOptions} message FileOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FileOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.java_package = "";
                        object.java_outer_classname = "";
                        object.optimize_for = options.enums === String ? "SPEED" : 1;
                        object.java_multiple_files = false;
                        object.go_package = "";
                        object.cc_generic_services = false;
                        object.java_generic_services = false;
                        object.py_generic_services = false;
                        object.java_generate_equals_and_hash = false;
                        object.deprecated = false;
                        object.java_string_check_utf8 = false;
                        object.cc_enable_arenas = false;
                        object.objc_class_prefix = "";
                        object.csharp_namespace = "";
                    }
                    if (message.java_package != null && message.hasOwnProperty("java_package"))
                        object.java_package = message.java_package;
                    if (message.java_outer_classname != null && message.hasOwnProperty("java_outer_classname"))
                        object.java_outer_classname = message.java_outer_classname;
                    if (message.optimize_for != null && message.hasOwnProperty("optimize_for"))
                        object.optimize_for = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimize_for] : message.optimize_for;
                    if (message.java_multiple_files != null && message.hasOwnProperty("java_multiple_files"))
                        object.java_multiple_files = message.java_multiple_files;
                    if (message.go_package != null && message.hasOwnProperty("go_package"))
                        object.go_package = message.go_package;
                    if (message.cc_generic_services != null && message.hasOwnProperty("cc_generic_services"))
                        object.cc_generic_services = message.cc_generic_services;
                    if (message.java_generic_services != null && message.hasOwnProperty("java_generic_services"))
                        object.java_generic_services = message.java_generic_services;
                    if (message.py_generic_services != null && message.hasOwnProperty("py_generic_services"))
                        object.py_generic_services = message.py_generic_services;
                    if (message.java_generate_equals_and_hash != null && message.hasOwnProperty("java_generate_equals_and_hash"))
                        object.java_generate_equals_and_hash = message.java_generate_equals_and_hash;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.java_string_check_utf8 != null && message.hasOwnProperty("java_string_check_utf8"))
                        object.java_string_check_utf8 = message.java_string_check_utf8;
                    if (message.cc_enable_arenas != null && message.hasOwnProperty("cc_enable_arenas"))
                        object.cc_enable_arenas = message.cc_enable_arenas;
                    if (message.objc_class_prefix != null && message.hasOwnProperty("objc_class_prefix"))
                        object.objc_class_prefix = message.objc_class_prefix;
                    if (message.csharp_namespace != null && message.hasOwnProperty("csharp_namespace"))
                        object.csharp_namespace = message.csharp_namespace;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FileOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FileOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FileOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * OptimizeMode enum.
                 * @name google.protobuf.FileOptions.OptimizeMode
                 * @enum {number}
                 * @property {number} SPEED=1 SPEED value
                 * @property {number} CODE_SIZE=2 CODE_SIZE value
                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
                 */
                FileOptions.OptimizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[1] = "SPEED"] = 1;
                    values[valuesById[2] = "CODE_SIZE"] = 2;
                    values[valuesById[3] = "LITE_RUNTIME"] = 3;
                    return values;
                })();
    
                return FileOptions;
            })();
    
            protobuf.MessageOptions = (function() {
    
                /**
                 * Properties of a MessageOptions.
                 * @memberof google.protobuf
                 * @interface IMessageOptions
                 * @property {boolean|null} [message_set_wire_format] MessageOptions message_set_wire_format
                 * @property {boolean|null} [no_standard_descriptor_accessor] MessageOptions no_standard_descriptor_accessor
                 * @property {boolean|null} [deprecated] MessageOptions deprecated
                 * @property {boolean|null} [map_entry] MessageOptions map_entry
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MessageOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MessageOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MessageOptions.
                 * @implements IMessageOptions
                 * @constructor
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 */
                function MessageOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MessageOptions message_set_wire_format.
                 * @member {boolean} message_set_wire_format
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.message_set_wire_format = false;
    
                /**
                 * MessageOptions no_standard_descriptor_accessor.
                 * @member {boolean} no_standard_descriptor_accessor
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.no_standard_descriptor_accessor = false;
    
                /**
                 * MessageOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.deprecated = false;
    
                /**
                 * MessageOptions map_entry.
                 * @member {boolean} map_entry
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.map_entry = false;
    
                /**
                 * MessageOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 */
                MessageOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MessageOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MessageOptions} MessageOptions instance
                 */
                MessageOptions.create = function create(properties) {
                    return new MessageOptions(properties);
                };
    
                /**
                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.message_set_wire_format != null && Object.hasOwnProperty.call(message, "message_set_wire_format"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.message_set_wire_format);
                    if (message.no_standard_descriptor_accessor != null && Object.hasOwnProperty.call(message, "no_standard_descriptor_accessor"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.no_standard_descriptor_accessor);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.map_entry != null && Object.hasOwnProperty.call(message, "map_entry"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.map_entry);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.message_set_wire_format = reader.bool();
                            break;
                        case 2:
                            message.no_standard_descriptor_accessor = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 7:
                            message.map_entry = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MessageOptions message.
                 * @function verify
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MessageOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        if (typeof message.message_set_wire_format !== "boolean")
                            return "message_set_wire_format: boolean expected";
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        if (typeof message.no_standard_descriptor_accessor !== "boolean")
                            return "no_standard_descriptor_accessor: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                        if (typeof message.map_entry !== "boolean")
                            return "map_entry: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MessageOptions} MessageOptions
                 */
                MessageOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MessageOptions)
                        return object;
                    var message = new $root.google.protobuf.MessageOptions();
                    if (object.message_set_wire_format != null)
                        message.message_set_wire_format = Boolean(object.message_set_wire_format);
                    if (object.no_standard_descriptor_accessor != null)
                        message.no_standard_descriptor_accessor = Boolean(object.no_standard_descriptor_accessor);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.map_entry != null)
                        message.map_entry = Boolean(object.map_entry);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MessageOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MessageOptions
                 * @static
                 * @param {google.protobuf.MessageOptions} message MessageOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MessageOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.message_set_wire_format = false;
                        object.no_standard_descriptor_accessor = false;
                        object.deprecated = false;
                        object.map_entry = false;
                    }
                    if (message.message_set_wire_format != null && message.hasOwnProperty("message_set_wire_format"))
                        object.message_set_wire_format = message.message_set_wire_format;
                    if (message.no_standard_descriptor_accessor != null && message.hasOwnProperty("no_standard_descriptor_accessor"))
                        object.no_standard_descriptor_accessor = message.no_standard_descriptor_accessor;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.map_entry != null && message.hasOwnProperty("map_entry"))
                        object.map_entry = message.map_entry;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MessageOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MessageOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MessageOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MessageOptions;
            })();
    
            protobuf.FieldOptions = (function() {
    
                /**
                 * Properties of a FieldOptions.
                 * @memberof google.protobuf
                 * @interface IFieldOptions
                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
                 * @property {boolean|null} [packed] FieldOptions packed
                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
                 * @property {boolean|null} [lazy] FieldOptions lazy
                 * @property {boolean|null} [deprecated] FieldOptions deprecated
                 * @property {boolean|null} [weak] FieldOptions weak
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] FieldOptions uninterpreted_option
                 * @property {koinos.bytes_type|null} [".koinos.btype"] FieldOptions .koinos.btype
                 */
    
                /**
                 * Constructs a new FieldOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a FieldOptions.
                 * @implements IFieldOptions
                 * @constructor
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 */
                function FieldOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldOptions ctype.
                 * @member {google.protobuf.FieldOptions.CType} ctype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.ctype = 0;
    
                /**
                 * FieldOptions packed.
                 * @member {boolean} packed
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.packed = false;
    
                /**
                 * FieldOptions jstype.
                 * @member {google.protobuf.FieldOptions.JSType} jstype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.jstype = 0;
    
                /**
                 * FieldOptions lazy.
                 * @member {boolean} lazy
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.lazy = false;
    
                /**
                 * FieldOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.deprecated = false;
    
                /**
                 * FieldOptions weak.
                 * @member {boolean} weak
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.weak = false;
    
                /**
                 * FieldOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * FieldOptions .koinos.btype.
                 * @member {koinos.bytes_type} .koinos.btype
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 */
                FieldOptions.prototype[".koinos.btype"] = 0;
    
                /**
                 * Creates a new FieldOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
                 * @returns {google.protobuf.FieldOptions} FieldOptions instance
                 */
                FieldOptions.create = function create(properties) {
                    return new FieldOptions(properties);
                };
    
                /**
                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                    if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                    if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                    if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    if (message[".koinos.btype"] != null && Object.hasOwnProperty.call(message, ".koinos.btype"))
                        writer.uint32(/* id 50000, wireType 0 =*/400000).int32(message[".koinos.btype"]);
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 6:
                            message.jstype = reader.int32();
                            break;
                        case 5:
                            message.lazy = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 10:
                            message.weak = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 50000:
                            message[".koinos.btype"] = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldOptions message.
                 * @function verify
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        switch (message.ctype) {
                        default:
                            return "ctype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        if (typeof message.packed !== "boolean")
                            return "packed: boolean expected";
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        switch (message.jstype) {
                        default:
                            return "jstype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        if (typeof message.lazy !== "boolean")
                            return "lazy: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        if (typeof message.weak !== "boolean")
                            return "weak: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    if (message[".koinos.btype"] != null && message.hasOwnProperty(".koinos.btype"))
                        switch (message[".koinos.btype"]) {
                        default:
                            return ".koinos.btype: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.FieldOptions} FieldOptions
                 */
                FieldOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.FieldOptions)
                        return object;
                    var message = new $root.google.protobuf.FieldOptions();
                    switch (object.ctype) {
                    case "STRING":
                    case 0:
                        message.ctype = 0;
                        break;
                    case "CORD":
                    case 1:
                        message.ctype = 1;
                        break;
                    case "STRING_PIECE":
                    case 2:
                        message.ctype = 2;
                        break;
                    }
                    if (object.packed != null)
                        message.packed = Boolean(object.packed);
                    switch (object.jstype) {
                    case "JS_NORMAL":
                    case 0:
                        message.jstype = 0;
                        break;
                    case "JS_STRING":
                    case 1:
                        message.jstype = 1;
                        break;
                    case "JS_NUMBER":
                    case 2:
                        message.jstype = 2;
                        break;
                    }
                    if (object.lazy != null)
                        message.lazy = Boolean(object.lazy);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.weak != null)
                        message.weak = Boolean(object.weak);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.FieldOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    switch (object[".koinos.btype"]) {
                    case "BASE64":
                    case 0:
                        message[".koinos.btype"] = 0;
                        break;
                    case "BASE58":
                    case 1:
                        message[".koinos.btype"] = 1;
                        break;
                    case "HEX":
                    case 2:
                        message[".koinos.btype"] = 2;
                        break;
                    case "BLOCK_ID":
                    case 3:
                        message[".koinos.btype"] = 3;
                        break;
                    case "TRANSACTION_ID":
                    case 4:
                        message[".koinos.btype"] = 4;
                        break;
                    case "CONTRACT_ID":
                    case 5:
                        message[".koinos.btype"] = 5;
                        break;
                    case "ADDRESS":
                    case 6:
                        message[".koinos.btype"] = 6;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.FieldOptions
                 * @static
                 * @param {google.protobuf.FieldOptions} message FieldOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.ctype = options.enums === String ? "STRING" : 0;
                        object.packed = false;
                        object.deprecated = false;
                        object.lazy = false;
                        object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                        object.weak = false;
                        object[".koinos.btype"] = options.enums === String ? "BASE64" : 0;
                    }
                    if (message.ctype != null && message.hasOwnProperty("ctype"))
                        object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                    if (message.packed != null && message.hasOwnProperty("packed"))
                        object.packed = message.packed;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.lazy != null && message.hasOwnProperty("lazy"))
                        object.lazy = message.lazy;
                    if (message.jstype != null && message.hasOwnProperty("jstype"))
                        object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                    if (message.weak != null && message.hasOwnProperty("weak"))
                        object.weak = message.weak;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    if (message[".koinos.btype"] != null && message.hasOwnProperty(".koinos.btype"))
                        object[".koinos.btype"] = options.enums === String ? $root.koinos.bytes_type[message[".koinos.btype"]] : message[".koinos.btype"];
                    return object;
                };
    
                /**
                 * Converts this FieldOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.FieldOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * CType enum.
                 * @name google.protobuf.FieldOptions.CType
                 * @enum {number}
                 * @property {number} STRING=0 STRING value
                 * @property {number} CORD=1 CORD value
                 * @property {number} STRING_PIECE=2 STRING_PIECE value
                 */
                FieldOptions.CType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRING"] = 0;
                    values[valuesById[1] = "CORD"] = 1;
                    values[valuesById[2] = "STRING_PIECE"] = 2;
                    return values;
                })();
    
                /**
                 * JSType enum.
                 * @name google.protobuf.FieldOptions.JSType
                 * @enum {number}
                 * @property {number} JS_NORMAL=0 JS_NORMAL value
                 * @property {number} JS_STRING=1 JS_STRING value
                 * @property {number} JS_NUMBER=2 JS_NUMBER value
                 */
                FieldOptions.JSType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "JS_NORMAL"] = 0;
                    values[valuesById[1] = "JS_STRING"] = 1;
                    values[valuesById[2] = "JS_NUMBER"] = 2;
                    return values;
                })();
    
                return FieldOptions;
            })();
    
            protobuf.OneofOptions = (function() {
    
                /**
                 * Properties of an OneofOptions.
                 * @memberof google.protobuf
                 * @interface IOneofOptions
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] OneofOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new OneofOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an OneofOptions.
                 * @implements IOneofOptions
                 * @constructor
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 */
                function OneofOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneofOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 */
                OneofOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new OneofOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
                 * @returns {google.protobuf.OneofOptions} OneofOptions instance
                 */
                OneofOptions.create = function create(properties) {
                    return new OneofOptions(properties);
                };
    
                /**
                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneofOptions message.
                 * @function verify
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneofOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.OneofOptions} OneofOptions
                 */
                OneofOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.OneofOptions)
                        return object;
                    var message = new $root.google.protobuf.OneofOptions();
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.OneofOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.OneofOptions
                 * @static
                 * @param {google.protobuf.OneofOptions} message OneofOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneofOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this OneofOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.OneofOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneofOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return OneofOptions;
            })();
    
            protobuf.EnumOptions = (function() {
    
                /**
                 * Properties of an EnumOptions.
                 * @memberof google.protobuf
                 * @interface IEnumOptions
                 * @property {boolean|null} [allow_alias] EnumOptions allow_alias
                 * @property {boolean|null} [deprecated] EnumOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumOptions.
                 * @implements IEnumOptions
                 * @constructor
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 */
                function EnumOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumOptions allow_alias.
                 * @member {boolean} allow_alias
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.allow_alias = false;
    
                /**
                 * EnumOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.deprecated = false;
    
                /**
                 * EnumOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 */
                EnumOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumOptions} EnumOptions instance
                 */
                EnumOptions.create = function create(properties) {
                    return new EnumOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.allow_alias != null && Object.hasOwnProperty.call(message, "allow_alias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allow_alias);
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            message.allow_alias = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                        if (typeof message.allow_alias !== "boolean")
                            return "allow_alias: boolean expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumOptions} EnumOptions
                 */
                EnumOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumOptions();
                    if (object.allow_alias != null)
                        message.allow_alias = Boolean(object.allow_alias);
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumOptions
                 * @static
                 * @param {google.protobuf.EnumOptions} message EnumOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults) {
                        object.allow_alias = false;
                        object.deprecated = false;
                    }
                    if (message.allow_alias != null && message.hasOwnProperty("allow_alias"))
                        object.allow_alias = message.allow_alias;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumOptions;
            })();
    
            protobuf.EnumValueOptions = (function() {
    
                /**
                 * Properties of an EnumValueOptions.
                 * @memberof google.protobuf
                 * @interface IEnumValueOptions
                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] EnumValueOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new EnumValueOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents an EnumValueOptions.
                 * @implements IEnumValueOptions
                 * @constructor
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 */
                function EnumValueOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EnumValueOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.deprecated = false;
    
                /**
                 * EnumValueOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 */
                EnumValueOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new EnumValueOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
                 */
                EnumValueOptions.create = function create(properties) {
                    return new EnumValueOptions(properties);
                };
    
                /**
                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EnumValueOptions message.
                 * @function verify
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumValueOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
                 */
                EnumValueOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumValueOptions)
                        return object;
                    var message = new $root.google.protobuf.EnumValueOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.EnumValueOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumValueOptions
                 * @static
                 * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumValueOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EnumValueOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumValueOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumValueOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EnumValueOptions;
            })();
    
            protobuf.ServiceOptions = (function() {
    
                /**
                 * Properties of a ServiceOptions.
                 * @memberof google.protobuf
                 * @interface IServiceOptions
                 * @property {boolean|null} [deprecated] ServiceOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] ServiceOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new ServiceOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a ServiceOptions.
                 * @implements IServiceOptions
                 * @constructor
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 */
                function ServiceOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ServiceOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.deprecated = false;
    
                /**
                 * ServiceOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 */
                ServiceOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new ServiceOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
                 */
                ServiceOptions.create = function create(properties) {
                    return new ServiceOptions(properties);
                };
    
                /**
                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ServiceOptions message.
                 * @function verify
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServiceOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.ServiceOptions} ServiceOptions
                 */
                ServiceOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.ServiceOptions)
                        return object;
                    var message = new $root.google.protobuf.ServiceOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.ServiceOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.ServiceOptions
                 * @static
                 * @param {google.protobuf.ServiceOptions} message ServiceOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServiceOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ServiceOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.ServiceOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServiceOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ServiceOptions;
            })();
    
            protobuf.MethodOptions = (function() {
    
                /**
                 * Properties of a MethodOptions.
                 * @memberof google.protobuf
                 * @interface IMethodOptions
                 * @property {boolean|null} [deprecated] MethodOptions deprecated
                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpreted_option] MethodOptions uninterpreted_option
                 */
    
                /**
                 * Constructs a new MethodOptions.
                 * @memberof google.protobuf
                 * @classdesc Represents a MethodOptions.
                 * @implements IMethodOptions
                 * @constructor
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 */
                function MethodOptions(properties) {
                    this.uninterpreted_option = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * MethodOptions deprecated.
                 * @member {boolean} deprecated
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.deprecated = false;
    
                /**
                 * MethodOptions uninterpreted_option.
                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpreted_option
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 */
                MethodOptions.prototype.uninterpreted_option = $util.emptyArray;
    
                /**
                 * Creates a new MethodOptions instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
                 * @returns {google.protobuf.MethodOptions} MethodOptions instance
                 */
                MethodOptions.create = function create(properties) {
                    return new MethodOptions(properties);
                };
    
                /**
                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                    if (message.uninterpreted_option != null && message.uninterpreted_option.length)
                        for (var i = 0; i < message.uninterpreted_option.length; ++i)
                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpreted_option[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpreted_option && message.uninterpreted_option.length))
                                message.uninterpreted_option = [];
                            message.uninterpreted_option.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MethodOptions message.
                 * @function verify
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MethodOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        if (typeof message.deprecated !== "boolean")
                            return "deprecated: boolean expected";
                    if (message.uninterpreted_option != null && message.hasOwnProperty("uninterpreted_option")) {
                        if (!Array.isArray(message.uninterpreted_option))
                            return "uninterpreted_option: array expected";
                        for (var i = 0; i < message.uninterpreted_option.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpreted_option[i]);
                            if (error)
                                return "uninterpreted_option." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.MethodOptions} MethodOptions
                 */
                MethodOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.MethodOptions)
                        return object;
                    var message = new $root.google.protobuf.MethodOptions();
                    if (object.deprecated != null)
                        message.deprecated = Boolean(object.deprecated);
                    if (object.uninterpreted_option) {
                        if (!Array.isArray(object.uninterpreted_option))
                            throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: array expected");
                        message.uninterpreted_option = [];
                        for (var i = 0; i < object.uninterpreted_option.length; ++i) {
                            if (typeof object.uninterpreted_option[i] !== "object")
                                throw TypeError(".google.protobuf.MethodOptions.uninterpreted_option: object expected");
                            message.uninterpreted_option[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpreted_option[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.MethodOptions
                 * @static
                 * @param {google.protobuf.MethodOptions} message MethodOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MethodOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.uninterpreted_option = [];
                    if (options.defaults)
                        object.deprecated = false;
                    if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                        object.deprecated = message.deprecated;
                    if (message.uninterpreted_option && message.uninterpreted_option.length) {
                        object.uninterpreted_option = [];
                        for (var j = 0; j < message.uninterpreted_option.length; ++j)
                            object.uninterpreted_option[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpreted_option[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this MethodOptions to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.MethodOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MethodOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MethodOptions;
            })();
    
            protobuf.UninterpretedOption = (function() {
    
                /**
                 * Properties of an UninterpretedOption.
                 * @memberof google.protobuf
                 * @interface IUninterpretedOption
                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
                 * @property {string|null} [identifier_value] UninterpretedOption identifier_value
                 * @property {number|Long|null} [positive_int_value] UninterpretedOption positive_int_value
                 * @property {number|Long|null} [negative_int_value] UninterpretedOption negative_int_value
                 * @property {number|null} [double_value] UninterpretedOption double_value
                 * @property {Uint8Array|null} [string_value] UninterpretedOption string_value
                 * @property {string|null} [aggregate_value] UninterpretedOption aggregate_value
                 */
    
                /**
                 * Constructs a new UninterpretedOption.
                 * @memberof google.protobuf
                 * @classdesc Represents an UninterpretedOption.
                 * @implements IUninterpretedOption
                 * @constructor
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 */
                function UninterpretedOption(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UninterpretedOption name.
                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.name = $util.emptyArray;
    
                /**
                 * UninterpretedOption identifier_value.
                 * @member {string} identifier_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.identifier_value = "";
    
                /**
                 * UninterpretedOption positive_int_value.
                 * @member {number|Long} positive_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.positive_int_value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UninterpretedOption negative_int_value.
                 * @member {number|Long} negative_int_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.negative_int_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * UninterpretedOption double_value.
                 * @member {number} double_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.double_value = 0;
    
                /**
                 * UninterpretedOption string_value.
                 * @member {Uint8Array} string_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.string_value = $util.newBuffer([]);
    
                /**
                 * UninterpretedOption aggregate_value.
                 * @member {string} aggregate_value
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 */
                UninterpretedOption.prototype.aggregate_value = "";
    
                /**
                 * Creates a new UninterpretedOption instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
                 */
                UninterpretedOption.create = function create(properties) {
                    return new UninterpretedOption(properties);
                };
    
                /**
                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.identifier_value != null && Object.hasOwnProperty.call(message, "identifier_value"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifier_value);
                    if (message.positive_int_value != null && Object.hasOwnProperty.call(message, "positive_int_value"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positive_int_value);
                    if (message.negative_int_value != null && Object.hasOwnProperty.call(message, "negative_int_value"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negative_int_value);
                    if (message.double_value != null && Object.hasOwnProperty.call(message, "double_value"))
                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.double_value);
                    if (message.string_value != null && Object.hasOwnProperty.call(message, "string_value"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.string_value);
                    if (message.aggregate_value != null && Object.hasOwnProperty.call(message, "aggregate_value"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregate_value);
                    return writer;
                };
    
                /**
                 * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifier_value = reader.string();
                            break;
                        case 4:
                            message.positive_int_value = reader.uint64();
                            break;
                        case 5:
                            message.negative_int_value = reader.int64();
                            break;
                        case 6:
                            message.double_value = reader.double();
                            break;
                        case 7:
                            message.string_value = reader.bytes();
                            break;
                        case 8:
                            message.aggregate_value = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UninterpretedOption message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UninterpretedOption.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i) {
                            var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                            if (error)
                                return "name." + error;
                        }
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        if (!$util.isString(message.identifier_value))
                            return "identifier_value: string expected";
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (!$util.isInteger(message.positive_int_value) && !(message.positive_int_value && $util.isInteger(message.positive_int_value.low) && $util.isInteger(message.positive_int_value.high)))
                            return "positive_int_value: integer|Long expected";
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (!$util.isInteger(message.negative_int_value) && !(message.negative_int_value && $util.isInteger(message.negative_int_value.low) && $util.isInteger(message.negative_int_value.high)))
                            return "negative_int_value: integer|Long expected";
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        if (typeof message.double_value !== "number")
                            return "double_value: number expected";
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        if (!(message.string_value && typeof message.string_value.length === "number" || $util.isString(message.string_value)))
                            return "string_value: buffer expected";
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        if (!$util.isString(message.aggregate_value))
                            return "aggregate_value: string expected";
                    return null;
                };
    
                /**
                 * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
                 */
                UninterpretedOption.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i) {
                            if (typeof object.name[i] !== "object")
                                throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                            message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                        }
                    }
                    if (object.identifier_value != null)
                        message.identifier_value = String(object.identifier_value);
                    if (object.positive_int_value != null)
                        if ($util.Long)
                            (message.positive_int_value = $util.Long.fromValue(object.positive_int_value)).unsigned = true;
                        else if (typeof object.positive_int_value === "string")
                            message.positive_int_value = parseInt(object.positive_int_value, 10);
                        else if (typeof object.positive_int_value === "number")
                            message.positive_int_value = object.positive_int_value;
                        else if (typeof object.positive_int_value === "object")
                            message.positive_int_value = new $util.LongBits(object.positive_int_value.low >>> 0, object.positive_int_value.high >>> 0).toNumber(true);
                    if (object.negative_int_value != null)
                        if ($util.Long)
                            (message.negative_int_value = $util.Long.fromValue(object.negative_int_value)).unsigned = false;
                        else if (typeof object.negative_int_value === "string")
                            message.negative_int_value = parseInt(object.negative_int_value, 10);
                        else if (typeof object.negative_int_value === "number")
                            message.negative_int_value = object.negative_int_value;
                        else if (typeof object.negative_int_value === "object")
                            message.negative_int_value = new $util.LongBits(object.negative_int_value.low >>> 0, object.negative_int_value.high >>> 0).toNumber();
                    if (object.double_value != null)
                        message.double_value = Number(object.double_value);
                    if (object.string_value != null)
                        if (typeof object.string_value === "string")
                            $util.base64.decode(object.string_value, message.string_value = $util.newBuffer($util.base64.length(object.string_value)), 0);
                        else if (object.string_value.length)
                            message.string_value = object.string_value;
                    if (object.aggregate_value != null)
                        message.aggregate_value = String(object.aggregate_value);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption
                 * @static
                 * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UninterpretedOption.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (options.defaults) {
                        object.identifier_value = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.positive_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.positive_int_value = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.negative_int_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.negative_int_value = options.longs === String ? "0" : 0;
                        object.double_value = 0;
                        if (options.bytes === String)
                            object.string_value = "";
                        else {
                            object.string_value = [];
                            if (options.bytes !== Array)
                                object.string_value = $util.newBuffer(object.string_value);
                        }
                        object.aggregate_value = "";
                    }
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                    }
                    if (message.identifier_value != null && message.hasOwnProperty("identifier_value"))
                        object.identifier_value = message.identifier_value;
                    if (message.positive_int_value != null && message.hasOwnProperty("positive_int_value"))
                        if (typeof message.positive_int_value === "number")
                            object.positive_int_value = options.longs === String ? String(message.positive_int_value) : message.positive_int_value;
                        else
                            object.positive_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.positive_int_value) : options.longs === Number ? new $util.LongBits(message.positive_int_value.low >>> 0, message.positive_int_value.high >>> 0).toNumber(true) : message.positive_int_value;
                    if (message.negative_int_value != null && message.hasOwnProperty("negative_int_value"))
                        if (typeof message.negative_int_value === "number")
                            object.negative_int_value = options.longs === String ? String(message.negative_int_value) : message.negative_int_value;
                        else
                            object.negative_int_value = options.longs === String ? $util.Long.prototype.toString.call(message.negative_int_value) : options.longs === Number ? new $util.LongBits(message.negative_int_value.low >>> 0, message.negative_int_value.high >>> 0).toNumber() : message.negative_int_value;
                    if (message.double_value != null && message.hasOwnProperty("double_value"))
                        object.double_value = options.json && !isFinite(message.double_value) ? String(message.double_value) : message.double_value;
                    if (message.string_value != null && message.hasOwnProperty("string_value"))
                        object.string_value = options.bytes === String ? $util.base64.encode(message.string_value, 0, message.string_value.length) : options.bytes === Array ? Array.prototype.slice.call(message.string_value) : message.string_value;
                    if (message.aggregate_value != null && message.hasOwnProperty("aggregate_value"))
                        object.aggregate_value = message.aggregate_value;
                    return object;
                };
    
                /**
                 * Converts this UninterpretedOption to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UninterpretedOption.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UninterpretedOption.NamePart = (function() {
    
                    /**
                     * Properties of a NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @interface INamePart
                     * @property {string} name_part NamePart name_part
                     * @property {boolean} is_extension NamePart is_extension
                     */
    
                    /**
                     * Constructs a new NamePart.
                     * @memberof google.protobuf.UninterpretedOption
                     * @classdesc Represents a NamePart.
                     * @implements INamePart
                     * @constructor
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     */
                    function NamePart(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * NamePart name_part.
                     * @member {string} name_part
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.name_part = "";
    
                    /**
                     * NamePart is_extension.
                     * @member {boolean} is_extension
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     */
                    NamePart.prototype.is_extension = false;
    
                    /**
                     * Creates a new NamePart instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                     */
                    NamePart.create = function create(properties) {
                        return new NamePart(properties);
                    };
    
                    /**
                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name_part);
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.is_extension);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name_part = reader.string();
                                break;
                            case 2:
                                message.is_extension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        if (!message.hasOwnProperty("name_part"))
                            throw $util.ProtocolError("missing required 'name_part'", { instance: message });
                        if (!message.hasOwnProperty("is_extension"))
                            throw $util.ProtocolError("missing required 'is_extension'", { instance: message });
                        return message;
                    };
    
                    /**
                     * Decodes a NamePart message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    NamePart.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a NamePart message.
                     * @function verify
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    NamePart.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (!$util.isString(message.name_part))
                            return "name_part: string expected";
                        if (typeof message.is_extension !== "boolean")
                            return "is_extension: boolean expected";
                        return null;
                    };
    
                    /**
                     * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                     */
                    NamePart.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                            return object;
                        var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                        if (object.name_part != null)
                            message.name_part = String(object.name_part);
                        if (object.is_extension != null)
                            message.is_extension = Boolean(object.is_extension);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @static
                     * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    NamePart.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.name_part = "";
                            object.is_extension = false;
                        }
                        if (message.name_part != null && message.hasOwnProperty("name_part"))
                            object.name_part = message.name_part;
                        if (message.is_extension != null && message.hasOwnProperty("is_extension"))
                            object.is_extension = message.is_extension;
                        return object;
                    };
    
                    /**
                     * Converts this NamePart to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.UninterpretedOption.NamePart
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    NamePart.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return NamePart;
                })();
    
                return UninterpretedOption;
            })();
    
            protobuf.SourceCodeInfo = (function() {
    
                /**
                 * Properties of a SourceCodeInfo.
                 * @memberof google.protobuf
                 * @interface ISourceCodeInfo
                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
                 */
    
                /**
                 * Constructs a new SourceCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a SourceCodeInfo.
                 * @implements ISourceCodeInfo
                 * @constructor
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 */
                function SourceCodeInfo(properties) {
                    this.location = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SourceCodeInfo location.
                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 */
                SourceCodeInfo.prototype.location = $util.emptyArray;
    
                /**
                 * Creates a new SourceCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
                 */
                SourceCodeInfo.create = function create(properties) {
                    return new SourceCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.location != null && message.location.length)
                        for (var i = 0; i < message.location.length; ++i)
                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SourceCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SourceCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.location != null && message.hasOwnProperty("location")) {
                        if (!Array.isArray(message.location))
                            return "location: array expected";
                        for (var i = 0; i < message.location.length; ++i) {
                            var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                            if (error)
                                return "location." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
                 */
                SourceCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo();
                    if (object.location) {
                        if (!Array.isArray(object.location))
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                        message.location = [];
                        for (var i = 0; i < object.location.length; ++i) {
                            if (typeof object.location[i] !== "object")
                                throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                            message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo
                 * @static
                 * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SourceCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.location = [];
                    if (message.location && message.location.length) {
                        object.location = [];
                        for (var j = 0; j < message.location.length; ++j)
                            object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SourceCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SourceCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SourceCodeInfo.Location = (function() {
    
                    /**
                     * Properties of a Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @interface ILocation
                     * @property {Array.<number>|null} [path] Location path
                     * @property {Array.<number>|null} [span] Location span
                     * @property {string|null} [leading_comments] Location leading_comments
                     * @property {string|null} [trailing_comments] Location trailing_comments
                     * @property {Array.<string>|null} [leading_detached_comments] Location leading_detached_comments
                     */
    
                    /**
                     * Constructs a new Location.
                     * @memberof google.protobuf.SourceCodeInfo
                     * @classdesc Represents a Location.
                     * @implements ILocation
                     * @constructor
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     */
                    function Location(properties) {
                        this.path = [];
                        this.span = [];
                        this.leading_detached_comments = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Location path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.path = $util.emptyArray;
    
                    /**
                     * Location span.
                     * @member {Array.<number>} span
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.span = $util.emptyArray;
    
                    /**
                     * Location leading_comments.
                     * @member {string} leading_comments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leading_comments = "";
    
                    /**
                     * Location trailing_comments.
                     * @member {string} trailing_comments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.trailing_comments = "";
    
                    /**
                     * Location leading_detached_comments.
                     * @member {Array.<string>} leading_detached_comments
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     */
                    Location.prototype.leading_detached_comments = $util.emptyArray;
    
                    /**
                     * Creates a new Location instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                     */
                    Location.create = function create(properties) {
                        return new Location(properties);
                    };
    
                    /**
                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.span != null && message.span.length) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork();
                            for (var i = 0; i < message.span.length; ++i)
                                writer.int32(message.span[i]);
                            writer.ldelim();
                        }
                        if (message.leading_comments != null && Object.hasOwnProperty.call(message, "leading_comments"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leading_comments);
                        if (message.trailing_comments != null && Object.hasOwnProperty.call(message, "trailing_comments"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailing_comments);
                        if (message.leading_detached_comments != null && message.leading_detached_comments.length)
                            for (var i = 0; i < message.leading_detached_comments.length; ++i)
                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leading_detached_comments[i]);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Location.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                } else
                                    message.span.push(reader.int32());
                                break;
                            case 3:
                                message.leading_comments = reader.string();
                                break;
                            case 4:
                                message.trailing_comments = reader.string();
                                break;
                            case 6:
                                if (!(message.leading_detached_comments && message.leading_detached_comments.length))
                                    message.leading_detached_comments = [];
                                message.leading_detached_comments.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a Location message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Location.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a Location message.
                     * @function verify
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Location.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.span != null && message.hasOwnProperty("span")) {
                            if (!Array.isArray(message.span))
                                return "span: array expected";
                            for (var i = 0; i < message.span.length; ++i)
                                if (!$util.isInteger(message.span[i]))
                                    return "span: integer[] expected";
                        }
                        if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                            if (!$util.isString(message.leading_comments))
                                return "leading_comments: string expected";
                        if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                            if (!$util.isString(message.trailing_comments))
                                return "trailing_comments: string expected";
                        if (message.leading_detached_comments != null && message.hasOwnProperty("leading_detached_comments")) {
                            if (!Array.isArray(message.leading_detached_comments))
                                return "leading_detached_comments: array expected";
                            for (var i = 0; i < message.leading_detached_comments.length; ++i)
                                if (!$util.isString(message.leading_detached_comments[i]))
                                    return "leading_detached_comments: string[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a Location message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.SourceCodeInfo.Location} Location
                     */
                    Location.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                            return object;
                        var message = new $root.google.protobuf.SourceCodeInfo.Location();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.span) {
                            if (!Array.isArray(object.span))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                            message.span = [];
                            for (var i = 0; i < object.span.length; ++i)
                                message.span[i] = object.span[i] | 0;
                        }
                        if (object.leading_comments != null)
                            message.leading_comments = String(object.leading_comments);
                        if (object.trailing_comments != null)
                            message.trailing_comments = String(object.trailing_comments);
                        if (object.leading_detached_comments) {
                            if (!Array.isArray(object.leading_detached_comments))
                                throw TypeError(".google.protobuf.SourceCodeInfo.Location.leading_detached_comments: array expected");
                            message.leading_detached_comments = [];
                            for (var i = 0; i < object.leading_detached_comments.length; ++i)
                                message.leading_detached_comments[i] = String(object.leading_detached_comments[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a Location message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @static
                     * @param {google.protobuf.SourceCodeInfo.Location} message Location
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Location.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.path = [];
                            object.span = [];
                            object.leading_detached_comments = [];
                        }
                        if (options.defaults) {
                            object.leading_comments = "";
                            object.trailing_comments = "";
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.span && message.span.length) {
                            object.span = [];
                            for (var j = 0; j < message.span.length; ++j)
                                object.span[j] = message.span[j];
                        }
                        if (message.leading_comments != null && message.hasOwnProperty("leading_comments"))
                            object.leading_comments = message.leading_comments;
                        if (message.trailing_comments != null && message.hasOwnProperty("trailing_comments"))
                            object.trailing_comments = message.trailing_comments;
                        if (message.leading_detached_comments && message.leading_detached_comments.length) {
                            object.leading_detached_comments = [];
                            for (var j = 0; j < message.leading_detached_comments.length; ++j)
                                object.leading_detached_comments[j] = message.leading_detached_comments[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this Location to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.SourceCodeInfo.Location
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Location.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Location;
                })();
    
                return SourceCodeInfo;
            })();
    
            protobuf.GeneratedCodeInfo = (function() {
    
                /**
                 * Properties of a GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @interface IGeneratedCodeInfo
                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
                 */
    
                /**
                 * Constructs a new GeneratedCodeInfo.
                 * @memberof google.protobuf
                 * @classdesc Represents a GeneratedCodeInfo.
                 * @implements IGeneratedCodeInfo
                 * @constructor
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 */
                function GeneratedCodeInfo(properties) {
                    this.annotation = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeneratedCodeInfo annotation.
                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 */
                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
    
                /**
                 * Creates a new GeneratedCodeInfo instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
                 */
                GeneratedCodeInfo.create = function create(properties) {
                    return new GeneratedCodeInfo(properties);
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.annotation != null && message.annotation.length)
                        for (var i = 0; i < message.annotation.length; ++i)
                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GeneratedCodeInfo message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeneratedCodeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.annotation != null && message.hasOwnProperty("annotation")) {
                        if (!Array.isArray(message.annotation))
                            return "annotation: array expected";
                        for (var i = 0; i < message.annotation.length; ++i) {
                            var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                            if (error)
                                return "annotation." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
                 */
                GeneratedCodeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo();
                    if (object.annotation) {
                        if (!Array.isArray(object.annotation))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                        message.annotation = [];
                        for (var i = 0; i < object.annotation.length; ++i) {
                            if (typeof object.annotation[i] !== "object")
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                            message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeneratedCodeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.annotation = [];
                    if (message.annotation && message.annotation.length) {
                        object.annotation = [];
                        for (var j = 0; j < message.annotation.length; ++j)
                            object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GeneratedCodeInfo to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GeneratedCodeInfo.Annotation = (function() {
    
                    /**
                     * Properties of an Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @interface IAnnotation
                     * @property {Array.<number>|null} [path] Annotation path
                     * @property {string|null} [source_file] Annotation source_file
                     * @property {number|null} [begin] Annotation begin
                     * @property {number|null} [end] Annotation end
                     */
    
                    /**
                     * Constructs a new Annotation.
                     * @memberof google.protobuf.GeneratedCodeInfo
                     * @classdesc Represents an Annotation.
                     * @implements IAnnotation
                     * @constructor
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     */
                    function Annotation(properties) {
                        this.path = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Annotation path.
                     * @member {Array.<number>} path
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.path = $util.emptyArray;
    
                    /**
                     * Annotation source_file.
                     * @member {string} source_file
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.source_file = "";
    
                    /**
                     * Annotation begin.
                     * @member {number} begin
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.begin = 0;
    
                    /**
                     * Annotation end.
                     * @member {number} end
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     */
                    Annotation.prototype.end = 0;
    
                    /**
                     * Creates a new Annotation instance using the specified properties.
                     * @function create
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                     */
                    Annotation.create = function create(properties) {
                        return new Annotation(properties);
                    };
    
                    /**
                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.path != null && message.path.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.path.length; ++i)
                                writer.int32(message.path[i]);
                            writer.ldelim();
                        }
                        if (message.source_file != null && Object.hasOwnProperty.call(message, "source_file"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.source_file);
                        if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                        if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer.
                     * @function decode
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                } else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                message.source_file = reader.string();
                                break;
                            case 3:
                                message.begin = reader.int32();
                                break;
                            case 4:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an Annotation message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Annotation.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an Annotation message.
                     * @function verify
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Annotation.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.path != null && message.hasOwnProperty("path")) {
                            if (!Array.isArray(message.path))
                                return "path: array expected";
                            for (var i = 0; i < message.path.length; ++i)
                                if (!$util.isInteger(message.path[i]))
                                    return "path: integer[] expected";
                        }
                        if (message.source_file != null && message.hasOwnProperty("source_file"))
                            if (!$util.isString(message.source_file))
                                return "source_file: string expected";
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            if (!$util.isInteger(message.begin))
                                return "begin: integer expected";
                        if (message.end != null && message.hasOwnProperty("end"))
                            if (!$util.isInteger(message.end))
                                return "end: integer expected";
                        return null;
                    };
    
                    /**
                     * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                     */
                    Annotation.fromObject = function fromObject(object) {
                        if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                            return object;
                        var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                        if (object.path) {
                            if (!Array.isArray(object.path))
                                throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                            message.path = [];
                            for (var i = 0; i < object.path.length; ++i)
                                message.path[i] = object.path[i] | 0;
                        }
                        if (object.source_file != null)
                            message.source_file = String(object.source_file);
                        if (object.begin != null)
                            message.begin = object.begin | 0;
                        if (object.end != null)
                            message.end = object.end | 0;
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @static
                     * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Annotation.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.path = [];
                        if (options.defaults) {
                            object.source_file = "";
                            object.begin = 0;
                            object.end = 0;
                        }
                        if (message.path && message.path.length) {
                            object.path = [];
                            for (var j = 0; j < message.path.length; ++j)
                                object.path[j] = message.path[j];
                        }
                        if (message.source_file != null && message.hasOwnProperty("source_file"))
                            object.source_file = message.source_file;
                        if (message.begin != null && message.hasOwnProperty("begin"))
                            object.begin = message.begin;
                        if (message.end != null && message.hasOwnProperty("end"))
                            object.end = message.end;
                        return object;
                    };
    
                    /**
                     * Converts this Annotation to JSON.
                     * @function toJSON
                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Annotation.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Annotation;
                })();
    
                return GeneratedCodeInfo;
            })();
    
            protobuf.Any = (function() {
    
                /**
                 * Properties of an Any.
                 * @memberof google.protobuf
                 * @interface IAny
                 * @property {string|null} [type_url] Any type_url
                 * @property {Uint8Array|null} [value] Any value
                 */
    
                /**
                 * Constructs a new Any.
                 * @memberof google.protobuf
                 * @classdesc Represents an Any.
                 * @implements IAny
                 * @constructor
                 * @param {google.protobuf.IAny=} [properties] Properties to set
                 */
                function Any(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Any type_url.
                 * @member {string} type_url
                 * @memberof google.protobuf.Any
                 * @instance
                 */
                Any.prototype.type_url = "";
    
                /**
                 * Any value.
                 * @member {Uint8Array} value
                 * @memberof google.protobuf.Any
                 * @instance
                 */
                Any.prototype.value = $util.newBuffer([]);
    
                /**
                 * Creates a new Any instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny=} [properties] Properties to set
                 * @returns {google.protobuf.Any} Any instance
                 */
                Any.create = function create(properties) {
                    return new Any(properties);
                };
    
                /**
                 * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny} message Any message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Any.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.IAny} message Any message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Any.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Any message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.Any} Any
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Any.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type_url = reader.string();
                            break;
                        case 2:
                            message.value = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Any message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.Any} Any
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Any.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Any message.
                 * @function verify
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Any.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        if (!$util.isString(message.type_url))
                            return "type_url: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                            return "value: buffer expected";
                    return null;
                };
    
                /**
                 * Creates an Any message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.Any} Any
                 */
                Any.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.Any)
                        return object;
                    var message = new $root.google.protobuf.Any();
                    if (object.type_url != null)
                        message.type_url = String(object.type_url);
                    if (object.value != null)
                        if (typeof object.value === "string")
                            $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                        else if (object.value.length)
                            message.value = object.value;
                    return message;
                };
    
                /**
                 * Creates a plain object from an Any message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.Any
                 * @static
                 * @param {google.protobuf.Any} message Any
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Any.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type_url = "";
                        if (options.bytes === String)
                            object.value = "";
                        else {
                            object.value = [];
                            if (options.bytes !== Array)
                                object.value = $util.newBuffer(object.value);
                        }
                    }
                    if (message.type_url != null && message.hasOwnProperty("type_url"))
                        object.type_url = message.type_url;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this Any to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.Any
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Any.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Any;
            })();
    
            return protobuf;
        })();
    
        return google;
    })();

    return $root;
});
